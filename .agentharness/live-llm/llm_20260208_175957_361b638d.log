AgentHarness LLM Live Output
Start: 2026-02-08T17:59:57
CWD: C:/Users/shlob/Pycharm Projects/harness-test/harness-test-4
Command: codex exec --skip-git-repo-check --full-auto --output-last-message "C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.codex_last_message.txt" --model gpt-5.3-codex -

Provider: Codex, Model: gpt-5.3-codex | Timeout: 600s
Prompt transport: stdin (678 chars)
LLM prompt begin (stdin)

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md
LLM prompt end (stdin)
Process PID: 19040
OpenAI Codex v0.98.0 (research preview)
--------
workdir: C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019c3dfb-308a-7d72-8f0b-1b44839dd651
--------
user

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md

deprecated: `enable_experimental_windows_sandbox` is deprecated. Use `[features].experimental_windows_sandbox` instead.
  Enable it with `--enable experimental_windows_sandbox` or `[features].experimental_windows_sandbox` in config.toml. See https://github.com/openai/codex/blob/main/docs/config.md#feature-flags for details.
mcp startup: no servers
codex
I’m going to start by reading `product-description.md`, then check `recent-changes.md` and `tasks.md`, and map the selected incomplete tasks to the folders/files they affect so I can implement them and update all required developer guides.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tasks.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw product-description.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Force | Select-Object Name,Mode,Length' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw recent-changes.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 201ms:
# FPS Bot Arena Implementation Tasks

## Project Setup & Architecture

- [x] Choose and document the technology stack (Python + Ursina or Web + Three.js)
- [x] Set up project structure with main folders (src, assets, config, tests)
- [x] Create root developer-guide.md documenting overall project architecture
- [x] Initialize package.json or requirements.txt with core dependencies
- [x] Set up basic project configuration files (config.py or config.js)

## Core Game Engine

- [ ] Implement main game loop with frame updates and delta time handling
- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
- [ ] Implement camera system with first-person perspective and mouse look controls
- [ ] Create input handler for WASD movement and mouse controls
- [ ] Implement player movement with collision detection
- [ ] Create physics system for projectile movement and collision
- [ ] Implement raycasting system for shooting mechanics
- [ ] Create game clock and time management system
 succeeded in 246ms:
# Product Description: FPS Bot Arena with "The Glitch"

## Overview
A First-Person Shooter (FPS) game where the player fights against waves of tactical AI bots in a multi-room indoor facility. The core loop involves combat, earning money from kills, and upgrading weapons. The game features a meta-twist ending where the final weapon, an RPG, triggers a simulated game crash (Fake BSOD/Error) upon use.

## Gameplay Mechanics
*   **Perspective:** First-Person.
*   **Controls:** Standard FPS controls (WASD + Mouse).
*   **Interaction:** Pressing 'B' opens a real-time inventory/shop wheel to buy and switch weapons.
*   **Win/Loss:**
    *   **Loss:** Player health reaches zero.
    *   **"Win":** Acquiring and firing the final RPG, triggering the "crash" ending.

## Economy & Progression
*   **Income:** Bots drop money as physical items upon death, which the player must collect.
*   **Weapon Progression:**
    1.  **Pistol:** Starting weapon.
    2.  **Shotgun:** High close-range damage.
    3.  **Assault Rifle:** Rapid fire, medium range.
    4.  **RPG (Final Weapon):** Expensive endgame item. Firing it causes a fake "Blue Screen of Death" or critical error message, effectively ending the session.
 succeeded in 246ms:
# Recent Changes


 succeeded in 248ms:

Name                   Mode   Length
----                   ----   ------
.agentharness          d-----       
.git                   d--h--       
.pytest_cache          d-----       
assets                 d-----       
config                 d-----       
review                 d-----       
src                    d-----       
tests                  d-----       
AGENTS.md              -a---- 1086  
CLAUDE.md              -a---- 1086  
developer-guide.md     -a---- 1096  
GEMINI.md              -a---- 1086  
product-description.md -a---- 2003  
questions.json         -a---- 3236  
recent-changes.md      -a---- 20    
requirements.txt       -a---- 20    
tasks.md               -a---- 7869  

thinking
**Planning task inspection**
codex
I’ve loaded the task list and project description; next I’m inspecting `src` and existing developer guides so I can select a coherent set of up to 10 tasks that can be fully completed end-to-end in this pass.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File src | Select-Object FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -Filter developer-guide.md | Select-Object FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 226ms:
# Developer Guide

## Project Architecture
This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.

## Directory Map
- `src/`: game systems and runtime code.
- `assets/`: static assets (models, audio, textures). Currently placeholder-only.
- `config/`: centralized runtime configuration modules.
- `tests/`: automated test suite.
- `requirements.txt`: pinned Python dependencies.

## Technology Stack Decision
- Language/runtime: Python 3.11+.
- Engine: Ursina (`ursina==6.1.2`).
- Rationale: aligns with quick prototype goals, simple geometric rendering, and first-person mechanics without heavy custom engine work.

## Current Runtime Config
- `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
- Game systems should import from `config.config` rather than duplicating constant values.
 succeeded in 267ms:

FullName                                                                
--------                                                                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\.gitkeep


 succeeded in 273ms:

FullName                                                                             
--------                                                                             
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md       
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\config\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\review\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\developer-guide.md 



thinking
**Assessing config and tests**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw config/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File tests | Select-Object FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File config | Select-Object FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 251ms:
# Developer Guide

## Purpose
`config/` contains centralized, importable configuration for gameplay and economy values.

## Files
- `config.py`: frozen dataclass-based configuration models and exported singleton config objects.

## How To Use
- Import `GAME_CONFIG` for core player/runtime constants.
- Import `ECONOMY_CONFIG` for weapon price progression values.
- Prefer updating values here rather than scattering literals across systems.

 succeeded in 257ms:

FullName                                                                                                              
--------                                                                                                              
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\developer-guide.md                                  
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_config.py                                      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_config.cpython-311-pytest-9.0.2.pyc


 succeeded in 260ms:
# Tests Developer Guide

## Overview
This directory contains the automated test suite for the FPS Bot Arena project.

## Testing Framework
- **Framework:** `pytest`
- **Rationale:** Standard, powerful, and easy-to-use testing framework for Python.

## Structure
- Test files should be named `test_<module_name>.py`.
- Tests should mirror the structure of the `src/` and `config/` directories where applicable.

## Running Tests
To run all tests, execute the following command from the project root:
```bash
pytest
```

 succeeded in 265ms:

FullName                                                                                               
--------                                                                                               
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\config\config.py                           
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\config\developer-guide.md                  
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\config\__init__.py                         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\config\__pycache__\config.cpython-311.pyc  
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\config\__pycache__\__init__.cpython-311.pyc


codex
I confirmed the repo is mostly scaffolded, so I’ll implement a foundational vertical slice (engine loop/state/input/player/weapons/projectiles/shop toggle/HUD) that lets us credibly complete 10 tasks, then update task tracking and all impacted developer guides.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw requirements.txt' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw config/config.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/test_config.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 206ms:
"""Project-wide configuration for the FPS Bot Arena prototype.

This module centralizes tunable values so gameplay systems can import
one source of truth instead of hardcoding constants.
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class GameConfig:
    """Core configuration values for the current prototype."""

    game_title: str = "FPS Bot Arena: The Glitch"
    start_health: int = 100
    start_money: int = 0
    mouse_sensitivity: float = 40.0
    walk_speed: float = 5.0


 succeeded in 228ms:
from dataclasses import FrozenInstanceError
import pytest
from config.config import GAME_CONFIG, ECONOMY_CONFIG, GameConfig, EconomyConfig

def test_game_config_defaults():
    """Verify that GameConfig loads with the expected default values."""
    assert GAME_CONFIG.game_title == "FPS Bot Arena: The Glitch"
    assert GAME_CONFIG.start_health == 100
    assert GAME_CONFIG.start_money == 0
    assert GAME_CONFIG.mouse_sensitivity == 40.0
    assert GAME_CONFIG.walk_speed == 5.0
    assert isinstance(GAME_CONFIG, GameConfig)

def test_economy_config_defaults():
    """Verify that EconomyConfig loads with the expected default values."""
    assert ECONOMY_CONFIG.shotgun_price == 300
    assert ECONOMY_CONFIG.assault_rifle_price == 900
    assert ECONOMY_CONFIG.rpg_price == 2500
    assert isinstance(ECONOMY_CONFIG, EconomyConfig)

 succeeded in 232ms:
ursina==6.1.2
pytest

thinking
**Selecting coherent implementation tasks**
codex
I have the implementation plan and I’m starting file edits now: adding core engine/player/weapon modules and tests that directly satisfy 10 selected tasks, then I’ll update developer guides and task tracking.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/__init__.py
"""Core runtime systems for FPS Bot Arena."""

apply_patch(auto_approved=true) exited 0 in 47ms:
Success. Updated the following files:
A src/core/__init__.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/game_state.py
"""Game state management for high-level flow transitions."""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum


class GameState(str, Enum):
    """Allowed top-level game states."""

    MENU = "menu"
    PLAYING = "playing"
    PAUSED = "paused"
    CRASHED = "crashed"


@dataclass
class GameStateManager:
    """Controls current state and validates state transitions."""

    current_state: GameState = GameState.MENU
    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])

    _ALLOWED_TRANSITIONS = {
        GameState.MENU: {GameState.PLAYING},
        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
        GameState.CRASHED: {GameState.MENU},
    }

    def can_transition_to(self, next_state: GameState) -> bool:
        """Return True when a transition is allowed from the current state."""
        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]

    def transition_to(self, next_state: GameState) -> None:
        """Move to a new valid state or raise ValueError."""
        if not self.can_transition_to(next_state):
            raise ValueError(
                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
            )
        self.current_state = next_state
        self.transition_history.append(next_state)

apply_patch(auto_approved=true) exited 0 in 64ms:
Success. Updated the following files:
A src/core/game_state.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/game_clock.py
"""Lightweight game clock and delta-time tracking."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class GameClock:
    """Tracks elapsed and per-frame timing."""

    elapsed_time: float = 0.0
    frame_count: int = 0
    _last_timestamp: float | None = None

    def tick(self, now: float) -> float:
        """Advance the clock and return frame delta-time in seconds."""
        if self._last_timestamp is None:
            self._last_timestamp = now
            return 0.0

        delta_time = max(0.0, now - self._last_timestamp)
        self._last_timestamp = now
        self.elapsed_time += delta_time
        self.frame_count += 1
        return delta_time

apply_patch(auto_approved=true) exited 0 in 82ms:
Success. Updated the following files:
A src/core/game_clock.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+


thinking
**Adjusting frame count increments**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/input_handler.py
"""Input translation for keyboard movement and mouse look."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass(frozen=True)
class InputSnapshot:
    """Raw frame input values from platform layer."""

    pressed_keys: set[str]
    mouse_delta_x: float = 0.0
    mouse_delta_y: float = 0.0


@dataclass(frozen=True)
class InputFrame:
    """Normalized input values consumed by gameplay systems."""

    move_x: float
    move_z: float
    look_yaw: float
    look_pitch: float


class InputHandler:
    """Normalizes raw control inputs into movement/look values."""

    def __init__(self, mouse_sensitivity: float) -> None:
        self.mouse_sensitivity = mouse_sensitivity

    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
        """Compute movement axis values and scaled look deltas."""
        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity

        return InputFrame(
            move_x=move_x,
            move_z=move_z,
            look_yaw=look_yaw,
            look_pitch=look_pitch,
        )

    @staticmethod
    def _axis(keys: set[str], positive: str, negative: str) -> float:
        if positive in keys and negative in keys:
            return 0.0
        if positive in keys:
            return 1.0
        if negative in keys:
            return -1.0
        return 0.0

apply_patch(auto_approved=true) exited 0 in 108ms:
Success. Updated the following files:
A src/core/input_handler.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+


thinking
**Planning game loop implementation**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/game_loop.py
"""Main game loop orchestration with delta-time updates."""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Callable

from src.core.game_clock import GameClock
from src.core.game_state import GameState, GameStateManager


FrameCallback = Callable[[float], None]


@dataclass
class GameLoop:
    """Owns frame stepping and update dispatch for active gameplay."""

    state_manager: GameStateManager
    clock: GameClock = field(default_factory=GameClock)
    _callbacks: list[FrameCallback] = field(default_factory=list)

    def register_update_callback(self, callback: FrameCallback) -> None:
        """Add a callback invoked each PLAYING frame with delta-time."""
        self._callbacks.append(callback)

    def step(self, now: float) -> float:
        """Run one frame step and return frame delta-time."""
        delta_time = self.clock.tick(now)
        if self.state_manager.current_state != GameState.PLAYING:
            return delta_time

        for callback in self._callbacks:
            callback(delta_time)
        return delta_time

apply_patch(auto_approved=true) exited 0 in 129ms:
Success. Updated the following files:
A src/core/game_loop.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+


thinking
**Defining base weapon class**
codex
I’m now adding the player and weapons domain models, including ammo/cooldown firing behavior so the selected player and pistol tasks are fully covered in code rather than stubs.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/__init__.py
"""Weapon definitions and shared weapon behavior."""

apply_patch(auto_approved=true) exited 0 in 144ms:
Success. Updated the following files:
A src/weapons/__init__.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/weapon.py
"""Base weapon model used by all weapon types."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class Weapon:
    """Shared weapon attributes and firing cooldown logic."""

    name: str
    damage: float
    fire_rate: float
    magazine_size: int
    reserve_ammo: int
    ammo_in_magazine: int | None = None
    _last_fired_at: float = -1_000_000.0

    def __post_init__(self) -> None:
        if self.ammo_in_magazine is None:
            self.ammo_in_magazine = self.magazine_size

    @property
    def cooldown_seconds(self) -> float:
        return 1.0 / self.fire_rate

    def can_fire(self, now: float) -> bool:
        """Return True when weapon has ammo and cooldown is ready."""
        has_ammo = self.ammo_in_magazine > 0
        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
        return has_ammo and off_cooldown

    def fire(self, now: float) -> bool:
        """Spend one ammo and start cooldown. Returns True on successful shot."""
        if not self.can_fire(now):
            return False
        self.ammo_in_magazine -= 1
        self._last_fired_at = now
        return True

apply_patch(auto_approved=true) exited 0 in 173ms:
Success. Updated the following files:
A src/weapons/weapon.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/pistol.py
"""Pistol weapon implementation."""

from __future__ import annotations

from src.weapons.weapon import Weapon


class Pistol(Weapon):
    """Default starter weapon with reliable semi-auto fire."""

    def __init__(self) -> None:
        super().__init__(
            name="Pistol",
            damage=20.0,
            fire_rate=3.0,
            magazine_size=12,
            reserve_ammo=48,
        )

apply_patch(auto_approved=true) exited 0 in 186ms:
Success. Updated the following files:
A src/weapons/pistol.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/player/__init__.py
"""Player state and gameplay behavior."""

apply_patch(auto_approved=true) exited 0 in 445ms:
Success. Updated the following files:
A src/player/__init__.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+


thinking
**Defining player class structure**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/player/player.py
"""Player model with health, currency, inventory, and shooting."""

from __future__ import annotations

from dataclasses import dataclass, field

from src.weapons.pistol import Pistol
from src.weapons.weapon import Weapon


@dataclass
class Player:
    """Encapsulates runtime player state and core gameplay actions."""

    max_health: int
    health: int
    money: int
    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
    rotation: tuple[float, float] = (0.0, 0.0)
    inventory: dict[str, Weapon] = field(default_factory=dict)
    equipped_weapon_name: str = "Pistol"

    @classmethod
    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
        """Create a player initialized with the starter pistol."""
        player = cls(
            max_health=start_health,
            health=start_health,
            money=start_money,
        )
        pistol = Pistol()
        player.inventory[pistol.name] = pistol
        return player

    @property
    def is_alive(self) -> bool:
        return self.health > 0

    @property
    def equipped_weapon(self) -> Weapon:
        return self.inventory[self.equipped_weapon_name]

    def set_rotation(self, yaw: float, pitch: float) -> None:
        self.rotation = (yaw, pitch)

    def set_position(self, x: float, y: float, z: float) -> None:
        self.position = (x, y, z)

    def apply_damage(self, damage: int) -> None:
        """Reduce health while clamping at zero."""
        if damage < 0:
            raise ValueError("Damage must be non-negative.")
        self.health = max(0, self.health - damage)

    def heal(self, amount: int) -> None:
        """Restore health without exceeding max health."""
        if amount < 0:
            raise ValueError("Heal amount must be non-negative.")
        self.health = min(self.max_health, self.health + amount)

    def add_money(self, amount: int) -> None:
        if amount < 0:
            raise ValueError("Amount must be non-negative.")
        self.money += amount

    def spend_money(self, amount: int) -> bool:
        if amount < 0:
            raise ValueError("Amount must be non-negative.")
        if self.money < amount:
            return False
        self.money -= amount
        return True

    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
        self.inventory[weapon.name] = weapon
        if auto_equip:
            self.equipped_weapon_name = weapon.name

    def equip_weapon(self, weapon_name: str) -> None:
        if weapon_name not in self.inventory:
            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
        self.equipped_weapon_name = weapon_name

    def shoot(self, now: float) -> bool:
        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
        if not self.is_alive:
            return False
        return self.equipped_weapon.fire(now)

apply_patch(auto_approved=true) exited 0 in 258ms:
Success. Updated the following files:
A src/player/player.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+


thinking
**Planning developer-guide creation**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/developer-guide.md
# Src Developer Guide

## Purpose
`src/` contains the game runtime modules for loop/state management, player logic, and weapons.

## Folder Overview
- `core/`: frame stepping, game clock, state machine, and input normalization.
- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
- `weapons/`: reusable weapon abstractions and concrete weapon implementations.

## Integration Flow
1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
4. Player actions call into weapon models for ammo/cooldown-validated firing.

apply_patch(auto_approved=true) exited 0 in 259ms:
Success. Updated the following files:
A src/developer-guide.md
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/developer-guide.md
# Core Developer Guide

## Purpose
`src/core/` provides engine-level systems that are independent from rendering backends.

## Files
- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.

## Behavior Notes
- `GameStateManager` blocks invalid transitions with `ValueError`.
- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).

apply_patch(auto_approved=true) exited 0 in 317ms:
Success. Updated the following files:
A src/core/developer-guide.md
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/player/developer-guide.md
# Player Developer Guide

## Purpose
`src/player/` owns all player-centric gameplay state and actions.

## Files
- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.

## Key Behaviors
- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
- Health logic:
  - `apply_damage` clamps health at `0`.
  - `heal` clamps health at `max_health`.
  - `is_alive` becomes `False` at `0` health.
- Economy logic:
  - `add_money` and `spend_money` reject negative inputs.
  - `spend_money` returns `False` when balance is insufficient.
- Inventory logic:
  - Weapons are stored by name.
  - `equip_weapon` requires ownership.
- Combat logic:
  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.

apply_patch(auto_approved=true) exited 0 in 299ms:
Success. Updated the following files:
A src/player/developer-guide.md
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/developer-guide.md
# Weapons Developer Guide

## Purpose
`src/weapons/` defines weapon behavior shared across loadout items.

## Files
- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
- `pistol.py`: starter `Pistol` implementation with tuned default stats.

## Key Behaviors
- `Weapon.fire(now)` returns `True` only when:
  - ammo remains in the magazine, and
  - cooldown time since last shot has elapsed.
- Successful fire events decrement `ammo_in_magazine` by exactly one.
- `Pistol` defaults:
  - damage `20`
  - fire rate `3` shots/sec
  - magazine size `12`
  - reserve ammo `48`

apply_patch(auto_approved=true) exited 0 in 332ms:
Success. Updated the following files:
A src/weapons/developer-guide.md
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+


thinking
**Updating root guide and adding tests**
codex
Core/player/weapons modules and their folder guides are in place. Next I’m adding targeted pytest coverage for each completed task, then I’ll update `tasks.md`, `recent-changes.md`, and the root developer guides to reflect the new behavior.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_core_systems.py
import pytest

from src.core.game_clock import GameClock
from src.core.game_loop import GameLoop
from src.core.game_state import GameState, GameStateManager
from src.core.input_handler import InputHandler, InputSnapshot


def test_game_clock_tracks_delta_and_elapsed_time():
    clock = GameClock()

    assert clock.tick(10.0) == 0.0
    assert clock.elapsed_time == 0.0
    assert clock.frame_count == 0

    assert clock.tick(10.25) == 0.25
    assert clock.tick(10.75) == 0.5
    assert clock.elapsed_time == 0.75
    assert clock.frame_count == 2


def test_state_manager_validates_transitions():
    manager = GameStateManager()

    manager.transition_to(GameState.PLAYING)
    manager.transition_to(GameState.PAUSED)
    manager.transition_to(GameState.PLAYING)
    manager.transition_to(GameState.CRASHED)
    manager.transition_to(GameState.MENU)

    assert manager.transition_history == [
        GameState.MENU,
        GameState.PLAYING,
        GameState.PAUSED,
        GameState.PLAYING,
        GameState.CRASHED,
        GameState.MENU,
    ]

    with pytest.raises(ValueError):
        manager.transition_to(GameState.PAUSED)


def test_input_handler_maps_wasd_and_mouse_look():
    handler = InputHandler(mouse_sensitivity=2.0)
    snapshot = InputSnapshot(
        pressed_keys={"w", "d"},
        mouse_delta_x=3.0,
        mouse_delta_y=-4.0,
    )

    frame = handler.build_frame(snapshot)
    assert frame.move_x == 1.0
    assert frame.move_z == 1.0
    assert frame.look_yaw == 6.0
    assert frame.look_pitch == 8.0


def test_game_loop_updates_only_while_playing():
    manager = GameStateManager()
    loop = GameLoop(state_manager=manager)
    deltas = []
    loop.register_update_callback(deltas.append)

    loop.step(1.0)
    loop.step(1.1)
    assert deltas == []

    manager.transition_to(GameState.PLAYING)
    loop.step(1.4)
    loop.step(1.8)
    assert deltas == [0.3, 0.4]

apply_patch(auto_approved=true) exited 0 in 347ms:
Success. Updated the following files:
A tests/test_core_systems.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..850206e15a8f660e6369d20eccc2abe20601ed4d
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,73 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == [0.3, 0.4]
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..850206e15a8f660e6369d20eccc2abe20601ed4d
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,73 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == [0.3, 0.4]
+

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_player_and_weapons.py
import pytest

from src.player.player import Player
from src.weapons.pistol import Pistol
from src.weapons.weapon import Weapon


def test_player_starter_loadout_and_properties():
    player = Player.with_starter_loadout(start_health=100, start_money=0)

    assert player.health == 100
    assert player.money == 0
    assert player.position == (0.0, 1.8, 0.0)
    assert player.rotation == (0.0, 0.0)
    assert player.equipped_weapon_name == "Pistol"
    assert isinstance(player.equipped_weapon, Pistol)


def test_player_health_system_damage_heal_and_death():
    player = Player.with_starter_loadout(start_health=100, start_money=0)
    player.apply_damage(30)
    assert player.health == 70
    assert player.is_alive

    player.apply_damage(1000)
    assert player.health == 0
    assert not player.is_alive

    player.heal(10)
    assert player.health == 10

    with pytest.raises(ValueError):
        player.apply_damage(-1)
    with pytest.raises(ValueError):
        player.heal(-1)


def test_player_money_tracking_and_spend_validation():
    player = Player.with_starter_loadout(start_health=100, start_money=50)

    player.add_money(25)
    assert player.money == 75

    assert player.spend_money(70) is True
    assert player.money == 5
    assert player.spend_money(6) is False
    assert player.money == 5

    with pytest.raises(ValueError):
        player.add_money(-1)
    with pytest.raises(ValueError):
        player.spend_money(-1)


def test_player_inventory_tracking_and_equipping():
    player = Player.with_starter_loadout(start_health=100, start_money=0)
    custom_weapon = Weapon(
        name="TestGun",
        damage=5,
        fire_rate=5,
        magazine_size=2,
        reserve_ammo=0,
    )

    player.add_weapon(custom_weapon)
    player.equip_weapon("TestGun")
    assert player.equipped_weapon_name == "TestGun"

    with pytest.raises(ValueError):
        player.equip_weapon("MissingWeapon")


def test_base_weapon_fire_rate_and_ammo_consumption():
    weapon = Weapon(
        name="BaseWeapon",
        damage=10,
        fire_rate=2,
        magazine_size=2,
        reserve_ammo=0,
    )
    assert weapon.ammo_in_magazine == 2

    assert weapon.fire(1.0) is True
    assert weapon.ammo_in_magazine == 1
    assert weapon.fire(1.2) is False
    assert weapon.fire(1.5) is True
    assert weapon.ammo_in_magazine == 0
    assert weapon.fire(2.5) is False


def test_pistol_defaults_and_player_shooting_behavior():
    pistol = Pistol()
    assert pistol.name == "Pistol"
    assert pistol.damage == 20.0
    assert pistol.fire_rate == 3.0
    assert pistol.magazine_size == 12
    assert pistol.reserve_ammo == 48

    player = Player.with_starter_loadout(start_health=100, start_money=0)
    assert player.shoot(1.0) is True
    assert player.equipped_weapon.ammo_in_magazine == 11
    assert player.shoot(1.1) is False

    player.apply_damage(100)
    assert player.shoot(2.0) is False

apply_patch(auto_approved=true) exited 0 in 374ms:
Success. Updated the following files:
A tests/test_player_and_weapons.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..850206e15a8f660e6369d20eccc2abe20601ed4d
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,73 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == [0.3, 0.4]
+
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..850206e15a8f660e6369d20eccc2abe20601ed4d
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,73 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == [0.3, 0.4]
+
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Preparing package init and test updates**
codex
I’ve finished implementation and tests for the selected systems; I’m running `pytest` now to validate everything before updating `tasks.md` and `recent-changes.md`.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 exited 1 in 623ms:

=================================== ERRORS ====================================
____________________ ERROR collecting tests/test_config.py ____________________
ImportError while importing test module 'C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_config.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
..\..\..\AppData\Local\Programs\Python\Python311\Lib\importlib\__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests\test_config.py:3: in <module>
    from config.config import GAME_CONFIG, ECONOMY_CONFIG, GameConfig, EconomyConfig
E   ModuleNotFoundError: No module named 'config'
_________________ ERROR collecting tests/test_core_systems.py _________________
ImportError while importing test module 'C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_core_systems.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
..\..\..\AppData\Local\Programs\Python\Python311\Lib\importlib\__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests\test_core_systems.py:3: in <module>
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..850206e15a8f660e6369d20eccc2abe20601ed4d
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,73 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == [0.3, 0.4]
+
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Adding sys.path fix in conftest**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/conftest.py
"""Pytest configuration for import resolution."""

from __future__ import annotations

import sys
from pathlib import Path


ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

apply_patch(auto_approved=true) exited 0 in 378ms:
Success. Updated the following files:
A tests/conftest.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..850206e15a8f660e6369d20eccc2abe20601ed4d
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,73 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == [0.3, 0.4]
+
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..850206e15a8f660e6369d20eccc2abe20601ed4d
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,73 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == [0.3, 0.4]
+
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Running tests**
codex
I hit an import-path issue during test collection; I added `tests/conftest.py` to put the repo root on `sys.path` and I’m rerunning the suite now.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 exited 1 in 554ms:
......F......                                                            [100%]
================================== FAILURES ===================================
__________________ test_game_loop_updates_only_while_playing __________________

    def test_game_loop_updates_only_while_playing():
        manager = GameStateManager()
        loop = GameLoop(state_manager=manager)
        deltas = []
        loop.register_update_callback(deltas.append)
    
        loop.step(1.0)
        loop.step(1.1)
        assert deltas == []
    
        manager.transition_to(GameState.PLAYING)
        loop.step(1.4)
        loop.step(1.8)
>       assert deltas == [0.3, 0.4]
E       assert [0.2999999999...0000000000013] == [0.3, 0.4]
E         
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..850206e15a8f660e6369d20eccc2abe20601ed4d
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,73 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == [0.3, 0.4]
+
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Fixing approximate float test**
codex
One test failed due to floating-point precision in delta-time assertions; I’m adjusting that assertion to use `pytest.approx` and validating again.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_core_systems.py
@@ -71,3 +71,2 @@
     loop.step(1.8)
-    assert deltas == [0.3, 0.4]
-
+    assert deltas == pytest.approx([0.3, 0.4])
apply_patch(auto_approved=true) exited 0 in 390ms:
Success. Updated the following files:
M tests/test_core_systems.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+

exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 537ms:
.............                                                            [100%]
13 passed in 0.04s
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Selecting completed tasks for updates**
codex
All selected implementations are passing tests. I’m now updating the root and tests developer guides, then I’ll mark exactly 10 completed tasks in `tasks.md` and log the work in `recent-changes.md`.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tasks.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 201ms:
# Developer Guide

## Project Architecture
This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.

## Directory Map
- `src/`: game systems and runtime code.
- `assets/`: static assets (models, audio, textures). Currently placeholder-only.
- `config/`: centralized runtime configuration modules.
- `tests/`: automated test suite.
- `requirements.txt`: pinned Python dependencies.

## Technology Stack Decision
- Language/runtime: Python 3.11+.
- Engine: Ursina (`ursina==6.1.2`).
- Rationale: aligns with quick prototype goals, simple geometric rendering, and first-person mechanics without heavy custom engine work.

## Current Runtime Config
- `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
- Game systems should import from `config.config` rather than duplicating constant values.
 succeeded in 201ms:
# FPS Bot Arena Implementation Tasks

## Project Setup & Architecture

- [x] Choose and document the technology stack (Python + Ursina or Web + Three.js)
- [x] Set up project structure with main folders (src, assets, config, tests)
- [x] Create root developer-guide.md documenting overall project architecture
- [x] Initialize package.json or requirements.txt with core dependencies
- [x] Set up basic project configuration files (config.py or config.js)

## Core Game Engine

- [ ] Implement main game loop with frame updates and delta time handling
- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
- [ ] Implement camera system with first-person perspective and mouse look controls
- [ ] Create input handler for WASD movement and mouse controls
- [ ] Implement player movement with collision detection
- [ ] Create physics system for projectile movement and collision
- [ ] Implement raycasting system for shooting mechanics
- [ ] Create game clock and time management system
 succeeded in 188ms:
# Tests Developer Guide

## Overview
This directory contains the automated test suite for the FPS Bot Arena project.

## Testing Framework
- **Framework:** `pytest`
- **Rationale:** Standard, powerful, and easy-to-use testing framework for Python.

## Structure
- Test files should be named `test_<module_name>.py`.
- Tests should mirror the structure of the `src/` and `config/` directories where applicable.

## Running Tests
To run all tests, execute the following command from the project root:
```bash
pytest
```

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Choosing core 10 tasks**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md
@@ -3,6 +3,16 @@
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
@@ -21,4 +31,12 @@
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
apply_patch(auto_approved=true) exited 0 in 405ms:
Success. Updated the following files:
M developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Planning tests guide update**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/developer-guide.md
@@ -12,2 +12,8 @@
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
apply_patch(auto_approved=true) exited 0 in 410ms:
Success. Updated the following files:
M tests/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index e547605fc4fe3c4c0aed63e6dd409a633e6b2e88..6c1bc5780d8c0fd4ec59223480d74aaab239f16d
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -10,6 +10,12 @@
 ## Structure
 - Test files should be named `test_<module_name>.py`.
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index e547605fc4fe3c4c0aed63e6dd409a633e6b2e88..6c1bc5780d8c0fd4ec59223480d74aaab239f16d
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -10,6 +10,12 @@
 ## Structure
 - Test files should be named `test_<module_name>.py`.
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Updating documentation and tasks**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tasks.md
@@ -12,6 +12,6 @@
 
-- [ ] Implement main game loop with frame updates and delta time handling
-- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
+- [x] Implement main game loop with frame updates and delta time handling
+- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
 - [ ] Implement camera system with first-person perspective and mouse look controls
-- [ ] Create input handler for WASD movement and mouse controls
+- [x] Create input handler for WASD movement and mouse controls
 - [ ] Implement player movement with collision detection
@@ -23,8 +23,8 @@
 
-- [ ] Create Player class with health, position, and rotation properties
-- [ ] Implement player health system with damage and death handling
-- [ ] Create player money/currency tracking system
-- [ ] Implement player inventory system to track owned weapons
+- [x] Create Player class with health, position, and rotation properties
+- [x] Implement player health system with damage and death handling
+- [x] Create player money/currency tracking system
+- [x] Implement player inventory system to track owned weapons
 - [ ] Create player weapon switching logic
-- [ ] Implement player shooting mechanics with ammo consumption
+- [x] Implement player shooting mechanics with ammo consumption
 - [ ] Add player respawn or game over logic on death
@@ -34,4 +34,4 @@
 
-- [ ] Create base Weapon class with common properties (damage, ammo, fire rate)
-- [ ] Implement Pistol weapon with stats and firing behavior
+- [x] Create base Weapon class with common properties (damage, ammo, fire rate)
+- [x] Implement Pistol weapon with stats and firing behavior
 - [ ] Implement Shotgun weapon with spread pattern and high damage
apply_patch(auto_approved=true) exited 0 in 491ms:
Success. Updated the following files:
M tasks.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tasks.md b/tasks.md
index f6820cb13076e385436a95d4c0edb60bab62a653..770ff01b25baf8262f6012c025852e3bde9193f0
--- a/tasks.md
+++ b/tasks.md
@@ -10,10 +10,10 @@
 
 ## Core Game Engine
 
-- [ ] Implement main game loop with frame updates and delta time handling
-- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
+- [x] Implement main game loop with frame updates and delta time handling
+- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
 - [ ] Implement camera system with first-person perspective and mouse look controls
-- [ ] Create input handler for WASD movement and mouse controls
+- [x] Create input handler for WASD movement and mouse controls
 - [ ] Implement player movement with collision detection
 - [ ] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
@@ -21,19 +21,19 @@
 
 ## Player Systems
 
-- [ ] Create Player class with health, position, and rotation properties
-- [ ] Implement player health system with damage and death handling
-- [ ] Create player money/currency tracking system
-- [ ] Implement player inventory system to track owned weapons
+- [x] Create Player class with health, position, and rotation properties
+- [x] Implement player health system with damage and death handling
+- [x] Create player money/currency tracking system
+- [x] Implement player inventory system to track owned weapons
 - [ ] Create player weapon switching logic
-- [ ] Implement player shooting mechanics with ammo consumption
+- [x] Implement player shooting mechanics with ammo consumption
 - [ ] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
-- [ ] Create base Weapon class with common properties (damage, ammo, fire rate)
-- [ ] Implement Pistol weapon with stats and firing behavior
+- [x] Create base Weapon class with common properties (damage, ammo, fire rate)
+- [x] Implement Pistol weapon with stats and firing behavior
 - [ ] Implement Shotgun weapon with spread pattern and high damage
 - [ ] Implement Assault Rifle weapon with rapid fire mechanics
 - [ ] Implement RPG weapon with special "crash" trigger behavior
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index e547605fc4fe3c4c0aed63e6dd409a633e6b2e88..6c1bc5780d8c0fd4ec59223480d74aaab239f16d
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -10,6 +10,12 @@
 ## Structure
 - Test files should be named `test_<module_name>.py`.
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tasks.md b/tasks.md
index f6820cb13076e385436a95d4c0edb60bab62a653..770ff01b25baf8262f6012c025852e3bde9193f0
--- a/tasks.md
+++ b/tasks.md
@@ -10,10 +10,10 @@
 
 ## Core Game Engine
 
-- [ ] Implement main game loop with frame updates and delta time handling
-- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
+- [x] Implement main game loop with frame updates and delta time handling
+- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
 - [ ] Implement camera system with first-person perspective and mouse look controls
-- [ ] Create input handler for WASD movement and mouse controls
+- [x] Create input handler for WASD movement and mouse controls
 - [ ] Implement player movement with collision detection
 - [ ] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
@@ -21,19 +21,19 @@
 
 ## Player Systems
 
-- [ ] Create Player class with health, position, and rotation properties
-- [ ] Implement player health system with damage and death handling
-- [ ] Create player money/currency tracking system
-- [ ] Implement player inventory system to track owned weapons
+- [x] Create Player class with health, position, and rotation properties
+- [x] Implement player health system with damage and death handling
+- [x] Create player money/currency tracking system
+- [x] Implement player inventory system to track owned weapons
 - [ ] Create player weapon switching logic
-- [ ] Implement player shooting mechanics with ammo consumption
+- [x] Implement player shooting mechanics with ammo consumption
 - [ ] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
-- [ ] Create base Weapon class with common properties (damage, ammo, fire rate)
-- [ ] Implement Pistol weapon with stats and firing behavior
+- [x] Create base Weapon class with common properties (damage, ammo, fire rate)
+- [x] Implement Pistol weapon with stats and firing behavior
 - [ ] Implement Shotgun weapon with spread pattern and high damage
 - [ ] Implement Assault Rifle weapon with rapid fire mechanics
 - [ ] Implement RPG weapon with special "crash" trigger behavior
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index e547605fc4fe3c4c0aed63e6dd409a633e6b2e88..6c1bc5780d8c0fd4ec59223480d74aaab239f16d
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -10,6 +10,12 @@
 ## Structure
 - Test files should be named `test_<module_name>.py`.
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Updating recent changes log**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
-
+# Recent Changes
+
+## 2026-02-08
+
+- Implemented foundational gameplay runtime modules:
+  - `src/core/game_state.py`: validated game state manager for `menu`, `playing`, `paused`, `crashed`.
+  - `src/core/game_clock.py`: delta-time and elapsed-time tracking.
+  - `src/core/input_handler.py`: WASD + mouse-look input normalization.
+  - `src/core/game_loop.py`: frame-stepped loop that dispatches updates only in `playing`.
+- Implemented player systems in `src/player/player.py`:
+  - player creation with position/rotation/health/money
+  - health damage/heal/death behavior
+  - money add/spend behavior with validation
+  - weapon inventory ownership and equip rules
+  - shooting through equipped weapon with ammo/cooldown enforcement
+- Implemented weapon systems:
+  - `src/weapons/weapon.py`: reusable weapon base class with common stats and cooldown-aware firing.
+  - `src/weapons/pistol.py`: starter pistol stats and behavior.
+- Added/updated developer documentation:
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+  - root `developer-guide.md`
+- Added automated tests and fixed import configuration:
+  - `tests/conftest.py`
+  - `tests/test_core_systems.py`
+  - `tests/test_player_and_weapons.py`
+- Validation: `pytest -q` passes (`13 passed`).
apply_patch(auto_approved=true) exited 0 in 470ms:
Success. Updated the following files:
M recent-changes.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..714c8d332ec63cc44502119bacd0b72474ebde25
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
-
+# Recent Changes
+
+## 2026-02-08
+
+- Implemented foundational gameplay runtime modules:
+  - `src/core/game_state.py`: validated game state manager for `menu`, `playing`, `paused`, `crashed`.
+  - `src/core/game_clock.py`: delta-time and elapsed-time tracking.
+  - `src/core/input_handler.py`: WASD + mouse-look input normalization.
+  - `src/core/game_loop.py`: frame-stepped loop that dispatches updates only in `playing`.
+- Implemented player systems in `src/player/player.py`:
+  - player creation with position/rotation/health/money
+  - health damage/heal/death behavior
+  - money add/spend behavior with validation
+  - weapon inventory ownership and equip rules
+  - shooting through equipped weapon with ammo/cooldown enforcement
+- Implemented weapon systems:
+  - `src/weapons/weapon.py`: reusable weapon base class with common stats and cooldown-aware firing.
+  - `src/weapons/pistol.py`: starter pistol stats and behavior.
+- Added/updated developer documentation:
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+  - root `developer-guide.md`
+- Added automated tests and fixed import configuration:
+  - `tests/conftest.py`
+  - `tests/test_core_systems.py`
+  - `tests/test_player_and_weapons.py`
+- Validation: `pytest -q` passes (`13 passed`).
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tasks.md b/tasks.md
index f6820cb13076e385436a95d4c0edb60bab62a653..770ff01b25baf8262f6012c025852e3bde9193f0
--- a/tasks.md
+++ b/tasks.md
@@ -10,10 +10,10 @@
 
 ## Core Game Engine
 
-- [ ] Implement main game loop with frame updates and delta time handling
-- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
+- [x] Implement main game loop with frame updates and delta time handling
+- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
 - [ ] Implement camera system with first-person perspective and mouse look controls
-- [ ] Create input handler for WASD movement and mouse controls
+- [x] Create input handler for WASD movement and mouse controls
 - [ ] Implement player movement with collision detection
 - [ ] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
@@ -21,19 +21,19 @@
 
 ## Player Systems
 
-- [ ] Create Player class with health, position, and rotation properties
-- [ ] Implement player health system with damage and death handling
-- [ ] Create player money/currency tracking system
-- [ ] Implement player inventory system to track owned weapons
+- [x] Create Player class with health, position, and rotation properties
+- [x] Implement player health system with damage and death handling
+- [x] Create player money/currency tracking system
+- [x] Implement player inventory system to track owned weapons
 - [ ] Create player weapon switching logic
-- [ ] Implement player shooting mechanics with ammo consumption
+- [x] Implement player shooting mechanics with ammo consumption
 - [ ] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
-- [ ] Create base Weapon class with common properties (damage, ammo, fire rate)
-- [ ] Implement Pistol weapon with stats and firing behavior
+- [x] Create base Weapon class with common properties (damage, ammo, fire rate)
+- [x] Implement Pistol weapon with stats and firing behavior
 - [ ] Implement Shotgun weapon with spread pattern and high damage
 - [ ] Implement Assault Rifle weapon with rapid fire mechanics
 - [ ] Implement RPG weapon with special "crash" trigger behavior
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index e547605fc4fe3c4c0aed63e6dd409a633e6b2e88..6c1bc5780d8c0fd4ec59223480d74aaab239f16d
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -10,6 +10,12 @@
 ## Structure
 - Test files should be named `test_<module_name>.py`.
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..714c8d332ec63cc44502119bacd0b72474ebde25
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
-
+# Recent Changes
+
+## 2026-02-08
+
+- Implemented foundational gameplay runtime modules:
+  - `src/core/game_state.py`: validated game state manager for `menu`, `playing`, `paused`, `crashed`.
+  - `src/core/game_clock.py`: delta-time and elapsed-time tracking.
+  - `src/core/input_handler.py`: WASD + mouse-look input normalization.
+  - `src/core/game_loop.py`: frame-stepped loop that dispatches updates only in `playing`.
+- Implemented player systems in `src/player/player.py`:
+  - player creation with position/rotation/health/money
+  - health damage/heal/death behavior
+  - money add/spend behavior with validation
+  - weapon inventory ownership and equip rules
+  - shooting through equipped weapon with ammo/cooldown enforcement
+- Implemented weapon systems:
+  - `src/weapons/weapon.py`: reusable weapon base class with common stats and cooldown-aware firing.
+  - `src/weapons/pistol.py`: starter pistol stats and behavior.
+- Added/updated developer documentation:
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+  - root `developer-guide.md`
+- Added automated tests and fixed import configuration:
+  - `tests/conftest.py`
+  - `tests/test_core_systems.py`
+  - `tests/test_player_and_weapons.py`
+- Validation: `pytest -q` passes (`13 passed`).
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tasks.md b/tasks.md
index f6820cb13076e385436a95d4c0edb60bab62a653..770ff01b25baf8262f6012c025852e3bde9193f0
--- a/tasks.md
+++ b/tasks.md
@@ -10,10 +10,10 @@
 
 ## Core Game Engine
 
-- [ ] Implement main game loop with frame updates and delta time handling
-- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
+- [x] Implement main game loop with frame updates and delta time handling
+- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
 - [ ] Implement camera system with first-person perspective and mouse look controls
-- [ ] Create input handler for WASD movement and mouse controls
+- [x] Create input handler for WASD movement and mouse controls
 - [ ] Implement player movement with collision detection
 - [ ] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
@@ -21,19 +21,19 @@
 
 ## Player Systems
 
-- [ ] Create Player class with health, position, and rotation properties
-- [ ] Implement player health system with damage and death handling
-- [ ] Create player money/currency tracking system
-- [ ] Implement player inventory system to track owned weapons
+- [x] Create Player class with health, position, and rotation properties
+- [x] Implement player health system with damage and death handling
+- [x] Create player money/currency tracking system
+- [x] Implement player inventory system to track owned weapons
 - [ ] Create player weapon switching logic
-- [ ] Implement player shooting mechanics with ammo consumption
+- [x] Implement player shooting mechanics with ammo consumption
 - [ ] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
-- [ ] Create base Weapon class with common properties (damage, ammo, fire rate)
-- [ ] Implement Pistol weapon with stats and firing behavior
+- [x] Create base Weapon class with common properties (damage, ammo, fire rate)
+- [x] Implement Pistol weapon with stats and firing behavior
 - [ ] Implement Shotgun weapon with spread pattern and high damage
 - [ ] Implement Assault Rifle weapon with rapid fire mechanics
 - [ ] Implement RPG weapon with special "crash" trigger behavior
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index e547605fc4fe3c4c0aed63e6dd409a633e6b2e88..6c1bc5780d8c0fd4ec59223480d74aaab239f16d
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -10,6 +10,12 @@
 ## Structure
 - Test files should be named `test_<module_name>.py`.
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Reviewing project structure and tasks**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tasks.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'git status --short' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 199ms:
# FPS Bot Arena Implementation Tasks

## Project Setup & Architecture

- [x] Choose and document the technology stack (Python + Ursina or Web + Three.js)
- [x] Set up project structure with main folders (src, assets, config, tests)
- [x] Create root developer-guide.md documenting overall project architecture
- [x] Initialize package.json or requirements.txt with core dependencies
- [x] Set up basic project configuration files (config.py or config.js)

## Core Game Engine

- [x] Implement main game loop with frame updates and delta time handling
- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
- [ ] Implement camera system with first-person perspective and mouse look controls
- [x] Create input handler for WASD movement and mouse controls
- [ ] Implement player movement with collision detection
- [ ] Create physics system for projectile movement and collision
- [ ] Implement raycasting system for shooting mechanics
- [ ] Create game clock and time management system
 succeeded in 207ms:
 M .agentharness/git-commit-message.txt
 D .codex_last_message.txt
 M developer-guide.md
 M recent-changes.md
 M tasks.md
 M tests/developer-guide.md
?? .agentharness/live-llm/llm_20260208_175957_361b638d.log
?? src/core/
?? src/developer-guide.md
?? src/player/
?? src/weapons/
?? tests/__pycache__/conftest.cpython-311-pytest-9.0.2.pyc
?? tests/__pycache__/test_core_systems.cpython-311-pytest-9.0.2.pyc
?? tests/__pycache__/test_player_and_weapons.cpython-311-pytest-9.0.2.pyc
?? tests/conftest.py
?? tests/test_core_systems.py
?? tests/test_player_and_weapons.py
 succeeded in 547ms:
.............                                                            [100%]
13 passed in 0.03s
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..714c8d332ec63cc44502119bacd0b72474ebde25
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
-
+# Recent Changes
+
+## 2026-02-08
+
+- Implemented foundational gameplay runtime modules:
+  - `src/core/game_state.py`: validated game state manager for `menu`, `playing`, `paused`, `crashed`.
+  - `src/core/game_clock.py`: delta-time and elapsed-time tracking.
+  - `src/core/input_handler.py`: WASD + mouse-look input normalization.
+  - `src/core/game_loop.py`: frame-stepped loop that dispatches updates only in `playing`.
+- Implemented player systems in `src/player/player.py`:
+  - player creation with position/rotation/health/money
+  - health damage/heal/death behavior
+  - money add/spend behavior with validation
+  - weapon inventory ownership and equip rules
+  - shooting through equipped weapon with ammo/cooldown enforcement
+- Implemented weapon systems:
+  - `src/weapons/weapon.py`: reusable weapon base class with common stats and cooldown-aware firing.
+  - `src/weapons/pistol.py`: starter pistol stats and behavior.
+- Added/updated developer documentation:
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+  - root `developer-guide.md`
+- Added automated tests and fixed import configuration:
+  - `tests/conftest.py`
+  - `tests/test_core_systems.py`
+  - `tests/test_player_and_weapons.py`
+- Validation: `pytest -q` passes (`13 passed`).
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tasks.md b/tasks.md
index f6820cb13076e385436a95d4c0edb60bab62a653..770ff01b25baf8262f6012c025852e3bde9193f0
--- a/tasks.md
+++ b/tasks.md
@@ -10,10 +10,10 @@
 
 ## Core Game Engine
 
-- [ ] Implement main game loop with frame updates and delta time handling
-- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
+- [x] Implement main game loop with frame updates and delta time handling
+- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
 - [ ] Implement camera system with first-person perspective and mouse look controls
-- [ ] Create input handler for WASD movement and mouse controls
+- [x] Create input handler for WASD movement and mouse controls
 - [ ] Implement player movement with collision detection
 - [ ] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
@@ -21,19 +21,19 @@
 
 ## Player Systems
 
-- [ ] Create Player class with health, position, and rotation properties
-- [ ] Implement player health system with damage and death handling
-- [ ] Create player money/currency tracking system
-- [ ] Implement player inventory system to track owned weapons
+- [x] Create Player class with health, position, and rotation properties
+- [x] Implement player health system with damage and death handling
+- [x] Create player money/currency tracking system
+- [x] Implement player inventory system to track owned weapons
 - [ ] Create player weapon switching logic
-- [ ] Implement player shooting mechanics with ammo consumption
+- [x] Implement player shooting mechanics with ammo consumption
 - [ ] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
-- [ ] Create base Weapon class with common properties (damage, ammo, fire rate)
-- [ ] Implement Pistol weapon with stats and firing behavior
+- [x] Create base Weapon class with common properties (damage, ammo, fire rate)
+- [x] Implement Pistol weapon with stats and firing behavior
 - [ ] Implement Shotgun weapon with spread pattern and high damage
 - [ ] Implement Assault Rifle weapon with rapid fire mechanics
 - [ ] Implement RPG weapon with special "crash" trigger behavior
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index e547605fc4fe3c4c0aed63e6dd409a633e6b2e88..6c1bc5780d8c0fd4ec59223480d74aaab239f16d
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -10,6 +10,12 @@
 ## Structure
 - Test files should be named `test_<module_name>.py`.
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Planning cleanup of pycache artifacts**
codex
I validated the work (`13 passed`) and found generated `__pycache__` artifacts from test runs; I’m removing those transient files so the code changes stay clean.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -Directory -Filter __pycache__ | Remove-Item -Recurse -Force' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 exited -1 in 0ms:
`"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -Directory -Filter __pycache__ | Remove-Item -Recurse -Force'` rejected: blocked by policy
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..714c8d332ec63cc44502119bacd0b72474ebde25
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
-
+# Recent Changes
+
+## 2026-02-08
+
+- Implemented foundational gameplay runtime modules:
+  - `src/core/game_state.py`: validated game state manager for `menu`, `playing`, `paused`, `crashed`.
+  - `src/core/game_clock.py`: delta-time and elapsed-time tracking.
+  - `src/core/input_handler.py`: WASD + mouse-look input normalization.
+  - `src/core/game_loop.py`: frame-stepped loop that dispatches updates only in `playing`.
+- Implemented player systems in `src/player/player.py`:
+  - player creation with position/rotation/health/money
+  - health damage/heal/death behavior
+  - money add/spend behavior with validation
+  - weapon inventory ownership and equip rules
+  - shooting through equipped weapon with ammo/cooldown enforcement
+- Implemented weapon systems:
+  - `src/weapons/weapon.py`: reusable weapon base class with common stats and cooldown-aware firing.
+  - `src/weapons/pistol.py`: starter pistol stats and behavior.
+- Added/updated developer documentation:
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+  - root `developer-guide.md`
+- Added automated tests and fixed import configuration:
+  - `tests/conftest.py`
+  - `tests/test_core_systems.py`
+  - `tests/test_player_and_weapons.py`
+- Validation: `pytest -q` passes (`13 passed`).
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tasks.md b/tasks.md
index f6820cb13076e385436a95d4c0edb60bab62a653..770ff01b25baf8262f6012c025852e3bde9193f0
--- a/tasks.md
+++ b/tasks.md
@@ -10,10 +10,10 @@
 
 ## Core Game Engine
 
-- [ ] Implement main game loop with frame updates and delta time handling
-- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
+- [x] Implement main game loop with frame updates and delta time handling
+- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
 - [ ] Implement camera system with first-person perspective and mouse look controls
-- [ ] Create input handler for WASD movement and mouse controls
+- [x] Create input handler for WASD movement and mouse controls
 - [ ] Implement player movement with collision detection
 - [ ] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
@@ -21,19 +21,19 @@
 
 ## Player Systems
 
-- [ ] Create Player class with health, position, and rotation properties
-- [ ] Implement player health system with damage and death handling
-- [ ] Create player money/currency tracking system
-- [ ] Implement player inventory system to track owned weapons
+- [x] Create Player class with health, position, and rotation properties
+- [x] Implement player health system with damage and death handling
+- [x] Create player money/currency tracking system
+- [x] Implement player inventory system to track owned weapons
 - [ ] Create player weapon switching logic
-- [ ] Implement player shooting mechanics with ammo consumption
+- [x] Implement player shooting mechanics with ammo consumption
 - [ ] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
-- [ ] Create base Weapon class with common properties (damage, ammo, fire rate)
-- [ ] Implement Pistol weapon with stats and firing behavior
+- [x] Create base Weapon class with common properties (damage, ammo, fire rate)
+- [x] Implement Pistol weapon with stats and firing behavior
 - [ ] Implement Shotgun weapon with spread pattern and high damage
 - [ ] Implement Assault Rifle weapon with rapid fire mechanics
 - [ ] Implement RPG weapon with special "crash" trigger behavior
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index e547605fc4fe3c4c0aed63e6dd409a633e6b2e88..6c1bc5780d8c0fd4ec59223480d74aaab239f16d
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -10,6 +10,12 @@
 ## Structure
 - Test files should be named `test_<module_name>.py`.
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Refining cleanup command scope**
codex
The broad cleanup command was blocked by policy, so I’m deleting only workspace-local cache directories explicitly.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path tests\\__pycache__) { Remove-Item tests\\__pycache__ -Recurse -Force }; if (Test-Path config\\__pycache__) { Remove-Item config\\__pycache__ -Recurse -Force }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 exited -1 in 0ms:
`"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path tests\\__pycache__) { Remove-Item tests\\__pycache__ -Recurse -Force }; if (Test-Path config\\__pycache__) { Remove-Item config\\__pycache__ -Recurse -Force }"` rejected: blocked by policy
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..714c8d332ec63cc44502119bacd0b72474ebde25
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
-
+# Recent Changes
+
+## 2026-02-08
+
+- Implemented foundational gameplay runtime modules:
+  - `src/core/game_state.py`: validated game state manager for `menu`, `playing`, `paused`, `crashed`.
+  - `src/core/game_clock.py`: delta-time and elapsed-time tracking.
+  - `src/core/input_handler.py`: WASD + mouse-look input normalization.
+  - `src/core/game_loop.py`: frame-stepped loop that dispatches updates only in `playing`.
+- Implemented player systems in `src/player/player.py`:
+  - player creation with position/rotation/health/money
+  - health damage/heal/death behavior
+  - money add/spend behavior with validation
+  - weapon inventory ownership and equip rules
+  - shooting through equipped weapon with ammo/cooldown enforcement
+- Implemented weapon systems:
+  - `src/weapons/weapon.py`: reusable weapon base class with common stats and cooldown-aware firing.
+  - `src/weapons/pistol.py`: starter pistol stats and behavior.
+- Added/updated developer documentation:
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+  - root `developer-guide.md`
+- Added automated tests and fixed import configuration:
+  - `tests/conftest.py`
+  - `tests/test_core_systems.py`
+  - `tests/test_player_and_weapons.py`
+- Validation: `pytest -q` passes (`13 passed`).
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tasks.md b/tasks.md
index f6820cb13076e385436a95d4c0edb60bab62a653..770ff01b25baf8262f6012c025852e3bde9193f0
--- a/tasks.md
+++ b/tasks.md
@@ -10,10 +10,10 @@
 
 ## Core Game Engine
 
-- [ ] Implement main game loop with frame updates and delta time handling
-- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
+- [x] Implement main game loop with frame updates and delta time handling
+- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
 - [ ] Implement camera system with first-person perspective and mouse look controls
-- [ ] Create input handler for WASD movement and mouse controls
+- [x] Create input handler for WASD movement and mouse controls
 - [ ] Implement player movement with collision detection
 - [ ] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
@@ -21,19 +21,19 @@
 
 ## Player Systems
 
-- [ ] Create Player class with health, position, and rotation properties
-- [ ] Implement player health system with damage and death handling
-- [ ] Create player money/currency tracking system
-- [ ] Implement player inventory system to track owned weapons
+- [x] Create Player class with health, position, and rotation properties
+- [x] Implement player health system with damage and death handling
+- [x] Create player money/currency tracking system
+- [x] Implement player inventory system to track owned weapons
 - [ ] Create player weapon switching logic
-- [ ] Implement player shooting mechanics with ammo consumption
+- [x] Implement player shooting mechanics with ammo consumption
 - [ ] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
-- [ ] Create base Weapon class with common properties (damage, ammo, fire rate)
-- [ ] Implement Pistol weapon with stats and firing behavior
+- [x] Create base Weapon class with common properties (damage, ammo, fire rate)
+- [x] Implement Pistol weapon with stats and firing behavior
 - [ ] Implement Shotgun weapon with spread pattern and high damage
 - [ ] Implement Assault Rifle weapon with rapid fire mechanics
 - [ ] Implement RPG weapon with special "crash" trigger behavior
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index e547605fc4fe3c4c0aed63e6dd409a633e6b2e88..6c1bc5780d8c0fd4ec59223480d74aaab239f16d
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -10,6 +10,12 @@
 ## Structure
 - Test files should be named `test_<module_name>.py`.
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Verifying safe removal options**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'git status --short' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 183ms:
 M .agentharness/git-commit-message.txt
 D .codex_last_message.txt
 M developer-guide.md
 M recent-changes.md
 M tasks.md
 M tests/developer-guide.md
?? .agentharness/live-llm/llm_20260208_175957_361b638d.log
?? src/core/
?? src/developer-guide.md
?? src/player/
?? src/weapons/
?? tests/__pycache__/conftest.cpython-311-pytest-9.0.2.pyc
?? tests/__pycache__/test_core_systems.cpython-311-pytest-9.0.2.pyc
?? tests/__pycache__/test_player_and_weapons.cpython-311-pytest-9.0.2.pyc
?? tests/conftest.py
?? tests/test_core_systems.py
?? tests/test_player_and_weapons.py
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..714c8d332ec63cc44502119bacd0b72474ebde25
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
-
+# Recent Changes
+
+## 2026-02-08
+
+- Implemented foundational gameplay runtime modules:
+  - `src/core/game_state.py`: validated game state manager for `menu`, `playing`, `paused`, `crashed`.
+  - `src/core/game_clock.py`: delta-time and elapsed-time tracking.
+  - `src/core/input_handler.py`: WASD + mouse-look input normalization.
+  - `src/core/game_loop.py`: frame-stepped loop that dispatches updates only in `playing`.
+- Implemented player systems in `src/player/player.py`:
+  - player creation with position/rotation/health/money
+  - health damage/heal/death behavior
+  - money add/spend behavior with validation
+  - weapon inventory ownership and equip rules
+  - shooting through equipped weapon with ammo/cooldown enforcement
+- Implemented weapon systems:
+  - `src/weapons/weapon.py`: reusable weapon base class with common stats and cooldown-aware firing.
+  - `src/weapons/pistol.py`: starter pistol stats and behavior.
+- Added/updated developer documentation:
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+  - root `developer-guide.md`
+- Added automated tests and fixed import configuration:
+  - `tests/conftest.py`
+  - `tests/test_core_systems.py`
+  - `tests/test_player_and_weapons.py`
+- Validation: `pytest -q` passes (`13 passed`).
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tasks.md b/tasks.md
index f6820cb13076e385436a95d4c0edb60bab62a653..770ff01b25baf8262f6012c025852e3bde9193f0
--- a/tasks.md
+++ b/tasks.md
@@ -10,10 +10,10 @@
 
 ## Core Game Engine
 
-- [ ] Implement main game loop with frame updates and delta time handling
-- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
+- [x] Implement main game loop with frame updates and delta time handling
+- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
 - [ ] Implement camera system with first-person perspective and mouse look controls
-- [ ] Create input handler for WASD movement and mouse controls
+- [x] Create input handler for WASD movement and mouse controls
 - [ ] Implement player movement with collision detection
 - [ ] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
@@ -21,19 +21,19 @@
 
 ## Player Systems
 
-- [ ] Create Player class with health, position, and rotation properties
-- [ ] Implement player health system with damage and death handling
-- [ ] Create player money/currency tracking system
-- [ ] Implement player inventory system to track owned weapons
+- [x] Create Player class with health, position, and rotation properties
+- [x] Implement player health system with damage and death handling
+- [x] Create player money/currency tracking system
+- [x] Implement player inventory system to track owned weapons
 - [ ] Create player weapon switching logic
-- [ ] Implement player shooting mechanics with ammo consumption
+- [x] Implement player shooting mechanics with ammo consumption
 - [ ] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
-- [ ] Create base Weapon class with common properties (damage, ammo, fire rate)
-- [ ] Implement Pistol weapon with stats and firing behavior
+- [x] Create base Weapon class with common properties (damage, ammo, fire rate)
+- [x] Implement Pistol weapon with stats and firing behavior
 - [ ] Implement Shotgun weapon with spread pattern and high damage
 - [ ] Implement Assault Rifle weapon with rapid fire mechanics
 - [ ] Implement RPG weapon with special "crash" trigger behavior
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index e547605fc4fe3c4c0aed63e6dd409a633e6b2e88..6c1bc5780d8c0fd4ec59223480d74aaab239f16d
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -10,6 +10,12 @@
 ## Structure
 - Test files should be named `test_<module_name>.py`.
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+


thinking
**Finalizing completed tasks summary**
codex
Implemented 10 incomplete tasks and updated both tracking files as requested.

Completed and marked in `tasks.md`:
1. `Implement main game loop with frame updates and delta time handling`
2. `Create game state manager to handle different states (menu, playing, paused, crashed)`
3. `Create input handler for WASD movement and mouse controls`
4. `Create Player class with health, position, and rotation properties`
5. `Implement player health system with damage and death handling`
6. `Create player money/currency tracking system`
7. `Implement player inventory system to track owned weapons`
8. `Implement player shooting mechanics with ammo consumption`
9. `Create base Weapon class with common properties (damage, ammo, fire rate)`
10. `Implement Pistol weapon with stats and firing behavior`

Key code added:
- `src/core/game_loop.py`
- `src/core/game_state.py`
- `src/core/input_handler.py`
- `src/core/game_clock.py` (supporting implementation)
- `src/player/player.py`
- `src/weapons/weapon.py`
- `src/weapons/pistol.py`
- Package init files under `src/core`, `src/player`, `src/weapons`

Developer guides added/updated:
- `src/developer-guide.md`
- `src/core/developer-guide.md`
- `src/player/developer-guide.md`
- `src/weapons/developer-guide.md`
- `tests/developer-guide.md`
- `developer-guide.md` (root)

Tracking files updated:
- `tasks.md` (10 tasks marked done)
- `recent-changes.md` (detailed log of implemented work)

Validation:
- Ran `pytest -q` successfully: `13 passed`.

Note:
- I attempted to remove generated `__pycache__` artifacts, but deletion commands were blocked by environment policy.
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 3af5861d898086052bc94b6a3fc1dff9324314c9..0f16dc933f598391f7c8702b74f017b0f1f22da3
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -1,10 +1,20 @@
 # Developer Guide
 
 ## Project Architecture
-This project uses **Python + Ursina** for the fastest path to a lightweight 3D FPS prototype with minimal setup overhead.
+This project uses **Python + Ursina** for a lightweight FPS prototype.
+
+The current codebase implements engine-agnostic gameplay foundations in pure Python:
+- Core runtime loop and timing
+- State machine for high-level game flow
+- Input normalization for WASD + mouse look
+- Player model with health, money, inventory, and shooting
+- Weapon base behavior and starter pistol
 
 ## Directory Map
-- `src/`: game systems and runtime code.
+- `src/`: runtime game systems.
+  - `src/core/`: game loop, game clock, state manager, input handler.
+  - `src/player/`: player model and starter loadout behavior.
+  - `src/weapons/`: base weapon logic and concrete weapons.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -19,6 +29,14 @@
 - `config/config.py` exposes `GAME_CONFIG` and `ECONOMY_CONFIG` dataclass instances.
 - Game systems should import from `config.config` rather than duplicating constant values.
 
+## Implemented Gameplay Foundations
+- `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
+- `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
+- `Weapon.fire(now)` enforces cooldown + ammo consumption.
+- `Pistol` is the starter weapon with tuned prototype stats.
+
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
-- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
+- Add per-folder `developer-guide.md` files when new code folders gain implementation files.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..714c8d332ec63cc44502119bacd0b72474ebde25
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
-
+# Recent Changes
+
+## 2026-02-08
+
+- Implemented foundational gameplay runtime modules:
+  - `src/core/game_state.py`: validated game state manager for `menu`, `playing`, `paused`, `crashed`.
+  - `src/core/game_clock.py`: delta-time and elapsed-time tracking.
+  - `src/core/input_handler.py`: WASD + mouse-look input normalization.
+  - `src/core/game_loop.py`: frame-stepped loop that dispatches updates only in `playing`.
+- Implemented player systems in `src/player/player.py`:
+  - player creation with position/rotation/health/money
+  - health damage/heal/death behavior
+  - money add/spend behavior with validation
+  - weapon inventory ownership and equip rules
+  - shooting through equipped weapon with ammo/cooldown enforcement
+- Implemented weapon systems:
+  - `src/weapons/weapon.py`: reusable weapon base class with common stats and cooldown-aware firing.
+  - `src/weapons/pistol.py`: starter pistol stats and behavior.
+- Added/updated developer documentation:
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+  - root `developer-guide.md`
+- Added automated tests and fixed import configuration:
+  - `tests/conftest.py`
+  - `tests/test_core_systems.py`
+  - `tests/test_player_and_weapons.py`
+- Validation: `pytest -q` passes (`13 passed`).
diff --git a/src/core/__init__.py b/src/core/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e093d60c96feba5ee6590c987b33d09c43dbdc2a
--- /dev/null
+++ b/src/core/__init__.py
@@ -0,0 +1,2 @@
+"""Core runtime systems for FPS Bot Arena."""
+
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f6e869a5a82143b36629f4ae35d5b2365bb2f410
--- /dev/null
+++ b/src/core/developer-guide.md
@@ -0,0 +1,16 @@
+# Core Developer Guide
+
+## Purpose
+`src/core/` provides engine-level systems that are independent from rendering backends.
+
+## Files
+- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
+- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
+- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+
+## Behavior Notes
+- `GameStateManager` blocks invalid transitions with `ValueError`.
+- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
new file mode 100644
index 0000000000000000000000000000000000000000..333d141973b942bfeb63aaac21425807f83ce656
--- /dev/null
+++ b/src/core/game_clock.py
@@ -0,0 +1,27 @@
+"""Lightweight game clock and delta-time tracking."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class GameClock:
+    """Tracks elapsed and per-frame timing."""
+
+    elapsed_time: float = 0.0
+    frame_count: int = 0
+    _last_timestamp: float | None = None
+
+    def tick(self, now: float) -> float:
+        """Advance the clock and return frame delta-time in seconds."""
+        if self._last_timestamp is None:
+            self._last_timestamp = now
+            return 0.0
+
+        delta_time = max(0.0, now - self._last_timestamp)
+        self._last_timestamp = now
+        self.elapsed_time += delta_time
+        self.frame_count += 1
+        return delta_time
+
diff --git a/src/core/game_loop.py b/src/core/game_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..d490e44f55092aa0f6c0e973fab448275169aaff
--- /dev/null
+++ b/src/core/game_loop.py
@@ -0,0 +1,36 @@
+"""Main game loop orchestration with delta-time updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Callable
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+
+
+FrameCallback = Callable[[float], None]
+
+
+@dataclass
+class GameLoop:
+    """Owns frame stepping and update dispatch for active gameplay."""
+
+    state_manager: GameStateManager
+    clock: GameClock = field(default_factory=GameClock)
+    _callbacks: list[FrameCallback] = field(default_factory=list)
+
+    def register_update_callback(self, callback: FrameCallback) -> None:
+        """Add a callback invoked each PLAYING frame with delta-time."""
+        self._callbacks.append(callback)
+
+    def step(self, now: float) -> float:
+        """Run one frame step and return frame delta-time."""
+        delta_time = self.clock.tick(now)
+        if self.state_manager.current_state != GameState.PLAYING:
+            return delta_time
+
+        for callback in self._callbacks:
+            callback(delta_time)
+        return delta_time
+
diff --git a/src/core/game_state.py b/src/core/game_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..cded68b1fd2d3890ce2264effb30879ca353c41b
--- /dev/null
+++ b/src/core/game_state.py
@@ -0,0 +1,44 @@
+"""Game state management for high-level flow transitions."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+
+
+class GameState(str, Enum):
+    """Allowed top-level game states."""
+
+    MENU = "menu"
+    PLAYING = "playing"
+    PAUSED = "paused"
+    CRASHED = "crashed"
+
+
+@dataclass
+class GameStateManager:
+    """Controls current state and validates state transitions."""
+
+    current_state: GameState = GameState.MENU
+    transition_history: list[GameState] = field(default_factory=lambda: [GameState.MENU])
+
+    _ALLOWED_TRANSITIONS = {
+        GameState.MENU: {GameState.PLAYING},
+        GameState.PLAYING: {GameState.PAUSED, GameState.CRASHED, GameState.MENU},
+        GameState.PAUSED: {GameState.PLAYING, GameState.MENU},
+        GameState.CRASHED: {GameState.MENU},
+    }
+
+    def can_transition_to(self, next_state: GameState) -> bool:
+        """Return True when a transition is allowed from the current state."""
+        return next_state in self._ALLOWED_TRANSITIONS[self.current_state]
+
+    def transition_to(self, next_state: GameState) -> None:
+        """Move to a new valid state or raise ValueError."""
+        if not self.can_transition_to(next_state):
+            raise ValueError(
+                f"Invalid transition: {self.current_state.value} -> {next_state.value}"
+            )
+        self.current_state = next_state
+        self.transition_history.append(next_state)
+
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
new file mode 100644
index 0000000000000000000000000000000000000000..31a251d67b16c01cbf966b82bc13bbe865032bc0
--- /dev/null
+++ b/src/core/input_handler.py
@@ -0,0 +1,56 @@
+"""Input translation for keyboard movement and mouse look."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class InputSnapshot:
+    """Raw frame input values from platform layer."""
+
+    pressed_keys: set[str]
+    mouse_delta_x: float = 0.0
+    mouse_delta_y: float = 0.0
+
+
+@dataclass(frozen=True)
+class InputFrame:
+    """Normalized input values consumed by gameplay systems."""
+
+    move_x: float
+    move_z: float
+    look_yaw: float
+    look_pitch: float
+
+
+class InputHandler:
+    """Normalizes raw control inputs into movement/look values."""
+
+    def __init__(self, mouse_sensitivity: float) -> None:
+        self.mouse_sensitivity = mouse_sensitivity
+
+    def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
+        """Compute movement axis values and scaled look deltas."""
+        move_x = self._axis(snapshot.pressed_keys, positive="d", negative="a")
+        move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
+        look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
+        look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+
+        return InputFrame(
+            move_x=move_x,
+            move_z=move_z,
+            look_yaw=look_yaw,
+            look_pitch=look_pitch,
+        )
+
+    @staticmethod
+    def _axis(keys: set[str], positive: str, negative: str) -> float:
+        if positive in keys and negative in keys:
+            return 0.0
+        if positive in keys:
+            return 1.0
+        if negative in keys:
+            return -1.0
+        return 0.0
+
diff --git a/src/developer-guide.md b/src/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..155dc7900c09d713c7cee789cb9e90e81e42d0e2
--- /dev/null
+++ b/src/developer-guide.md
@@ -0,0 +1,16 @@
+# Src Developer Guide
+
+## Purpose
+`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+
+## Folder Overview
+- `core/`: frame stepping, game clock, state machine, and input normalization.
+- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+
+## Integration Flow
+1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
+2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
+4. Player actions call into weapon models for ammo/cooldown-validated firing.
+
diff --git a/src/player/__init__.py b/src/player/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52297c3cbf67d9df6b43a8e6124d52f754770f5e
--- /dev/null
+++ b/src/player/__init__.py
@@ -0,0 +1,2 @@
+"""Player state and gameplay behavior."""
+
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..28ff6dc0a43c783275e8bef0d2dbfc46d15879b8
--- /dev/null
+++ b/src/player/developer-guide.md
@@ -0,0 +1,23 @@
+# Player Developer Guide
+
+## Purpose
+`src/player/` owns all player-centric gameplay state and actions.
+
+## Files
+- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.
+
+## Key Behaviors
+- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
+- Health logic:
+  - `apply_damage` clamps health at `0`.
+  - `heal` clamps health at `max_health`.
+  - `is_alive` becomes `False` at `0` health.
+- Economy logic:
+  - `add_money` and `spend_money` reject negative inputs.
+  - `spend_money` returns `False` when balance is insufficient.
+- Inventory logic:
+  - Weapons are stored by name.
+  - `equip_weapon` requires ownership.
+- Combat logic:
+  - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
+
diff --git a/src/player/player.py b/src/player/player.py
new file mode 100644
index 0000000000000000000000000000000000000000..087f66998f6b66442b9e889c0b0b654d259f9eaa
--- /dev/null
+++ b/src/player/player.py
@@ -0,0 +1,89 @@
+"""Player model with health, currency, inventory, and shooting."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+@dataclass
+class Player:
+    """Encapsulates runtime player state and core gameplay actions."""
+
+    max_health: int
+    health: int
+    money: int
+    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
+    rotation: tuple[float, float] = (0.0, 0.0)
+    inventory: dict[str, Weapon] = field(default_factory=dict)
+    equipped_weapon_name: str = "Pistol"
+
+    @classmethod
+    def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
+        """Create a player initialized with the starter pistol."""
+        player = cls(
+            max_health=start_health,
+            health=start_health,
+            money=start_money,
+        )
+        pistol = Pistol()
+        player.inventory[pistol.name] = pistol
+        return player
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    @property
+    def equipped_weapon(self) -> Weapon:
+        return self.inventory[self.equipped_weapon_name]
+
+    def set_rotation(self, yaw: float, pitch: float) -> None:
+        self.rotation = (yaw, pitch)
+
+    def set_position(self, x: float, y: float, z: float) -> None:
+        self.position = (x, y, z)
+
+    def apply_damage(self, damage: int) -> None:
+        """Reduce health while clamping at zero."""
+        if damage < 0:
+            raise ValueError("Damage must be non-negative.")
+        self.health = max(0, self.health - damage)
+
+    def heal(self, amount: int) -> None:
+        """Restore health without exceeding max health."""
+        if amount < 0:
+            raise ValueError("Heal amount must be non-negative.")
+        self.health = min(self.max_health, self.health + amount)
+
+    def add_money(self, amount: int) -> None:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        self.money += amount
+
+    def spend_money(self, amount: int) -> bool:
+        if amount < 0:
+            raise ValueError("Amount must be non-negative.")
+        if self.money < amount:
+            return False
+        self.money -= amount
+        return True
+
+    def add_weapon(self, weapon: Weapon, auto_equip: bool = False) -> None:
+        self.inventory[weapon.name] = weapon
+        if auto_equip:
+            self.equipped_weapon_name = weapon.name
+
+    def equip_weapon(self, weapon_name: str) -> None:
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        self.equipped_weapon_name = weapon_name
+
+    def shoot(self, now: float) -> bool:
+        """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
+        if not self.is_alive:
+            return False
+        return self.equipped_weapon.fire(now)
+
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d07cd437d3c7239fbd56e48167982dbcf46a28b6
--- /dev/null
+++ b/src/weapons/__init__.py
@@ -0,0 +1,2 @@
+"""Weapon definitions and shared weapon behavior."""
+
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a
--- /dev/null
+++ b/src/weapons/developer-guide.md
@@ -0,0 +1,20 @@
+# Weapons Developer Guide
+
+## Purpose
+`src/weapons/` defines weapon behavior shared across loadout items.
+
+## Files
+- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
+- `pistol.py`: starter `Pistol` implementation with tuned default stats.
+
+## Key Behaviors
+- `Weapon.fire(now)` returns `True` only when:
+  - ammo remains in the magazine, and
+  - cooldown time since last shot has elapsed.
+- Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Pistol` defaults:
+  - damage `20`
+  - fire rate `3` shots/sec
+  - magazine size `12`
+  - reserve ammo `48`
+
diff --git a/src/weapons/pistol.py b/src/weapons/pistol.py
new file mode 100644
index 0000000000000000000000000000000000000000..5b8f1c8f2771f1d1795bfbead8e100ee0c41e957
--- /dev/null
+++ b/src/weapons/pistol.py
@@ -0,0 +1,19 @@
+"""Pistol weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class Pistol(Weapon):
+    """Default starter weapon with reliable semi-auto fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Pistol",
+            damage=20.0,
+            fire_rate=3.0,
+            magazine_size=12,
+            reserve_ammo=48,
+        )
+
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
new file mode 100644
index 0000000000000000000000000000000000000000..f486920a5ad6fde64026a29e997c13af51a6c57a
--- /dev/null
+++ b/src/weapons/weapon.py
@@ -0,0 +1,41 @@
+"""Base weapon model used by all weapon types."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class Weapon:
+    """Shared weapon attributes and firing cooldown logic."""
+
+    name: str
+    damage: float
+    fire_rate: float
+    magazine_size: int
+    reserve_ammo: int
+    ammo_in_magazine: int | None = None
+    _last_fired_at: float = -1_000_000.0
+
+    def __post_init__(self) -> None:
+        if self.ammo_in_magazine is None:
+            self.ammo_in_magazine = self.magazine_size
+
+    @property
+    def cooldown_seconds(self) -> float:
+        return 1.0 / self.fire_rate
+
+    def can_fire(self, now: float) -> bool:
+        """Return True when weapon has ammo and cooldown is ready."""
+        has_ammo = self.ammo_in_magazine > 0
+        off_cooldown = (now - self._last_fired_at) >= self.cooldown_seconds
+        return has_ammo and off_cooldown
+
+    def fire(self, now: float) -> bool:
+        """Spend one ammo and start cooldown. Returns True on successful shot."""
+        if not self.can_fire(now):
+            return False
+        self.ammo_in_magazine -= 1
+        self._last_fired_at = now
+        return True
+
diff --git a/tasks.md b/tasks.md
index f6820cb13076e385436a95d4c0edb60bab62a653..770ff01b25baf8262f6012c025852e3bde9193f0
--- a/tasks.md
+++ b/tasks.md
@@ -10,10 +10,10 @@
 
 ## Core Game Engine
 
-- [ ] Implement main game loop with frame updates and delta time handling
-- [ ] Create game state manager to handle different states (menu, playing, paused, crashed)
+- [x] Implement main game loop with frame updates and delta time handling
+- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
 - [ ] Implement camera system with first-person perspective and mouse look controls
-- [ ] Create input handler for WASD movement and mouse controls
+- [x] Create input handler for WASD movement and mouse controls
 - [ ] Implement player movement with collision detection
 - [ ] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
@@ -21,19 +21,19 @@
 
 ## Player Systems
 
-- [ ] Create Player class with health, position, and rotation properties
-- [ ] Implement player health system with damage and death handling
-- [ ] Create player money/currency tracking system
-- [ ] Implement player inventory system to track owned weapons
+- [x] Create Player class with health, position, and rotation properties
+- [x] Implement player health system with damage and death handling
+- [x] Create player money/currency tracking system
+- [x] Implement player inventory system to track owned weapons
 - [ ] Create player weapon switching logic
-- [ ] Implement player shooting mechanics with ammo consumption
+- [x] Implement player shooting mechanics with ammo consumption
 - [ ] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
-- [ ] Create base Weapon class with common properties (damage, ammo, fire rate)
-- [ ] Implement Pistol weapon with stats and firing behavior
+- [x] Create base Weapon class with common properties (damage, ammo, fire rate)
+- [x] Implement Pistol weapon with stats and firing behavior
 - [ ] Implement Shotgun weapon with spread pattern and high damage
 - [ ] Implement Assault Rifle weapon with rapid fire mechanics
 - [ ] Implement RPG weapon with special "crash" trigger behavior
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3d183e054b8ca4142070de22e39d93b38970ae9
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,12 @@
+"""Pytest configuration for import resolution."""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+ROOT = Path(__file__).resolve().parents[1]
+if str(ROOT) not in sys.path:
+    sys.path.insert(0, str(ROOT))
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index e547605fc4fe3c4c0aed63e6dd409a633e6b2e88..6c1bc5780d8c0fd4ec59223480d74aaab239f16d
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -10,6 +10,12 @@
 ## Structure
 - Test files should be named `test_<module_name>.py`.
 - Tests should mirror the structure of the `src/` and `config/` directories where applicable.
+- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.
+
+## Current Test Modules
+- `test_config.py`: validates immutable config defaults.
+- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2d04f6ab9c70c305ffe8153ca5ba04763e394ab
--- /dev/null
+++ b/tests/test_core_systems.py
@@ -0,0 +1,72 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+
+
+def test_game_clock_tracks_delta_and_elapsed_time():
+    clock = GameClock()
+
+    assert clock.tick(10.0) == 0.0
+    assert clock.elapsed_time == 0.0
+    assert clock.frame_count == 0
+
+    assert clock.tick(10.25) == 0.25
+    assert clock.tick(10.75) == 0.5
+    assert clock.elapsed_time == 0.75
+    assert clock.frame_count == 2
+
+
+def test_state_manager_validates_transitions():
+    manager = GameStateManager()
+
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.PAUSED)
+    manager.transition_to(GameState.PLAYING)
+    manager.transition_to(GameState.CRASHED)
+    manager.transition_to(GameState.MENU)
+
+    assert manager.transition_history == [
+        GameState.MENU,
+        GameState.PLAYING,
+        GameState.PAUSED,
+        GameState.PLAYING,
+        GameState.CRASHED,
+        GameState.MENU,
+    ]
+
+    with pytest.raises(ValueError):
+        manager.transition_to(GameState.PAUSED)
+
+
+def test_input_handler_maps_wasd_and_mouse_look():
+    handler = InputHandler(mouse_sensitivity=2.0)
+    snapshot = InputSnapshot(
+        pressed_keys={"w", "d"},
+        mouse_delta_x=3.0,
+        mouse_delta_y=-4.0,
+    )
+
+    frame = handler.build_frame(snapshot)
+    assert frame.move_x == 1.0
+    assert frame.move_z == 1.0
+    assert frame.look_yaw == 6.0
+    assert frame.look_pitch == 8.0
+
+
+def test_game_loop_updates_only_while_playing():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    deltas = []
+    loop.register_update_callback(deltas.append)
+
+    loop.step(1.0)
+    loop.step(1.1)
+    assert deltas == []
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(1.4)
+    loop.step(1.8)
+    assert deltas == pytest.approx([0.3, 0.4])
diff --git a/tests/test_player_and_weapons.py b/tests/test_player_and_weapons.py
new file mode 100644
index 0000000000000000000000000000000000000000..ba9f1f93672fff9427099d7b6d2719eebbcec0ca
--- /dev/null
+++ b/tests/test_player_and_weapons.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.player.player import Player
+from src.weapons.pistol import Pistol
+from src.weapons.weapon import Weapon
+
+
+def test_player_starter_loadout_and_properties():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    assert player.health == 100
+    assert player.money == 0
+    assert player.position == (0.0, 1.8, 0.0)
+    assert player.rotation == (0.0, 0.0)
+    assert player.equipped_weapon_name == "Pistol"
+    assert isinstance(player.equipped_weapon, Pistol)
+
+
+def test_player_health_system_damage_heal_and_death():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.apply_damage(30)
+    assert player.health == 70
+    assert player.is_alive
+
+    player.apply_damage(1000)
+    assert player.health == 0
+    assert not player.is_alive
+
+    player.heal(10)
+    assert player.health == 10
+
+    with pytest.raises(ValueError):
+        player.apply_damage(-1)
+    with pytest.raises(ValueError):
+        player.heal(-1)
+
+
+def test_player_money_tracking_and_spend_validation():
+    player = Player.with_starter_loadout(start_health=100, start_money=50)
+
+    player.add_money(25)
+    assert player.money == 75
+
+    assert player.spend_money(70) is True
+    assert player.money == 5
+    assert player.spend_money(6) is False
+    assert player.money == 5
+
+    with pytest.raises(ValueError):
+        player.add_money(-1)
+    with pytest.raises(ValueError):
+        player.spend_money(-1)
+
+
+def test_player_inventory_tracking_and_equipping():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    custom_weapon = Weapon(
+        name="TestGun",
+        damage=5,
+        fire_rate=5,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+
+    player.add_weapon(custom_weapon)
+    player.equip_weapon("TestGun")
+    assert player.equipped_weapon_name == "TestGun"
+
+    with pytest.raises(ValueError):
+        player.equip_weapon("MissingWeapon")
+
+
+def test_base_weapon_fire_rate_and_ammo_consumption():
+    weapon = Weapon(
+        name="BaseWeapon",
+        damage=10,
+        fire_rate=2,
+        magazine_size=2,
+        reserve_ammo=0,
+    )
+    assert weapon.ammo_in_magazine == 2
+
+    assert weapon.fire(1.0) is True
+    assert weapon.ammo_in_magazine == 1
+    assert weapon.fire(1.2) is False
+    assert weapon.fire(1.5) is True
+    assert weapon.ammo_in_magazine == 0
+    assert weapon.fire(2.5) is False
+
+
+def test_pistol_defaults_and_player_shooting_behavior():
+    pistol = Pistol()
+    assert pistol.name == "Pistol"
+    assert pistol.damage == 20.0
+    assert pistol.fire_rate == 3.0
+    assert pistol.magazine_size == 12
+    assert pistol.reserve_ammo == 48
+
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    assert player.shoot(1.0) is True
+    assert player.equipped_weapon.ammo_in_magazine == 11
+    assert player.shoot(1.1) is False
+
+    player.apply_damage(100)
+    assert player.shoot(2.0) is False
+

tokens used
64,796
Implemented 10 incomplete tasks and updated both tracking files as requested.

Completed and marked in `tasks.md`:
1. `Implement main game loop with frame updates and delta time handling`
2. `Create game state manager to handle different states (menu, playing, paused, crashed)`
3. `Create input handler for WASD movement and mouse controls`
4. `Create Player class with health, position, and rotation properties`
5. `Implement player health system with damage and death handling`
6. `Create player money/currency tracking system`
7. `Implement player inventory system to track owned weapons`
8. `Implement player shooting mechanics with ammo consumption`
9. `Create base Weapon class with common properties (damage, ammo, fire rate)`
10. `Implement Pistol weapon with stats and firing behavior`

Key code added:
- `src/core/game_loop.py`
- `src/core/game_state.py`
- `src/core/input_handler.py`
- `src/core/game_clock.py` (supporting implementation)
- `src/player/player.py`
- `src/weapons/weapon.py`
- `src/weapons/pistol.py`
- Package init files under `src/core`, `src/player`, `src/weapons`

Developer guides added/updated:
- `src/developer-guide.md`
- `src/core/developer-guide.md`
- `src/player/developer-guide.md`
- `src/weapons/developer-guide.md`
- `tests/developer-guide.md`
- `developer-guide.md` (root)

Tracking files updated:
- `tasks.md` (10 tasks marked done)
- `recent-changes.md` (detailed log of implemented work)

Validation:
- Ran `pytest -q` successfully: `13 passed`.

Note:
- I attempted to remove generated `__pycache__` artifacts, but deletion commands were blocked by environment policy.
Implemented 10 incomplete tasks and updated both tracking files as requested.

Completed and marked in `tasks.md`:
1. `Implement main game loop with frame updates and delta time handling`
2. `Create game state manager to handle different states (menu, playing, paused, crashed)`
3. `Create input handler for WASD movement and mouse controls`
4. `Create Player class with health, position, and rotation properties`
5. `Implement player health system with damage and death handling`
6. `Create player money/currency tracking system`
7. `Implement player inventory system to track owned weapons`
8. `Implement player shooting mechanics with ammo consumption`
9. `Create base Weapon class with common properties (damage, ammo, fire rate)`
10. `Implement Pistol weapon with stats and firing behavior`

Key code added:
- `src/core/game_loop.py`
- `src/core/game_state.py`
- `src/core/input_handler.py`
- `src/core/game_clock.py` (supporting implementation)
- `src/player/player.py`
- `src/weapons/weapon.py`
- `src/weapons/pistol.py`
- Package init files under `src/core`, `src/player`, `src/weapons`

Developer guides added/updated:
- `src/developer-guide.md`
- `src/core/developer-guide.md`
- `src/player/developer-guide.md`
- `src/weapons/developer-guide.md`
- `tests/developer-guide.md`
- `developer-guide.md` (root)

Tracking files updated:
- `tasks.md` (10 tasks marked done)
- `recent-changes.md` (detailed log of implemented work)

Validation:
- Ran `pytest -q` successfully: `13 passed`.

Note:
- I attempted to remove generated `__pycache__` artifacts, but deletion commands were blocked by environment policy.
Process exited with code 0. Output length: 912560 chars.
End: 2026-02-08T18:04:37
__AGENTHARNESS_LIVE_DONE__
