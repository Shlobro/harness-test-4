AgentHarness LLM Live Output
Start: 2026-02-08T18:10:40
CWD: C:/Users/shlob/Pycharm Projects/harness-test/harness-test-4
Command: codex exec --skip-git-repo-check --full-auto --output-last-message "C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.codex_last_message.txt" --model gpt-5.3-codex -

Provider: Codex, Model: gpt-5.3-codex | Timeout: 600s
Prompt transport: stdin (678 chars)
LLM prompt begin (stdin)

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md
LLM prompt end (stdin)
Process PID: 17836
OpenAI Codex v0.98.0 (research preview)
--------
workdir: C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019c3e04-fd96-7c81-abff-099a93bc420d
--------
user

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md

deprecated: `enable_experimental_windows_sandbox` is deprecated. Use `[features].experimental_windows_sandbox` instead.
  Enable it with `--enable experimental_windows_sandbox` or `[features].experimental_windows_sandbox` in config.toml. See https://github.com/openai/codex/blob/main/docs/config.md#feature-flags for details.
mcp startup: no servers

thinking
**Preparing product description read**
codex
I’m going to follow your workflow exactly: first I’ll read `product-description.md` and `recent-changes.md`, then inspect `tasks.md`, pick up to 10 unchecked tasks, and implement them end-to-end before updating both tracking files. I’ll report progress as I validate each task.

thinking
**Planning parallel file inspection**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path tasks.md) { Get-Content tasks.md } else { Write-Output 'MISSING: tasks.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path product-description.md) { Get-Content product-description.md } else { Write-Output 'MISSING: product-description.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path recent-changes.md) { Get-Content recent-changes.md } else { Write-Output 'MISSING: recent-changes.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Force' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 245ms:
# Recent Changes

 succeeded in 253ms:
# Product Description: FPS Bot Arena with "The Glitch"

## Overview
A First-Person Shooter (FPS) game where the player fights against waves of tactical AI bots in a multi-room indoor facility. The core loop involves combat, earning money from kills, and upgrading weapons. The game features a meta-twist ending where the final weapon, an RPG, triggers a simulated game crash (Fake BSOD/Error) upon use.

## Gameplay Mechanics
*   **Perspective:** First-Person.
*   **Controls:** Standard FPS controls (WASD + Mouse).
*   **Interaction:** Pressing 'B' opens a real-time inventory/shop wheel to buy and switch weapons.
*   **Win/Loss:**
    *   **Loss:** Player health reaches zero.
    *   **"Win":** Acquiring and firing the final RPG, triggering the "crash" ending.

## Economy & Progression
*   **Income:** Bots drop money as physical items upon death, which the player must collect.
*   **Weapon Progression:**
    1.  **Pistol:** Starting weapon.
    2.  **Shotgun:** High close-range damage.
    3.  **Assault Rifle:** Rapid fire, medium range.
    4.  **RPG (Final Weapon):** Expensive endgame item. Firing it causes a fake "Blue Screen of Death" or critical error message, effectively ending the session.
 succeeded in 258ms:
# FPS Bot Arena Implementation Tasks

## Project Setup & Architecture

- [x] Choose and document the technology stack (Python + Ursina or Web + Three.js)
- [x] Set up project structure with main folders (src, assets, config, tests)
- [x] Create root developer-guide.md documenting overall project architecture
- [x] Initialize package.json or requirements.txt with core dependencies
- [x] Set up basic project configuration files (config.py or config.js)

## Core Game Engine

- [x] Implement main game loop with frame updates and delta time handling
- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
- [ ] Implement camera system with first-person perspective and mouse look controls
- [x] Create input handler for WASD movement and mouse controls
- [ ] Implement player movement with collision detection
- [ ] Create physics system for projectile movement and collision
- [ ] Implement raycasting system for shooting mechanics
- [ ] Create game clock and time management system
 succeeded in 245ms:


    Directory: C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4


Mode                 LastWriteTime         Length Name                                                                                                                                                        
----                 -------------         ------ ----                                                                                                                                                        
d-----          2/8/2026   5:53 PM                .agentharness                                                                                                                                               
d--h--          2/8/2026   6:10 PM                .git                                                                                                                                                        
d-----          2/8/2026   5:56 PM                .pytest_cache                                                                                                                                               
d-----          2/8/2026   5:54 PM                assets                                                                                                                                                      
d-----          2/8/2026   5:56 PM                config                                                                                                                                                      
d-----          2/8/2026   6:10 PM                review                                                                                                                                                      
d-----          2/8/2026   6:01 PM                src                                                                                                                                                         
d-----          2/8/2026   6:02 PM                tests                                                                                                                                                       
-a----          2/8/2026   5:39 PM           1086 AGENTS.md                                                                                                                                                   
-a----          2/8/2026   5:39 PM           1086 CLAUDE.md                                                                                                                                                   
-a----          2/8/2026   6:03 PM           2091 developer-guide.md                                                                                                                                          
-a----          2/8/2026   5:39 PM           1086 GEMINI.md                                                                                                                                                   
-a----          2/8/2026   5:51 PM           2003 product-description.md                                                                                                                                      

thinking
**Assessing repo structure**
codex
I’ve loaded the task list and will now scan the current `src` structure and folder-level `developer-guide.md` files so I can select tasks that can be completed cleanly and update the correct guides (including ancestors) after behavior changes.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -Filter developer-guide.md | ForEach-Object { $_.FullName }' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'rg --files' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 227ms:
tests\__pycache__\test_player_and_weapons.cpython-311-pytest-9.0.2.pyc
tests\__pycache__\test_core_systems.cpython-311-pytest-9.0.2.pyc
tests\__pycache__\test_config.cpython-311-pytest-9.0.2.pyc
tests\__pycache__\conftest.cpython-311-pytest-9.0.2.pyc
tests\test_player_and_weapons.py
tests\test_core_systems.py
tests\test_config.py
tests\developer-guide.md
tests\conftest.py
tasks.md
recent-changes.md
questions.json
product-description.md
GEMINI.md
developer-guide.md
src\weapons\__pycache__\__init__.cpython-311.pyc
src\weapons\__pycache__\weapon.cpython-311.pyc
src\weapons\__pycache__\pistol.cpython-311.pyc
src\weapons\__init__.py
src\weapons\weapon.py
 succeeded in 231ms:
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\config\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\review\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\player\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\weapons\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\developer-guide.md

thinking
**Listing feasible feature tasks**
codex
I found existing code in `src/core`, `src/player`, and `src/weapons`, plus developer guides in those folders. Next I’m reading those guides and source files to choose 10 tasks that fit the current architecture and can be fully tested in this pass.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/player/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 231ms:
# Weapons Developer Guide

## Purpose
`src/weapons/` defines weapon behavior shared across loadout items.

## Files
- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
- `pistol.py`: starter `Pistol` implementation with tuned default stats.

## Key Behaviors
- `Weapon.fire(now)` returns `True` only when:
  - ammo remains in the magazine, and
  - cooldown time since last shot has elapsed.
- Successful fire events decrement `ammo_in_magazine` by exactly one.
- `Pistol` defaults:
  - damage `20`
  - fire rate `3` shots/sec
  - magazine size `12`
  - reserve ammo `48`

 succeeded in 231ms:
# Player Developer Guide

## Purpose
`src/player/` owns all player-centric gameplay state and actions.

## Files
- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.

## Key Behaviors
- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
- Health logic:
  - `apply_damage` clamps health at `0`.
  - `heal` clamps health at `max_health`.
  - `is_alive` becomes `False` at `0` health.
- Economy logic:
  - `add_money` and `spend_money` reject negative inputs.
  - `spend_money` returns `False` when balance is insufficient.
- Inventory logic:
  - Weapons are stored by name.
  - `equip_weapon` requires ownership.
 succeeded in 231ms:
# Src Developer Guide

## Purpose
`src/` contains the game runtime modules for loop/state management, player logic, and weapons.

## Folder Overview
- `core/`: frame stepping, game clock, state machine, and input normalization.
- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
- `weapons/`: reusable weapon abstractions and concrete weapon implementations.

## Integration Flow
1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
4. Player actions call into weapon models for ammo/cooldown-validated firing.

 succeeded in 231ms:
# Core Developer Guide

## Purpose
`src/core/` provides engine-level systems that are independent from rendering backends.

## Files
- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.

## Behavior Notes
- `GameStateManager` blocks invalid transitions with `ValueError`.
- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).

 succeeded in 239ms:
# Developer Guide

## Project Architecture
This project uses **Python + Ursina** for a lightweight FPS prototype.

The current codebase implements engine-agnostic gameplay foundations in pure Python:
- Core runtime loop and timing
- State machine for high-level game flow
- Input normalization for WASD + mouse look
- Player model with health, money, inventory, and shooting
- Weapon base behavior and starter pistol

## Directory Map
- `src/`: runtime game systems.
  - `src/core/`: game loop, game clock, state manager, input handler.
  - `src/player/`: player model and starter loadout behavior.
  - `src/weapons/`: base weapon logic and concrete weapons.
- `assets/`: static assets (models, audio, textures). Currently placeholder-only.
- `config/`: centralized runtime configuration modules.
- `tests/`: automated test suite.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/game_state.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/pistol.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tests/test_config.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/input_handler.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/player/player.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/game_loop.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/game_clock.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tests/test_player_and_weapons.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tests/test_core_systems.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/weapon.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 303ms:
"""Pistol weapon implementation."""

from __future__ import annotations

from src.weapons.weapon import Weapon


class Pistol(Weapon):
    """Default starter weapon with reliable semi-auto fire."""

    def __init__(self) -> None:
        super().__init__(
            name="Pistol",
            damage=20.0,
            fire_rate=3.0,
            magazine_size=12,
            reserve_ammo=48,
        )

 succeeded in 306ms:
"""Main game loop orchestration with delta-time updates."""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import Callable

from src.core.game_clock import GameClock
from src.core.game_state import GameState, GameStateManager

logger = logging.getLogger(__name__)


FrameCallback = Callable[[float], None]


@dataclass
class GameLoop:
    """Owns frame stepping and update dispatch for active gameplay."""
 succeeded in 306ms:
"""Input translation for keyboard movement and mouse look."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass(frozen=True)
class InputSnapshot:
    """Raw frame input values from platform layer."""

    pressed_keys: set[str]
    mouse_delta_x: float = 0.0
    mouse_delta_y: float = 0.0


@dataclass(frozen=True)
class InputFrame:
    """Normalized input values consumed by gameplay systems."""

 succeeded in 312ms:
"""Lightweight game clock and delta-time tracking."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class GameClock:
    """Tracks elapsed and per-frame timing."""

    elapsed_time: float = 0.0
    frame_count: int = 0
    _last_timestamp: float | None = None

    def tick(self, now: float) -> float:
        """Advance the clock and return frame delta-time in seconds."""
        if self._last_timestamp is None:
            self._last_timestamp = now
            return 0.0
 succeeded in 307ms:
"""Game state management for high-level flow transitions."""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum


class GameState(str, Enum):
    """Allowed top-level game states."""

    MENU = "menu"
    PLAYING = "playing"
    PAUSED = "paused"
    CRASHED = "crashed"


@dataclass
class GameStateManager:
    """Controls current state and validates state transitions."""
 succeeded in 304ms:
from dataclasses import FrozenInstanceError
import pytest
from config.config import GAME_CONFIG, ECONOMY_CONFIG, GameConfig, EconomyConfig

def test_game_config_defaults():
    """Verify that GameConfig loads with the expected default values."""
    assert GAME_CONFIG.game_title == "FPS Bot Arena: The Glitch"
    assert GAME_CONFIG.start_health == 100
    assert GAME_CONFIG.start_money == 0
    assert GAME_CONFIG.mouse_sensitivity == 40.0
    assert GAME_CONFIG.walk_speed == 5.0
    assert isinstance(GAME_CONFIG, GameConfig)

def test_economy_config_defaults():
    """Verify that EconomyConfig loads with the expected default values."""
    assert ECONOMY_CONFIG.shotgun_price == 300
    assert ECONOMY_CONFIG.assault_rifle_price == 900
    assert ECONOMY_CONFIG.rpg_price == 2500
    assert isinstance(ECONOMY_CONFIG, EconomyConfig)

 succeeded in 305ms:
"""Player model with health, currency, inventory, and shooting."""

from __future__ import annotations

from dataclasses import dataclass, field

from src.weapons.pistol import Pistol
from src.weapons.weapon import Weapon


@dataclass
class Player:
    """Encapsulates runtime player state and core gameplay actions."""

    max_health: int
    health: int
    money: int
    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
    rotation: tuple[float, float] = (0.0, 0.0)
    inventory: dict[str, Weapon] = field(default_factory=dict)
 succeeded in 286ms:
import pytest

from src.player.player import Player
from src.weapons.pistol import Pistol
from src.weapons.weapon import Weapon


def test_player_starter_loadout_and_properties():
    player = Player.with_starter_loadout(start_health=100, start_money=0)

    assert player.health == 100
    assert player.money == 0
    assert player.position == (0.0, 1.8, 0.0)
    assert player.rotation == (0.0, 0.0)
    assert player.equipped_weapon_name == "Pistol"
    assert isinstance(player.equipped_weapon, Pistol)


def test_player_health_system_damage_heal_and_death():
    player = Player.with_starter_loadout(start_health=100, start_money=0)
 succeeded in 286ms:
"""Base weapon model used by all weapon types."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class Weapon:
    """Shared weapon attributes and firing cooldown logic."""

    name: str
    damage: float
    fire_rate: float
    magazine_size: int
    reserve_ammo: int
    ammo_in_magazine: int | None = None
    _last_fired_at: float = -1_000_000.0

    def __post_init__(self) -> None:
 succeeded in 272ms:
import pytest

from src.core.game_clock import GameClock
from src.core.game_loop import GameLoop
from src.core.game_state import GameState, GameStateManager
from src.core.input_handler import InputHandler, InputSnapshot


def test_game_clock_tracks_delta_and_elapsed_time():
    clock = GameClock()

    assert clock.tick(10.0) == 0.0
    assert clock.elapsed_time == 0.0
    assert clock.frame_count == 0

    assert clock.tick(10.25) == 0.25
    assert clock.tick(10.75) == 0.5
    assert clock.elapsed_time == 0.75
    assert clock.frame_count == 2


thinking
**Considering config inspection**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content config/config.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 188ms:
"""Project-wide configuration for the FPS Bot Arena prototype.

This module centralizes tunable values so gameplay systems can import
one source of truth instead of hardcoding constants.
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class GameConfig:
    """Core configuration values for the current prototype."""

    game_title: str = "FPS Bot Arena: The Glitch"
    start_health: int = 100
    start_money: int = 0
    mouse_sensitivity: float = 40.0
    walk_speed: float = 5.0



thinking
**Planning task selection and guides**
codex
I’ve selected 10 cohesive unchecked tasks in core/player/weapons plus projectile physics so they can be fully implemented and tested together. I’m now adding the new runtime modules and tests, then I’ll update `tasks.md`, `recent-changes.md`, and all impacted developer guides (`src/*` and root).

thinking
**Inspecting initialization exports**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/player/__init__.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/__init__.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content config/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/__init__.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tests/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 229ms:
"""Player state and gameplay behavior."""

 succeeded in 230ms:
"""Core runtime systems for FPS Bot Arena."""

 succeeded in 230ms:
# Tests Developer Guide

## Overview
This directory contains the automated test suite for the FPS Bot Arena project.

## Testing Framework
- **Framework:** `pytest`
- **Rationale:** Standard, powerful, and easy-to-use testing framework for Python.

## Structure
- Test files should be named `test_<module_name>.py`.
- Tests should mirror the structure of the `src/` and `config/` directories where applicable.
- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.

## Current Test Modules
- `test_config.py`: validates immutable config defaults.
- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.

## Running Tests
 succeeded in 233ms:
# Developer Guide

## Purpose
`config/` contains centralized, importable configuration for gameplay and economy values.

## Files
- `config.py`: frozen dataclass-based configuration models and exported singleton config objects.

## How To Use
- Import `GAME_CONFIG` for core player/runtime constants.
- Import `ECONOMY_CONFIG` for weapon price progression values.
- Prefer updating values here rather than scattering literals across systems.
 succeeded in 230ms:
"""Weapon definitions and shared weapon behavior."""


thinking
**Planning modular system architecture**
codex
I have enough context and I’m starting edits now. I’m implementing new core modules for camera/collision/movement, extending player and weapon behavior (switching, reload, respawn/game-over, new weapon types), and adding a new `src/projectiles` package with physics + collision handling, then I’ll validate with pytest.

thinking
**Planning file update approach**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/weapon.py
@@ -5,4 +5,23 @@
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
@@ -16,2 +35,5 @@
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
@@ -24,2 +46,4 @@
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
@@ -29,2 +53,12 @@
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
@@ -43 +77,24 @@
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
apply_patch(auto_approved=true) exited 0 in 49ms:
Success. Updated the following files:
M src/weapons/weapon.py
file update:
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]


thinking
**Adding new weapon files**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/shotgun.py
"""Shotgun weapon implementation."""

from __future__ import annotations

import math

from src.weapons.weapon import Weapon


class Shotgun(Weapon):
    """High-damage close-range weapon with pellet spread."""

    def __init__(self) -> None:
        super().__init__(
            name="Shotgun",
            damage=12.0,
            fire_rate=1.0,
            magazine_size=8,
            reserve_ammo=32,
            projectile_speed=70.0,
            projectile_radius=0.1,
            projectile_kind="pellet",
        )
        self.pellet_count = 8
        self.spread_degrees = 6.0

    def create_projectile_payload(
        self,
        origin: tuple[float, float, float],
        direction: tuple[float, float, float],
    ) -> list[dict]:
        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
        spread_rad = math.radians(self.spread_degrees)
        payload: list[dict] = []
        for index in range(self.pellet_count):
            # Deterministic circular distribution keeps tests stable.
            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
            yaw_offset = ratio * spread_rad
            direction_x = base["direction"][0] + yaw_offset
            direction_y = base["direction"][1]
            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
            payload.append(
                {
                    **base,
                    "direction": (direction_x, direction_y, direction_z),
                }
            )
        return payload
apply_patch(auto_approved=true) exited 0 in 74ms:
Success. Updated the following files:
A src/weapons/shotgun.py
file update:
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/assault_rifle.py
"""Assault rifle weapon implementation."""

from __future__ import annotations

from src.weapons.weapon import Weapon


class AssaultRifle(Weapon):
    """Rapid-fire automatic weapon for mid-range combat."""

    def __init__(self) -> None:
        super().__init__(
            name="AssaultRifle",
            damage=16.0,
            fire_rate=9.0,
            magazine_size=30,
            reserve_ammo=120,
            projectile_speed=95.0,
            projectile_radius=0.07,
            projectile_kind="bullet",
        )
apply_patch(auto_approved=true) exited 0 in 89ms:
Success. Updated the following files:
A src/weapons/assault_rifle.py
file update:
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/rpg.py
"""RPG weapon implementation with special crash trigger behavior."""

from __future__ import annotations

from src.weapons.weapon import Weapon


class RPG(Weapon):
    """Endgame launcher that triggers the glitch sequence on fire."""

    def __init__(self) -> None:
        super().__init__(
            name="RPG",
            damage=200.0,
            fire_rate=0.5,
            magazine_size=1,
            reserve_ammo=3,
            projectile_speed=45.0,
            projectile_radius=0.3,
            projectile_kind="rocket",
        )
        self.crash_triggered = False

    def fire(self, now: float) -> bool:
        fired = super().fire(now)
        if fired:
            self.crash_triggered = True
        return fired
apply_patch(auto_approved=true) exited 0 in 107ms:
Success. Updated the following files:
A src/weapons/rpg.py
file update:
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]


thinking
**Adding core collision camera modules**
codex
I’m now wiring core runtime systems: first-person camera state, reusable AABB collision world, and movement logic that uses camera yaw plus collision checks. After that I’ll connect player shooting to projectile spawning.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/collision.py
"""AABB collision primitives used by movement and projectiles."""

from __future__ import annotations

from dataclasses import dataclass


Vector3 = tuple[float, float, float]


@dataclass(frozen=True)
class AABB:
    """Axis-aligned bounding box."""

    min_corner: Vector3
    max_corner: Vector3

    def intersects(self, other: "AABB") -> bool:
        return (
            self.min_corner[0] <= other.max_corner[0]
            and self.max_corner[0] >= other.min_corner[0]
            and self.min_corner[1] <= other.max_corner[1]
            and self.max_corner[1] >= other.min_corner[1]
            and self.min_corner[2] <= other.max_corner[2]
            and self.max_corner[2] >= other.min_corner[2]
        )


@dataclass
class CollisionWorld:
    """Container for static world collision volumes."""

    world_bounds: AABB
    static_walls: list[AABB]

    def collides_with_wall(self, box: AABB) -> bool:
        return any(wall.intersects(box) for wall in self.static_walls)

    def outside_world_bounds(self, box: AABB) -> bool:
        return not self.world_bounds.intersects(box)
apply_patch(auto_approved=true) exited 0 in 139ms:
Success. Updated the following files:
A src/core/collision.py
file update:
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/camera.py
"""First-person camera state and mouse-look handling."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class FirstPersonCamera:
    """Tracks first-person yaw/pitch with clamped vertical look."""

    yaw: float = 0.0
    pitch: float = 0.0
    min_pitch: float = -89.0
    max_pitch: float = 89.0
    eye_height: float = 1.8

    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
        self.yaw += look_yaw
        self.pitch += look_pitch
        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
        return self.yaw, self.pitch
apply_patch(auto_approved=true) exited 0 in 153ms:
Success. Updated the following files:
A src/core/camera.py
file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/movement.py
"""Player movement with collision detection against world geometry."""

from __future__ import annotations

import math
from dataclasses import dataclass

from src.core.collision import AABB, CollisionWorld


@dataclass
class PlayerMovementController:
    """Moves a player in local-space input while resolving collisions."""

    walk_speed: float
    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)

    def move(
        self,
        *,
        player_position: tuple[float, float, float],
        player_yaw_degrees: float,
        move_x: float,
        move_z: float,
        delta_time: float,
        collision_world: CollisionWorld,
    ) -> tuple[float, float, float]:
        if delta_time <= 0.0:
            return player_position

        yaw_rad = math.radians(player_yaw_degrees)
        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
        move_dir = (
            (right[0] * move_x) + (forward[0] * move_z),
            0.0,
            (right[2] * move_x) + (forward[2] * move_z),
        )
        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
        if length > 0:
            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)

        displacement = (
            move_dir[0] * self.walk_speed * delta_time,
            0.0,
            move_dir[2] * self.walk_speed * delta_time,
        )
        proposed = (
            player_position[0] + displacement[0],
            player_position[1],
            player_position[2] + displacement[2],
        )

        if self._is_valid_position(proposed, collision_world):
            return proposed

        slide_x = (
            player_position[0] + displacement[0],
            player_position[1],
            player_position[2],
        )
        if self._is_valid_position(slide_x, collision_world):
            return slide_x

        slide_z = (
            player_position[0],
            player_position[1],
            player_position[2] + displacement[2],
        )
        if self._is_valid_position(slide_z, collision_world):
            return slide_z
        return player_position

    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
        half_x, half_y, half_z = self.collider_half_size
        box = AABB(
            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
        )
        if world.outside_world_bounds(box):
            return False
        return not world.collides_with_wall(box)
apply_patch(auto_approved=true) exited 0 in 176ms:
Success. Updated the following files:
A src/core/movement.py
file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]


thinking
**Planning projectile feature setup**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'New-Item -ItemType Directory -Force src/projectiles | Out-Null' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 200ms:

file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]


thinking
**Initializing core modules**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/projectiles/__init__.py
"""Projectile entities and physics simulation."""
apply_patch(auto_approved=true) exited 0 in 188ms:
Success. Updated the following files:
A src/projectiles/__init__.py
file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

codex
I created a new `src/projectiles` package to cover both “projectile system” and “projectile physics/collision” tasks. I’m adding entity + simulation modules next, then hooking them into player/weapon APIs.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/projectiles/projectile.py
"""Projectile entities for bullets, pellets, and rockets."""

from __future__ import annotations

import math
from dataclasses import dataclass


Vector3 = tuple[float, float, float]


def _normalize(direction: Vector3) -> Vector3:
    length = math.sqrt(
        (direction[0] * direction[0])
        + (direction[1] * direction[1])
        + (direction[2] * direction[2])
    )
    if length <= 0.0:
        raise ValueError("Projectile direction must be non-zero.")
    return (
        direction[0] / length,
        direction[1] / length,
        direction[2] / length,
    )


@dataclass
class Projectile:
    """Simple projectile with position, velocity, and collision radius."""

    kind: str
    position: Vector3
    velocity: Vector3
    radius: float
    damage: float
    max_distance: float
    distance_traveled: float = 0.0
    is_active: bool = True

    @classmethod
    def from_payload(cls, payload: dict) -> "Projectile":
        direction = _normalize(payload["direction"])
        speed = payload["speed"]
        velocity = (
            direction[0] * speed,
            direction[1] * speed,
            direction[2] * speed,
        )
        return cls(
            kind=payload["kind"],
            position=payload["origin"],
            velocity=velocity,
            radius=payload["radius"],
            damage=payload["damage"],
            max_distance=payload.get("max_distance", 150.0),
        )

    def advance(self, delta_time: float) -> None:
        if not self.is_active or delta_time <= 0.0:
            return
        displacement = (
            self.velocity[0] * delta_time,
            self.velocity[1] * delta_time,
            self.velocity[2] * delta_time,
        )
        self.position = (
            self.position[0] + displacement[0],
            self.position[1] + displacement[1],
            self.position[2] + displacement[2],
        )
        self.distance_traveled += math.sqrt(
            (displacement[0] * displacement[0])
            + (displacement[1] * displacement[1])
            + (displacement[2] * displacement[2])
        )
        if self.distance_traveled >= self.max_distance:
            self.is_active = False
apply_patch(auto_approved=true) exited 0 in 220ms:
Success. Updated the following files:
A src/projectiles/projectile.py
file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/projectiles/physics.py
"""Projectile simulation with world collision detection."""

from __future__ import annotations

from dataclasses import dataclass

from src.core.collision import AABB, CollisionWorld
from src.projectiles.projectile import Projectile


@dataclass
class ProjectilePhysicsSystem:
    """Advances projectiles and deactivates on world collision."""

    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
        collision_count = 0
        for projectile in projectiles:
            if not projectile.is_active:
                continue
            projectile.advance(delta_time)
            if not projectile.is_active:
                continue
            projectile_box = AABB(
                min_corner=(
                    projectile.position[0] - projectile.radius,
                    projectile.position[1] - projectile.radius,
                    projectile.position[2] - projectile.radius,
                ),
                max_corner=(
                    projectile.position[0] + projectile.radius,
                    projectile.position[1] + projectile.radius,
                    projectile.position[2] + projectile.radius,
                ),
            )
            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
                projectile.is_active = False
                collision_count += 1
        return collision_count
apply_patch(auto_approved=true) exited 0 in 237ms:
Success. Updated the following files:
A src/projectiles/physics.py
file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]


thinking
**Implementing core player actions**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/player/player.py
@@ -6,2 +6,3 @@
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
@@ -21,2 +22,3 @@
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
@@ -60,2 +62,4 @@
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
@@ -90,5 +94,23 @@
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
@@ -96 +118,21 @@
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
apply_patch(auto_approved=true) exited 0 in 251ms:
Success. Updated the following files:
M src/player/player.py
file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]


thinking
**Planning import and structure cleanup**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/__init__.py
@@ -2 +2,8 @@
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
apply_patch(auto_approved=true) exited 0 in 282ms:
Success. Updated the following files:
M src/weapons/__init__.py
file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]


thinking
**Planning core exports patch**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/__init__.py
@@ -2 +2,22 @@
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
apply_patch(auto_approved=true) exited 0 in 300ms:
Success. Updated the following files:
M src/core/__init__.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]


thinking
**Considering export adjustment**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/player/__init__.py
@@ -2 +2,4 @@
 
+from src.player.player import Player
+
+__all__ = ["Player"]
apply_patch(auto_approved=true) exited 0 in 309ms:
Success. Updated the following files:
M src/player/__init__.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]


thinking
**Planning comprehensive test additions**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_advanced_combat_and_movement.py
from src.core.camera import FirstPersonCamera
from src.core.collision import AABB, CollisionWorld
from src.core.input_handler import InputHandler, InputSnapshot
from src.core.movement import PlayerMovementController
from src.player.player import Player
from src.projectiles.physics import ProjectilePhysicsSystem
from src.weapons.assault_rifle import AssaultRifle
from src.weapons.rpg import RPG
from src.weapons.shotgun import Shotgun


def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
    handler = InputHandler(mouse_sensitivity=1.0)
    camera = FirstPersonCamera()
    frame = handler.build_frame(
        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
    )
    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
    assert yaw == 12.0
    assert pitch == 89.0


def test_player_movement_resolves_wall_collision_with_slide():
    world = CollisionWorld(
        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
        static_walls=[AABB(min_corner=(0.5, 0.0, 1.5), max_corner=(1.5, 3.0, 2.5))],
    )
    movement = PlayerMovementController(walk_speed=4.0)
    next_pos = movement.move(
        player_position=(0.0, 1.8, 1.7),
        player_yaw_degrees=0.0,
        move_x=1.0,
        move_z=1.0,
        delta_time=0.5,
        collision_world=world,
    )
    assert next_pos[0] > 0.0
    assert next_pos[2] == 1.7


def test_player_weapon_switch_reload_and_game_over_respawn():
    player = Player.with_starter_loadout(start_health=100, start_money=0)
    player.add_weapon(Shotgun())
    player.add_weapon(AssaultRifle())
    assert player.cycle_weapon(1) == "Shotgun"
    assert player.cycle_weapon(1) == "AssaultRifle"
    assert player.cycle_weapon(-1) == "Shotgun"

    player.equipped_weapon.ammo_in_magazine = 2
    player.equipped_weapon.reserve_ammo = 10
    loaded = player.reload_weapon()
    assert loaded == 6
    assert player.equipped_weapon.ammo_in_magazine == 8
    assert player.equipped_weapon.reserve_ammo == 4

    player.apply_damage(999)
    assert player.is_game_over is True
    assert player.shoot(10.0) is False
    player.respawn((1.0, 1.8, 2.0))
    assert player.is_game_over is False
    assert player.health == 100
    assert player.position == (1.0, 1.8, 2.0)


def test_shotgun_assault_rifle_and_rpg_behaviors():
    shotgun = Shotgun()
    payload = shotgun.create_projectile_payload(
        origin=(0.0, 0.0, 0.0),
        direction=(0.0, 0.0, 1.0),
    )
    assert len(payload) == shotgun.pellet_count
    assert payload[0]["kind"] == "pellet"

    rifle = AssaultRifle()
    assert rifle.fire(1.0) is True
    assert rifle.fire(1.05) is False
    assert rifle.fire(1.12) is True

    rpg = RPG()
    assert rpg.crash_triggered is False
    assert rpg.fire(2.0) is True
    assert rpg.crash_triggered is True


def test_projectile_system_and_collision_physics():
    world = CollisionWorld(
        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
    )
    player = Player.with_starter_loadout(start_health=100, start_money=0)
    projectiles = player.shoot_projectiles(
        now=1.0,
        origin=(0.0, 0.0, 0.0),
        direction=(1.0, 0.0, 0.0),
    )
    assert len(projectiles) == 1
    physics = ProjectilePhysicsSystem()
    collisions = physics.step(projectiles, delta_time=0.05, world=world)
    assert collisions == 1
    assert projectiles[0].is_active is False
apply_patch(auto_approved=true) exited 0 in 348ms:
Success. Updated the following files:
A tests/test_advanced_combat_and_movement.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..90c662f9b8d7febd7512bd92110bfcaf62d9a71c
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.5, 0.0, 1.5), max_corner=(1.5, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 1.7),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 1.7
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..90c662f9b8d7febd7512bd92110bfcaf62d9a71c
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.5, 0.0, 1.5), max_corner=(1.5, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 1.7),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 1.7
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Adjusting direction normalization**
codex
Core/player/weapons/projectile implementations are in place. I’m running the full test suite now to verify these 10 tasks are actually complete before I mark anything in `tasks.md`.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 exited 1 in 579ms:
.F.................                                                      [100%]
================================== FAILURES ===================================
___________ test_player_movement_resolves_wall_collision_with_slide ___________

    def test_player_movement_resolves_wall_collision_with_slide():
        world = CollisionWorld(
            world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
            static_walls=[AABB(min_corner=(0.5, 0.0, 1.5), max_corner=(1.5, 3.0, 2.5))],
        )
        movement = PlayerMovementController(walk_speed=4.0)
        next_pos = movement.move(
            player_position=(0.0, 1.8, 1.7),
            player_yaw_degrees=0.0,
            move_x=1.0,
            move_z=1.0,
            delta_time=0.5,
            collision_world=world,
        )
        assert next_pos[0] > 0.0
>       assert next_pos[2] == 1.7
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..90c662f9b8d7febd7512bd92110bfcaf62d9a71c
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.5, 0.0, 1.5), max_corner=(1.5, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 1.7),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 1.7
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Adjusting test geometry for collision**
codex
One movement test failed because the scenario didn’t actually force a wall collision. I’m adjusting the fixture geometry so diagonal movement is blocked and the slide-along-X behavior is tested correctly, then rerunning tests.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_advanced_combat_and_movement.py
@@ -25,3 +25,3 @@
         world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
-        static_walls=[AABB(min_corner=(0.5, 0.0, 1.5), max_corner=(1.5, 3.0, 2.5))],
+        static_walls=[AABB(min_corner=(-0.2, 0.0, 0.5), max_corner=(0.2, 3.0, 3.0))],
     )
@@ -29,3 +29,3 @@
     next_pos = movement.move(
-        player_position=(0.0, 1.8, 1.7),
+        player_position=(0.0, 1.8, 0.3),
         player_yaw_degrees=0.0,
@@ -37,3 +37,3 @@
     assert next_pos[0] > 0.0
-    assert next_pos[2] == 1.7
+    assert next_pos[2] == 0.3
 
apply_patch(auto_approved=true) exited 0 in 339ms:
Success. Updated the following files:
M tests/test_advanced_combat_and_movement.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..56a08d466359b354ed61868dbc706f35f71cfe51
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(-0.2, 0.0, 0.5), max_corner=(0.2, 3.0, 3.0))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..56a08d466359b354ed61868dbc706f35f71cfe51
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(-0.2, 0.0, 0.5), max_corner=(0.2, 3.0, 3.0))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Running tests**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 exited 1 in 564ms:
.F.................                                                      [100%]
================================== FAILURES ===================================
___________ test_player_movement_resolves_wall_collision_with_slide ___________

    def test_player_movement_resolves_wall_collision_with_slide():
        world = CollisionWorld(
            world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
            static_walls=[AABB(min_corner=(-0.2, 0.0, 0.5), max_corner=(0.2, 3.0, 3.0))],
        )
        movement = PlayerMovementController(walk_speed=4.0)
        next_pos = movement.move(
            player_position=(0.0, 1.8, 0.3),
            player_yaw_degrees=0.0,
            move_x=1.0,
            move_z=1.0,
            delta_time=0.5,
            collision_world=world,
        )
        assert next_pos[0] > 0.0
>       assert next_pos[2] == 0.3
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..56a08d466359b354ed61868dbc706f35f71cfe51
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(-0.2, 0.0, 0.5), max_corner=(0.2, 3.0, 3.0))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Adjusting wall placement for collision**
codex
The test still wasn’t constructing the right blocked path. I’m making one more targeted fix to the wall AABB so diagonal movement intersects while pure X slide remains valid.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_advanced_combat_and_movement.py
@@ -25,3 +25,3 @@
         world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
-        static_walls=[AABB(min_corner=(-0.2, 0.0, 0.5), max_corner=(0.2, 3.0, 3.0))],
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
     )
apply_patch(auto_approved=true) exited 0 in 339ms:
Success. Updated the following files:
M tests/test_advanced_combat_and_movement.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 520ms:
...................                                                      [100%]
19 passed in 0.06s
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Planning developer guide and task updates**
codex
Implementation and tests are passing. I’m now updating documentation artifacts: marking completed tasks in `tasks.md`, appending `recent-changes.md`, and refreshing all impacted developer guides (root, `src`, and changed subfolders including the new `src/projectiles`).

thinking
**Patching developer guide root**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md
@@ -9,4 +9,6 @@
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
@@ -14,5 +16,6 @@
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
@@ -35,5 +38,8 @@
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
apply_patch(auto_approved=true) exited 0 in 365ms:
Success. Updated the following files:
M developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Updating developer guide**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/developer-guide.md
@@ -3,8 +3,9 @@
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
@@ -12,5 +13,6 @@
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
apply_patch(auto_approved=true) exited 0 in 389ms:
Success. Updated the following files:
M src/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Updating developer guide**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/developer-guide.md
@@ -10,2 +10,5 @@
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
@@ -15,2 +18,4 @@
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
apply_patch(auto_approved=true) exited 0 in 505ms:
Success. Updated the following files:
M src/core/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/player/developer-guide.md
@@ -20,4 +20,10 @@
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
apply_patch(auto_approved=true) exited 0 in 469ms:
Success. Updated the following files:
M src/player/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/developer-guide.md
@@ -8,2 +8,5 @@
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
@@ -14,2 +17,4 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
@@ -19,2 +24 @@
   - reserve ammo `48`
-
apply_patch(auto_approved=true) exited 0 in 496ms:
Success. Updated the following files:
M src/weapons/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Creating missing developer guide**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/projectiles/developer-guide.md
# Projectiles Developer Guide

## Purpose
`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.

## Files
- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.

## Runtime Flow
1. A weapon returns payload dictionaries describing projectile spawn info.
2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
apply_patch(auto_approved=true) exited 0 in 473ms:
Success. Updated the following files:
A src/projectiles/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/developer-guide.md b/src/projectiles/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..fe91f591e1ca6dc46aff79cf507428ddbdd11509
--- /dev/null
+++ b/src/projectiles/developer-guide.md
@@ -0,0 +1,14 @@
+# Projectiles Developer Guide
+
+## Purpose
+`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.
+
+## Files
+- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
+- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.
+
+## Runtime Flow
+1. A weapon returns payload dictionaries describing projectile spawn info.
+2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
+3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
+4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/developer-guide.md b/src/projectiles/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..fe91f591e1ca6dc46aff79cf507428ddbdd11509
--- /dev/null
+++ b/src/projectiles/developer-guide.md
@@ -0,0 +1,14 @@
+# Projectiles Developer Guide
+
+## Purpose
+`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.
+
+## Files
+- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
+- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.
+
+## Runtime Flow
+1. A weapon returns payload dictionaries describing projectile spawn info.
+2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
+3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
+4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Planning test documentation update**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/developer-guide.md
@@ -18,2 +18,3 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
+- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
 
apply_patch(auto_approved=true) exited 0 in 487ms:
Success. Updated the following files:
M tests/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/developer-guide.md b/src/projectiles/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..fe91f591e1ca6dc46aff79cf507428ddbdd11509
--- /dev/null
+++ b/src/projectiles/developer-guide.md
@@ -0,0 +1,14 @@
+# Projectiles Developer Guide
+
+## Purpose
+`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.
+
+## Files
+- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
+- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.
+
+## Runtime Flow
+1. A weapon returns payload dictionaries describing projectile spawn info.
+2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
+3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
+4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 6c1bc5780d8c0fd4ec59223480d74aaab239f16d..540f1701a37b66aec941fba6e4268e37f7d7af47
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -16,6 +16,7 @@
 - `test_config.py`: validates immutable config defaults.
 - `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
+- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/developer-guide.md b/src/projectiles/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..fe91f591e1ca6dc46aff79cf507428ddbdd11509
--- /dev/null
+++ b/src/projectiles/developer-guide.md
@@ -0,0 +1,14 @@
+# Projectiles Developer Guide
+
+## Purpose
+`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.
+
+## Files
+- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
+- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.
+
+## Runtime Flow
+1. A weapon returns payload dictionaries describing projectile spawn info.
+2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
+3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
+4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 6c1bc5780d8c0fd4ec59223480d74aaab239f16d..540f1701a37b66aec941fba6e4268e37f7d7af47
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -16,6 +16,7 @@
 - `test_config.py`: validates immutable config defaults.
 - `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
+- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Updating core initialization and task annotations**
codex
I’m updating tracking files now: marking exactly the 10 completed items in `tasks.md` and writing a dated summary in `recent-changes.md` of the implemented systems and test coverage.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tasks.md
@@ -14,6 +14,6 @@
 - [x] Create game state manager to handle different states (menu, playing, paused, crashed)
-- [ ] Implement camera system with first-person perspective and mouse look controls
+- [x] Implement camera system with first-person perspective and mouse look controls
 - [x] Create input handler for WASD movement and mouse controls
-- [ ] Implement player movement with collision detection
-- [ ] Create physics system for projectile movement and collision
+- [x] Implement player movement with collision detection
+- [x] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
@@ -27,5 +27,5 @@
 - [x] Implement player inventory system to track owned weapons
-- [ ] Create player weapon switching logic
+- [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
-- [ ] Add player respawn or game over logic on death
+- [x] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
@@ -36,8 +36,8 @@
 - [x] Implement Pistol weapon with stats and firing behavior
-- [ ] Implement Shotgun weapon with spread pattern and high damage
-- [ ] Implement Assault Rifle weapon with rapid fire mechanics
-- [ ] Implement RPG weapon with special "crash" trigger behavior
+- [x] Implement Shotgun weapon with spread pattern and high damage
+- [x] Implement Assault Rifle weapon with rapid fire mechanics
+- [x] Implement RPG weapon with special "crash" trigger behavior
 - [ ] Create weapon switching system with smooth transitions
-- [ ] Implement ammo management and reload mechanics
-- [ ] Create projectile system for bullets and rockets
+- [x] Implement ammo management and reload mechanics
+- [x] Create projectile system for bullets and rockets
 - [ ] Add weapon visual representations using geometric primitives
apply_patch(auto_approved=true) exited 0 in 505ms:
Success. Updated the following files:
M tasks.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/developer-guide.md b/src/projectiles/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..fe91f591e1ca6dc46aff79cf507428ddbdd11509
--- /dev/null
+++ b/src/projectiles/developer-guide.md
@@ -0,0 +1,14 @@
+# Projectiles Developer Guide
+
+## Purpose
+`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.
+
+## Files
+- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
+- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.
+
+## Runtime Flow
+1. A weapon returns payload dictionaries describing projectile spawn info.
+2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
+3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
+4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tasks.md b/tasks.md
index 770ff01b25baf8262f6012c025852e3bde9193f0..e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f
--- a/tasks.md
+++ b/tasks.md
@@ -12,10 +12,10 @@
 
 - [x] Implement main game loop with frame updates and delta time handling
 - [x] Create game state manager to handle different states (menu, playing, paused, crashed)
-- [ ] Implement camera system with first-person perspective and mouse look controls
+- [x] Implement camera system with first-person perspective and mouse look controls
 - [x] Create input handler for WASD movement and mouse controls
-- [ ] Implement player movement with collision detection
-- [ ] Create physics system for projectile movement and collision
+- [x] Implement player movement with collision detection
+- [x] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
 - [ ] Create game clock and time management system
 
@@ -25,21 +25,21 @@
 - [x] Implement player health system with damage and death handling
 - [x] Create player money/currency tracking system
 - [x] Implement player inventory system to track owned weapons
-- [ ] Create player weapon switching logic
+- [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
-- [ ] Add player respawn or game over logic on death
+- [x] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
 - [x] Create base Weapon class with common properties (damage, ammo, fire rate)
 - [x] Implement Pistol weapon with stats and firing behavior
-- [ ] Implement Shotgun weapon with spread pattern and high damage
-- [ ] Implement Assault Rifle weapon with rapid fire mechanics
-- [ ] Implement RPG weapon with special "crash" trigger behavior
+- [x] Implement Shotgun weapon with spread pattern and high damage
+- [x] Implement Assault Rifle weapon with rapid fire mechanics
+- [x] Implement RPG weapon with special "crash" trigger behavior
 - [ ] Create weapon switching system with smooth transitions
-- [ ] Implement ammo management and reload mechanics
-- [ ] Create projectile system for bullets and rockets
+- [x] Implement ammo management and reload mechanics
+- [x] Create projectile system for bullets and rockets
 - [ ] Add weapon visual representations using geometric primitives
 - [ ] Create src/weapons folder developer-guide.md
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 6c1bc5780d8c0fd4ec59223480d74aaab239f16d..540f1701a37b66aec941fba6e4268e37f7d7af47
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -16,6 +16,7 @@
 - `test_config.py`: validates immutable config defaults.
 - `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
+- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/developer-guide.md b/src/projectiles/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..fe91f591e1ca6dc46aff79cf507428ddbdd11509
--- /dev/null
+++ b/src/projectiles/developer-guide.md
@@ -0,0 +1,14 @@
+# Projectiles Developer Guide
+
+## Purpose
+`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.
+
+## Files
+- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
+- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.
+
+## Runtime Flow
+1. A weapon returns payload dictionaries describing projectile spawn info.
+2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
+3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
+4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tasks.md b/tasks.md
index 770ff01b25baf8262f6012c025852e3bde9193f0..e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f
--- a/tasks.md
+++ b/tasks.md
@@ -12,10 +12,10 @@
 
 - [x] Implement main game loop with frame updates and delta time handling
 - [x] Create game state manager to handle different states (menu, playing, paused, crashed)
-- [ ] Implement camera system with first-person perspective and mouse look controls
+- [x] Implement camera system with first-person perspective and mouse look controls
 - [x] Create input handler for WASD movement and mouse controls
-- [ ] Implement player movement with collision detection
-- [ ] Create physics system for projectile movement and collision
+- [x] Implement player movement with collision detection
+- [x] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
 - [ ] Create game clock and time management system
 
@@ -25,21 +25,21 @@
 - [x] Implement player health system with damage and death handling
 - [x] Create player money/currency tracking system
 - [x] Implement player inventory system to track owned weapons
-- [ ] Create player weapon switching logic
+- [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
-- [ ] Add player respawn or game over logic on death
+- [x] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
 - [x] Create base Weapon class with common properties (damage, ammo, fire rate)
 - [x] Implement Pistol weapon with stats and firing behavior
-- [ ] Implement Shotgun weapon with spread pattern and high damage
-- [ ] Implement Assault Rifle weapon with rapid fire mechanics
-- [ ] Implement RPG weapon with special "crash" trigger behavior
+- [x] Implement Shotgun weapon with spread pattern and high damage
+- [x] Implement Assault Rifle weapon with rapid fire mechanics
+- [x] Implement RPG weapon with special "crash" trigger behavior
 - [ ] Create weapon switching system with smooth transitions
-- [ ] Implement ammo management and reload mechanics
-- [ ] Create projectile system for bullets and rockets
+- [x] Implement ammo management and reload mechanics
+- [x] Create projectile system for bullets and rockets
 - [ ] Add weapon visual representations using geometric primitives
 - [ ] Create src/weapons folder developer-guide.md
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 6c1bc5780d8c0fd4ec59223480d74aaab239f16d..540f1701a37b66aec941fba6e4268e37f7d7af47
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -16,6 +16,7 @@
 - `test_config.py`: validates immutable config defaults.
 - `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
+- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Adding dated bullets to changelog**
🌐 Searching the web...
🌐 Searched the web
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\recent-changes.md
@@ -1,2 +1,18 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented first-person camera state in `src/core/camera.py` with yaw/pitch mouse-look updates and pitch clamping.
+- Implemented collision primitives and movement controller in `src/core/collision.py` and `src/core/movement.py` for player movement with wall/bounds collision and slide resolution.
+- Added new weapon implementations:
+  - `src/weapons/shotgun.py` (pellet spread payload)
+  - `src/weapons/assault_rifle.py` (rapid fire)
+  - `src/weapons/rpg.py` (crash trigger flag when fired)
+- Extended `src/weapons/weapon.py` with ammo reload mechanics, total ammo tracking, and projectile payload generation.
+- Extended `src/player/player.py` with weapon cycling, reload delegation, projectile firing API, game-over state on death, and respawn handling.
+- Added projectile package `src/projectiles/`:
+  - `projectile.py` for projectile entities and movement/lifetime
+  - `physics.py` for projectile movement and world collision deactivation
+- Updated package exports in `src/core/__init__.py`, `src/player/__init__.py`, and `src/weapons/__init__.py`.
+- Added `tests/test_advanced_combat_and_movement.py` covering camera look, movement collision, weapon switching/reload/respawn, new weapons, and projectile physics.
+- Verified full test suite passes: `19 passed`.
 
apply_patch(auto_approved=true) exited 0 in 529ms:
Success. Updated the following files:
M recent-changes.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..981d1266aedb312c64fcf41ac04e84440e1d4fc8
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,18 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented first-person camera state in `src/core/camera.py` with yaw/pitch mouse-look updates and pitch clamping.
+- Implemented collision primitives and movement controller in `src/core/collision.py` and `src/core/movement.py` for player movement with wall/bounds collision and slide resolution.
+- Added new weapon implementations:
+  - `src/weapons/shotgun.py` (pellet spread payload)
+  - `src/weapons/assault_rifle.py` (rapid fire)
+  - `src/weapons/rpg.py` (crash trigger flag when fired)
+- Extended `src/weapons/weapon.py` with ammo reload mechanics, total ammo tracking, and projectile payload generation.
+- Extended `src/player/player.py` with weapon cycling, reload delegation, projectile firing API, game-over state on death, and respawn handling.
+- Added projectile package `src/projectiles/`:
+  - `projectile.py` for projectile entities and movement/lifetime
+  - `physics.py` for projectile movement and world collision deactivation
+- Updated package exports in `src/core/__init__.py`, `src/player/__init__.py`, and `src/weapons/__init__.py`.
+- Added `tests/test_advanced_combat_and_movement.py` covering camera look, movement collision, weapon switching/reload/respawn, new weapons, and projectile physics.
+- Verified full test suite passes: `19 passed`.
 
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/developer-guide.md b/src/projectiles/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..fe91f591e1ca6dc46aff79cf507428ddbdd11509
--- /dev/null
+++ b/src/projectiles/developer-guide.md
@@ -0,0 +1,14 @@
+# Projectiles Developer Guide
+
+## Purpose
+`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.
+
+## Files
+- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
+- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.
+
+## Runtime Flow
+1. A weapon returns payload dictionaries describing projectile spawn info.
+2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
+3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
+4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tasks.md b/tasks.md
index 770ff01b25baf8262f6012c025852e3bde9193f0..e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f
--- a/tasks.md
+++ b/tasks.md
@@ -12,10 +12,10 @@
 
 - [x] Implement main game loop with frame updates and delta time handling
 - [x] Create game state manager to handle different states (menu, playing, paused, crashed)
-- [ ] Implement camera system with first-person perspective and mouse look controls
+- [x] Implement camera system with first-person perspective and mouse look controls
 - [x] Create input handler for WASD movement and mouse controls
-- [ ] Implement player movement with collision detection
-- [ ] Create physics system for projectile movement and collision
+- [x] Implement player movement with collision detection
+- [x] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
 - [ ] Create game clock and time management system
 
@@ -25,21 +25,21 @@
 - [x] Implement player health system with damage and death handling
 - [x] Create player money/currency tracking system
 - [x] Implement player inventory system to track owned weapons
-- [ ] Create player weapon switching logic
+- [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
-- [ ] Add player respawn or game over logic on death
+- [x] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
 - [x] Create base Weapon class with common properties (damage, ammo, fire rate)
 - [x] Implement Pistol weapon with stats and firing behavior
-- [ ] Implement Shotgun weapon with spread pattern and high damage
-- [ ] Implement Assault Rifle weapon with rapid fire mechanics
-- [ ] Implement RPG weapon with special "crash" trigger behavior
+- [x] Implement Shotgun weapon with spread pattern and high damage
+- [x] Implement Assault Rifle weapon with rapid fire mechanics
+- [x] Implement RPG weapon with special "crash" trigger behavior
 - [ ] Create weapon switching system with smooth transitions
-- [ ] Implement ammo management and reload mechanics
-- [ ] Create projectile system for bullets and rockets
+- [x] Implement ammo management and reload mechanics
+- [x] Create projectile system for bullets and rockets
 - [ ] Add weapon visual representations using geometric primitives
 - [ ] Create src/weapons folder developer-guide.md
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 6c1bc5780d8c0fd4ec59223480d74aaab239f16d..540f1701a37b66aec941fba6e4268e37f7d7af47
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -16,6 +16,7 @@
 - `test_config.py`: validates immutable config defaults.
 - `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
+- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..981d1266aedb312c64fcf41ac04e84440e1d4fc8
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,18 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented first-person camera state in `src/core/camera.py` with yaw/pitch mouse-look updates and pitch clamping.
+- Implemented collision primitives and movement controller in `src/core/collision.py` and `src/core/movement.py` for player movement with wall/bounds collision and slide resolution.
+- Added new weapon implementations:
+  - `src/weapons/shotgun.py` (pellet spread payload)
+  - `src/weapons/assault_rifle.py` (rapid fire)
+  - `src/weapons/rpg.py` (crash trigger flag when fired)
+- Extended `src/weapons/weapon.py` with ammo reload mechanics, total ammo tracking, and projectile payload generation.
+- Extended `src/player/player.py` with weapon cycling, reload delegation, projectile firing API, game-over state on death, and respawn handling.
+- Added projectile package `src/projectiles/`:
+  - `projectile.py` for projectile entities and movement/lifetime
+  - `physics.py` for projectile movement and world collision deactivation
+- Updated package exports in `src/core/__init__.py`, `src/player/__init__.py`, and `src/weapons/__init__.py`.
+- Added `tests/test_advanced_combat_and_movement.py` covering camera look, movement collision, weapon switching/reload/respawn, new weapons, and projectile physics.
+- Verified full test suite passes: `19 passed`.
 
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/developer-guide.md b/src/projectiles/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..fe91f591e1ca6dc46aff79cf507428ddbdd11509
--- /dev/null
+++ b/src/projectiles/developer-guide.md
@@ -0,0 +1,14 @@
+# Projectiles Developer Guide
+
+## Purpose
+`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.
+
+## Files
+- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
+- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.
+
+## Runtime Flow
+1. A weapon returns payload dictionaries describing projectile spawn info.
+2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
+3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
+4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tasks.md b/tasks.md
index 770ff01b25baf8262f6012c025852e3bde9193f0..e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f
--- a/tasks.md
+++ b/tasks.md
@@ -12,10 +12,10 @@
 
 - [x] Implement main game loop with frame updates and delta time handling
 - [x] Create game state manager to handle different states (menu, playing, paused, crashed)
-- [ ] Implement camera system with first-person perspective and mouse look controls
+- [x] Implement camera system with first-person perspective and mouse look controls
 - [x] Create input handler for WASD movement and mouse controls
-- [ ] Implement player movement with collision detection
-- [ ] Create physics system for projectile movement and collision
+- [x] Implement player movement with collision detection
+- [x] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
 - [ ] Create game clock and time management system
 
@@ -25,21 +25,21 @@
 - [x] Implement player health system with damage and death handling
 - [x] Create player money/currency tracking system
 - [x] Implement player inventory system to track owned weapons
-- [ ] Create player weapon switching logic
+- [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
-- [ ] Add player respawn or game over logic on death
+- [x] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
 - [x] Create base Weapon class with common properties (damage, ammo, fire rate)
 - [x] Implement Pistol weapon with stats and firing behavior
-- [ ] Implement Shotgun weapon with spread pattern and high damage
-- [ ] Implement Assault Rifle weapon with rapid fire mechanics
-- [ ] Implement RPG weapon with special "crash" trigger behavior
+- [x] Implement Shotgun weapon with spread pattern and high damage
+- [x] Implement Assault Rifle weapon with rapid fire mechanics
+- [x] Implement RPG weapon with special "crash" trigger behavior
 - [ ] Create weapon switching system with smooth transitions
-- [ ] Implement ammo management and reload mechanics
-- [ ] Create projectile system for bullets and rockets
+- [x] Implement ammo management and reload mechanics
+- [x] Create projectile system for bullets and rockets
 - [ ] Add weapon visual representations using geometric primitives
 - [ ] Create src/weapons folder developer-guide.md
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 6c1bc5780d8c0fd4ec59223480d74aaab239f16d..540f1701a37b66aec941fba6e4268e37f7d7af47
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -16,6 +16,7 @@
 - `test_config.py`: validates immutable config defaults.
 - `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
+- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Confirming test run necessity**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 522ms:
...................                                                      [100%]
19 passed in 0.04s
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..981d1266aedb312c64fcf41ac04e84440e1d4fc8
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,18 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented first-person camera state in `src/core/camera.py` with yaw/pitch mouse-look updates and pitch clamping.
+- Implemented collision primitives and movement controller in `src/core/collision.py` and `src/core/movement.py` for player movement with wall/bounds collision and slide resolution.
+- Added new weapon implementations:
+  - `src/weapons/shotgun.py` (pellet spread payload)
+  - `src/weapons/assault_rifle.py` (rapid fire)
+  - `src/weapons/rpg.py` (crash trigger flag when fired)
+- Extended `src/weapons/weapon.py` with ammo reload mechanics, total ammo tracking, and projectile payload generation.
+- Extended `src/player/player.py` with weapon cycling, reload delegation, projectile firing API, game-over state on death, and respawn handling.
+- Added projectile package `src/projectiles/`:
+  - `projectile.py` for projectile entities and movement/lifetime
+  - `physics.py` for projectile movement and world collision deactivation
+- Updated package exports in `src/core/__init__.py`, `src/player/__init__.py`, and `src/weapons/__init__.py`.
+- Added `tests/test_advanced_combat_and_movement.py` covering camera look, movement collision, weapon switching/reload/respawn, new weapons, and projectile physics.
+- Verified full test suite passes: `19 passed`.
 
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/developer-guide.md b/src/projectiles/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..fe91f591e1ca6dc46aff79cf507428ddbdd11509
--- /dev/null
+++ b/src/projectiles/developer-guide.md
@@ -0,0 +1,14 @@
+# Projectiles Developer Guide
+
+## Purpose
+`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.
+
+## Files
+- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
+- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.
+
+## Runtime Flow
+1. A weapon returns payload dictionaries describing projectile spawn info.
+2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
+3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
+4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tasks.md b/tasks.md
index 770ff01b25baf8262f6012c025852e3bde9193f0..e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f
--- a/tasks.md
+++ b/tasks.md
@@ -12,10 +12,10 @@
 
 - [x] Implement main game loop with frame updates and delta time handling
 - [x] Create game state manager to handle different states (menu, playing, paused, crashed)
-- [ ] Implement camera system with first-person perspective and mouse look controls
+- [x] Implement camera system with first-person perspective and mouse look controls
 - [x] Create input handler for WASD movement and mouse controls
-- [ ] Implement player movement with collision detection
-- [ ] Create physics system for projectile movement and collision
+- [x] Implement player movement with collision detection
+- [x] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
 - [ ] Create game clock and time management system
 
@@ -25,21 +25,21 @@
 - [x] Implement player health system with damage and death handling
 - [x] Create player money/currency tracking system
 - [x] Implement player inventory system to track owned weapons
-- [ ] Create player weapon switching logic
+- [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
-- [ ] Add player respawn or game over logic on death
+- [x] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
 - [x] Create base Weapon class with common properties (damage, ammo, fire rate)
 - [x] Implement Pistol weapon with stats and firing behavior
-- [ ] Implement Shotgun weapon with spread pattern and high damage
-- [ ] Implement Assault Rifle weapon with rapid fire mechanics
-- [ ] Implement RPG weapon with special "crash" trigger behavior
+- [x] Implement Shotgun weapon with spread pattern and high damage
+- [x] Implement Assault Rifle weapon with rapid fire mechanics
+- [x] Implement RPG weapon with special "crash" trigger behavior
 - [ ] Create weapon switching system with smooth transitions
-- [ ] Implement ammo management and reload mechanics
-- [ ] Create projectile system for bullets and rockets
+- [x] Implement ammo management and reload mechanics
+- [x] Create projectile system for bullets and rockets
 - [ ] Add weapon visual representations using geometric primitives
 - [ ] Create src/weapons folder developer-guide.md
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 6c1bc5780d8c0fd4ec59223480d74aaab239f16d..540f1701a37b66aec941fba6e4268e37f7d7af47
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -16,6 +16,7 @@
 - `test_config.py`: validates immutable config defaults.
 - `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
+- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'git status --short' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 198ms:
 M .agentharness/git-commit-message.txt
 D .codex_last_message.txt
 M developer-guide.md
 M recent-changes.md
 M src/core/__init__.py
 M src/core/__pycache__/__init__.cpython-311.pyc
 M src/core/developer-guide.md
 M src/developer-guide.md
 M src/player/__init__.py
 M src/player/__pycache__/__init__.cpython-311.pyc
 M src/player/__pycache__/player.cpython-311.pyc
 M src/player/developer-guide.md
 M src/player/player.py
 M src/weapons/__init__.py
 M src/weapons/__pycache__/__init__.cpython-311.pyc
 M src/weapons/__pycache__/weapon.cpython-311.pyc
 M src/weapons/developer-guide.md
 M src/weapons/weapon.py
 M tasks.md
 M tests/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..981d1266aedb312c64fcf41ac04e84440e1d4fc8
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,18 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented first-person camera state in `src/core/camera.py` with yaw/pitch mouse-look updates and pitch clamping.
+- Implemented collision primitives and movement controller in `src/core/collision.py` and `src/core/movement.py` for player movement with wall/bounds collision and slide resolution.
+- Added new weapon implementations:
+  - `src/weapons/shotgun.py` (pellet spread payload)
+  - `src/weapons/assault_rifle.py` (rapid fire)
+  - `src/weapons/rpg.py` (crash trigger flag when fired)
+- Extended `src/weapons/weapon.py` with ammo reload mechanics, total ammo tracking, and projectile payload generation.
+- Extended `src/player/player.py` with weapon cycling, reload delegation, projectile firing API, game-over state on death, and respawn handling.
+- Added projectile package `src/projectiles/`:
+  - `projectile.py` for projectile entities and movement/lifetime
+  - `physics.py` for projectile movement and world collision deactivation
+- Updated package exports in `src/core/__init__.py`, `src/player/__init__.py`, and `src/weapons/__init__.py`.
+- Added `tests/test_advanced_combat_and_movement.py` covering camera look, movement collision, weapon switching/reload/respawn, new weapons, and projectile physics.
+- Verified full test suite passes: `19 passed`.
 
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/developer-guide.md b/src/projectiles/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..fe91f591e1ca6dc46aff79cf507428ddbdd11509
--- /dev/null
+++ b/src/projectiles/developer-guide.md
@@ -0,0 +1,14 @@
+# Projectiles Developer Guide
+
+## Purpose
+`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.
+
+## Files
+- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
+- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.
+
+## Runtime Flow
+1. A weapon returns payload dictionaries describing projectile spawn info.
+2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
+3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
+4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tasks.md b/tasks.md
index 770ff01b25baf8262f6012c025852e3bde9193f0..e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f
--- a/tasks.md
+++ b/tasks.md
@@ -12,10 +12,10 @@
 
 - [x] Implement main game loop with frame updates and delta time handling
 - [x] Create game state manager to handle different states (menu, playing, paused, crashed)
-- [ ] Implement camera system with first-person perspective and mouse look controls
+- [x] Implement camera system with first-person perspective and mouse look controls
 - [x] Create input handler for WASD movement and mouse controls
-- [ ] Implement player movement with collision detection
-- [ ] Create physics system for projectile movement and collision
+- [x] Implement player movement with collision detection
+- [x] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
 - [ ] Create game clock and time management system
 
@@ -25,21 +25,21 @@
 - [x] Implement player health system with damage and death handling
 - [x] Create player money/currency tracking system
 - [x] Implement player inventory system to track owned weapons
-- [ ] Create player weapon switching logic
+- [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
-- [ ] Add player respawn or game over logic on death
+- [x] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
 - [x] Create base Weapon class with common properties (damage, ammo, fire rate)
 - [x] Implement Pistol weapon with stats and firing behavior
-- [ ] Implement Shotgun weapon with spread pattern and high damage
-- [ ] Implement Assault Rifle weapon with rapid fire mechanics
-- [ ] Implement RPG weapon with special "crash" trigger behavior
+- [x] Implement Shotgun weapon with spread pattern and high damage
+- [x] Implement Assault Rifle weapon with rapid fire mechanics
+- [x] Implement RPG weapon with special "crash" trigger behavior
 - [ ] Create weapon switching system with smooth transitions
-- [ ] Implement ammo management and reload mechanics
-- [ ] Create projectile system for bullets and rockets
+- [x] Implement ammo management and reload mechanics
+- [x] Create projectile system for bullets and rockets
 - [ ] Add weapon visual representations using geometric primitives
 - [ ] Create src/weapons folder developer-guide.md
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 6c1bc5780d8c0fd4ec59223480d74aaab239f16d..540f1701a37b66aec941fba6e4268e37f7d7af47
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -16,6 +16,7 @@
 - `test_config.py`: validates immutable config defaults.
 - `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
+- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False


thinking
**Preparing final summary response**
codex
Implemented 10 incomplete tasks and updated tracking/docs as requested.

Completed and marked in `tasks.md`:
1. `Implement camera system with first-person perspective and mouse look controls`
2. `Implement player movement with collision detection`
3. `Create physics system for projectile movement and collision`
4. `Create player weapon switching logic`
5. `Add player respawn or game over logic on death`
6. `Implement Shotgun weapon with spread pattern and high damage`
7. `Implement Assault Rifle weapon with rapid fire mechanics`
8. `Implement RPG weapon with special "crash" trigger behavior`
9. `Implement ammo management and reload mechanics`
10. `Create projectile system for bullets and rockets`

Key code changes:
- Added `src/core/camera.py`, `src/core/collision.py`, `src/core/movement.py`
- Added `src/weapons/shotgun.py`, `src/weapons/assault_rifle.py`, `src/weapons/rpg.py`
- Added `src/projectiles/projectile.py`, `src/projectiles/physics.py`, `src/projectiles/developer-guide.md`
- Extended `src/weapons/weapon.py` with reload/ammo/projectile payload logic
- Extended `src/player/player.py` with weapon cycling, reload delegation, projectile firing, game-over, respawn
- Updated exports in `src/core/__init__.py`, `src/player/__init__.py`, `src/weapons/__init__.py`

Documentation updates:
- Updated `recent-changes.md` with a full summary of this implementation
- Updated developer guides:
  - `developer-guide.md`
  - `src/developer-guide.md`
  - `src/core/developer-guide.md`
  - `src/player/developer-guide.md`
  - `src/weapons/developer-guide.md`
  - `tests/developer-guide.md`

Validation:
- Ran test suite successfully: `19 passed` (`pytest -q`)

No additional new tasks were discovered that needed to be added to `tasks.md`.
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 0f16dc933f598391f7c8702b74f017b0f1f22da3..eb9009057b8c8475899900f6470b552c82ed8836
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,14 +7,17 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Input normalization for WASD + mouse look
-- Player model with health, money, inventory, and shooting
-- Weapon base behavior and starter pistol
+- First-person camera and movement/collision simulation
+- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input handler.
-  - `src/player/`: player model and starter loadout behavior.
-  - `src/weapons/`: base weapon logic and concrete weapons.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
+  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
+  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -33,9 +36,12 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
-- `Player` enforces bounded health, validated currency operations, inventory ownership checks, and alive-only firing.
-- `Weapon.fire(now)` enforces cooldown + ammo consumption.
-- `Pistol` is the starter weapon with tuned prototype stats.
+- `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
+- `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
+- `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..981d1266aedb312c64fcf41ac04e84440e1d4fc8
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,18 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented first-person camera state in `src/core/camera.py` with yaw/pitch mouse-look updates and pitch clamping.
+- Implemented collision primitives and movement controller in `src/core/collision.py` and `src/core/movement.py` for player movement with wall/bounds collision and slide resolution.
+- Added new weapon implementations:
+  - `src/weapons/shotgun.py` (pellet spread payload)
+  - `src/weapons/assault_rifle.py` (rapid fire)
+  - `src/weapons/rpg.py` (crash trigger flag when fired)
+- Extended `src/weapons/weapon.py` with ammo reload mechanics, total ammo tracking, and projectile payload generation.
+- Extended `src/player/player.py` with weapon cycling, reload delegation, projectile firing API, game-over state on death, and respawn handling.
+- Added projectile package `src/projectiles/`:
+  - `projectile.py` for projectile entities and movement/lifetime
+  - `physics.py` for projectile movement and world collision deactivation
+- Updated package exports in `src/core/__init__.py`, `src/player/__init__.py`, and `src/weapons/__init__.py`.
+- Added `tests/test_advanced_combat_and_movement.py` covering camera look, movement collision, weapon switching/reload/respawn, new weapons, and projectile physics.
+- Verified full test suite passes: `19 passed`.
 
diff --git a/src/core/__init__.py b/src/core/__init__.py
index e093d60c96feba5ee6590c987b33d09c43dbdc2a..b79dce6a3693ac2041df3a21f591ddf4717b1246
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -1,2 +1,23 @@
 """Core runtime systems for FPS Bot Arena."""
 
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.game_clock import GameClock
+from src.core.game_loop import GameLoop
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+
+__all__ = [
+    "AABB",
+    "CollisionWorld",
+    "FirstPersonCamera",
+    "GameClock",
+    "GameLoop",
+    "GameState",
+    "GameStateManager",
+    "InputFrame",
+    "InputHandler",
+    "InputSnapshot",
+    "PlayerMovementController",
+]
diff --git a/src/core/camera.py b/src/core/camera.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ef53f0ea40ff608a246227a30a1545e082ed672
--- /dev/null
+++ b/src/core/camera.py
@@ -0,0 +1,22 @@
+"""First-person camera state and mouse-look handling."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class FirstPersonCamera:
+    """Tracks first-person yaw/pitch with clamped vertical look."""
+
+    yaw: float = 0.0
+    pitch: float = 0.0
+    min_pitch: float = -89.0
+    max_pitch: float = 89.0
+    eye_height: float = 1.8
+
+    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
+        self.yaw += look_yaw
+        self.pitch += look_pitch
+        self.pitch = max(self.min_pitch, min(self.max_pitch, self.pitch))
+        return self.yaw, self.pitch
diff --git a/src/core/collision.py b/src/core/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cb70f81f7696671826da29d4b1784ffeb34b6c0
--- /dev/null
+++ b/src/core/collision.py
@@ -0,0 +1,40 @@
+"""AABB collision primitives used by movement and projectiles."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class AABB:
+    """Axis-aligned bounding box."""
+
+    min_corner: Vector3
+    max_corner: Vector3
+
+    def intersects(self, other: "AABB") -> bool:
+        return (
+            self.min_corner[0] <= other.max_corner[0]
+            and self.max_corner[0] >= other.min_corner[0]
+            and self.min_corner[1] <= other.max_corner[1]
+            and self.max_corner[1] >= other.min_corner[1]
+            and self.min_corner[2] <= other.max_corner[2]
+            and self.max_corner[2] >= other.min_corner[2]
+        )
+
+
+@dataclass
+class CollisionWorld:
+    """Container for static world collision volumes."""
+
+    world_bounds: AABB
+    static_walls: list[AABB]
+
+    def collides_with_wall(self, box: AABB) -> bool:
+        return any(wall.intersects(box) for wall in self.static_walls)
+
+    def outside_world_bounds(self, box: AABB) -> bool:
+        return not self.world_bounds.intersects(box)
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index f6e869a5a82143b36629f4ae35d5b2365bb2f410..e8632b1ea0480b34f38c34ddd14cea408a2e6b8b
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -8,9 +8,14 @@
 - `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
+- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
+- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
+- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
-
+- Camera pitch is clamped to avoid flipping.
+- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
+- Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/movement.py b/src/core/movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa61c70dc674b27983323d320992b9320189e0d8
--- /dev/null
+++ b/src/core/movement.py
@@ -0,0 +1,82 @@
+"""Player movement with collision detection against world geometry."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+
+
+@dataclass
+class PlayerMovementController:
+    """Moves a player in local-space input while resolving collisions."""
+
+    walk_speed: float
+    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)
+
+    def move(
+        self,
+        *,
+        player_position: tuple[float, float, float],
+        player_yaw_degrees: float,
+        move_x: float,
+        move_z: float,
+        delta_time: float,
+        collision_world: CollisionWorld,
+    ) -> tuple[float, float, float]:
+        if delta_time <= 0.0:
+            return player_position
+
+        yaw_rad = math.radians(player_yaw_degrees)
+        forward = (math.sin(yaw_rad), 0.0, math.cos(yaw_rad))
+        right = (math.cos(yaw_rad), 0.0, -math.sin(yaw_rad))
+        move_dir = (
+            (right[0] * move_x) + (forward[0] * move_z),
+            0.0,
+            (right[2] * move_x) + (forward[2] * move_z),
+        )
+        length = math.sqrt((move_dir[0] * move_dir[0]) + (move_dir[2] * move_dir[2]))
+        if length > 0:
+            move_dir = (move_dir[0] / length, 0.0, move_dir[2] / length)
+
+        displacement = (
+            move_dir[0] * self.walk_speed * delta_time,
+            0.0,
+            move_dir[2] * self.walk_speed * delta_time,
+        )
+        proposed = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+
+        if self._is_valid_position(proposed, collision_world):
+            return proposed
+
+        slide_x = (
+            player_position[0] + displacement[0],
+            player_position[1],
+            player_position[2],
+        )
+        if self._is_valid_position(slide_x, collision_world):
+            return slide_x
+
+        slide_z = (
+            player_position[0],
+            player_position[1],
+            player_position[2] + displacement[2],
+        )
+        if self._is_valid_position(slide_z, collision_world):
+            return slide_z
+        return player_position
+
+    def _is_valid_position(self, position: tuple[float, float, float], world: CollisionWorld) -> bool:
+        half_x, half_y, half_z = self.collider_half_size
+        box = AABB(
+            min_corner=(position[0] - half_x, position[1] - half_y, position[2] - half_z),
+            max_corner=(position[0] + half_x, position[1] + half_y, position[2] + half_z),
+        )
+        if world.outside_world_bounds(box):
+            return False
+        return not world.collides_with_wall(box)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 155dc7900c09d713c7cee789cb9e90e81e42d0e2..e8a3abf429fd50ca29f10e5af2043969a049a56f
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -1,16 +1,18 @@
 # Src Developer Guide
 
 ## Purpose
-`src/` contains the game runtime modules for loop/state management, player logic, and weapons.
+`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, and input normalization.
-- `player/`: player runtime model (health, money, inventory, equipped weapon, shooting).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations.
+- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
+- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
-2. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-3. When in `playing` state, registered update callbacks apply gameplay changes each frame.
-4. Player actions call into weapon models for ammo/cooldown-validated firing.
-
+2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
+3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
+4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
+5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
diff --git a/src/player/__init__.py b/src/player/__init__.py
index 52297c3cbf67d9df6b43a8e6124d52f754770f5e..13154806c0c22ac2c83faffc6315f32edaf29b25
--- a/src/player/__init__.py
+++ b/src/player/__init__.py
@@ -1,2 +1,5 @@
 """Player state and gameplay behavior."""
 
+from src.player.player import Player
+
+__all__ = ["Player"]
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 28ff6dc0a43c783275e8bef0d2dbfc46d15879b8..2e946f7452244bee07e7bfe7e19216c245d67e75
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -18,6 +18,12 @@
 - Inventory logic:
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
+  - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
-
+  - `reload_weapon()` delegates magazine refill from reserve ammo.
+  - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+- Death/respawn logic:
+  - Health reaching `0` marks `is_game_over=True`.
+  - `shoot` is blocked while game over.
+  - `respawn(spawn_position)` resets health and clears game-over state.
diff --git a/src/player/player.py b/src/player/player.py
index 085c5b0a15479c47f2353819520dbae15d66f425..04eedcc91b9cc3d0bb574c54aa03f61148ebeb35
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,6 +4,7 @@
 
 from dataclasses import dataclass, field
 
+from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
@@ -19,6 +20,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    is_game_over: bool = False
 
     @classmethod
     def with_starter_loadout(cls, start_health: int, start_money: int) -> "Player":
@@ -58,6 +60,8 @@
         if damage < 0:
             raise ValueError("Damage must be non-negative.")
         self.health = max(0, self.health - damage)
+        if self.health == 0:
+            self.is_game_over = True
 
     def heal(self, amount: int) -> None:
         """Restore health without exceeding max health."""
@@ -88,9 +92,47 @@
             raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
         self.equipped_weapon_name = weapon_name
 
+    def cycle_weapon(self, direction: int = 1) -> str:
+        """Cycle through inventory weapons and return the newly equipped name."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return self.equipped_weapon_name
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        self.equipped_weapon_name = weapon_names[next_index]
+        return self.equipped_weapon_name
+
+    def reload_weapon(self) -> int:
+        return self.equipped_weapon.reload()
+
     def shoot(self, now: float) -> bool:
         """Attempt to fire the equipped weapon. Returns True when a shot is fired."""
-        if not self.is_alive:
+        if not self.is_alive or self.is_game_over:
             return False
         return self.equipped_weapon.fire(now)
 
+    def shoot_projectiles(
+        self,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[Projectile]:
+        """Fire the equipped weapon and return instantiated projectile entities."""
+        if not self.shoot(now):
+            return []
+        payload = self.equipped_weapon.create_projectile_payload(
+            origin=origin,
+            direction=direction,
+        )
+        return [Projectile.from_payload(item) for item in payload]
+
+    def respawn(self, spawn_position: tuple[float, float, float]) -> None:
+        """Reset player death/game-over state and place at spawn."""
+        self.health = self.max_health
+        self.position = spawn_position
+        self.is_game_over = False
diff --git a/src/projectiles/__init__.py b/src/projectiles/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..930d075d56e8d1652f307ac2b20735d9b83ee0ea
--- /dev/null
+++ b/src/projectiles/__init__.py
@@ -0,0 +1 @@
+"""Projectile entities and physics simulation."""
diff --git a/src/projectiles/developer-guide.md b/src/projectiles/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..fe91f591e1ca6dc46aff79cf507428ddbdd11509
--- /dev/null
+++ b/src/projectiles/developer-guide.md
@@ -0,0 +1,14 @@
+# Projectiles Developer Guide
+
+## Purpose
+`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.
+
+## Files
+- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
+- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.
+
+## Runtime Flow
+1. A weapon returns payload dictionaries describing projectile spawn info.
+2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
+3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
+4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
diff --git a/src/projectiles/physics.py b/src/projectiles/physics.py
new file mode 100644
index 0000000000000000000000000000000000000000..aab284d7c6d7e3ad791035b2f6a2a31ba0a90b09
--- /dev/null
+++ b/src/projectiles/physics.py
@@ -0,0 +1,38 @@
+"""Projectile simulation with world collision detection."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+from src.core.collision import AABB, CollisionWorld
+from src.projectiles.projectile import Projectile
+
+
+@dataclass
+class ProjectilePhysicsSystem:
+    """Advances projectiles and deactivates on world collision."""
+
+    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
+        collision_count = 0
+        for projectile in projectiles:
+            if not projectile.is_active:
+                continue
+            projectile.advance(delta_time)
+            if not projectile.is_active:
+                continue
+            projectile_box = AABB(
+                min_corner=(
+                    projectile.position[0] - projectile.radius,
+                    projectile.position[1] - projectile.radius,
+                    projectile.position[2] - projectile.radius,
+                ),
+                max_corner=(
+                    projectile.position[0] + projectile.radius,
+                    projectile.position[1] + projectile.radius,
+                    projectile.position[2] + projectile.radius,
+                ),
+            )
+            if world.outside_world_bounds(projectile_box) or world.collides_with_wall(projectile_box):
+                projectile.is_active = False
+                collision_count += 1
+        return collision_count
diff --git a/src/projectiles/projectile.py b/src/projectiles/projectile.py
new file mode 100644
index 0000000000000000000000000000000000000000..e388e2c8fb9bf087b30e25c5d08be88d8e9f14b5
--- /dev/null
+++ b/src/projectiles/projectile.py
@@ -0,0 +1,77 @@
+"""Projectile entities for bullets, pellets, and rockets."""
+
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = math.sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Projectile direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Projectile:
+    """Simple projectile with position, velocity, and collision radius."""
+
+    kind: str
+    position: Vector3
+    velocity: Vector3
+    radius: float
+    damage: float
+    max_distance: float
+    distance_traveled: float = 0.0
+    is_active: bool = True
+
+    @classmethod
+    def from_payload(cls, payload: dict) -> "Projectile":
+        direction = _normalize(payload["direction"])
+        speed = payload["speed"]
+        velocity = (
+            direction[0] * speed,
+            direction[1] * speed,
+            direction[2] * speed,
+        )
+        return cls(
+            kind=payload["kind"],
+            position=payload["origin"],
+            velocity=velocity,
+            radius=payload["radius"],
+            damage=payload["damage"],
+            max_distance=payload.get("max_distance", 150.0),
+        )
+
+    def advance(self, delta_time: float) -> None:
+        if not self.is_active or delta_time <= 0.0:
+            return
+        displacement = (
+            self.velocity[0] * delta_time,
+            self.velocity[1] * delta_time,
+            self.velocity[2] * delta_time,
+        )
+        self.position = (
+            self.position[0] + displacement[0],
+            self.position[1] + displacement[1],
+            self.position[2] + displacement[2],
+        )
+        self.distance_traveled += math.sqrt(
+            (displacement[0] * displacement[0])
+            + (displacement[1] * displacement[1])
+            + (displacement[2] * displacement[2])
+        )
+        if self.distance_traveled >= self.max_distance:
+            self.is_active = False
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d07cd437d3c7239fbd56e48167982dbcf46a28b6..d6f6ab326e591915f25bc22f1f3bf6ce3297d433
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -1,2 +1,9 @@
 """Weapon definitions and shared weapon behavior."""
 
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.pistol import Pistol
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
diff --git a/src/weapons/assault_rifle.py b/src/weapons/assault_rifle.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff8ea20af2d4d1561aa60d4f2205259267f399bc
--- /dev/null
+++ b/src/weapons/assault_rifle.py
@@ -0,0 +1,21 @@
+"""Assault rifle weapon implementation."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class AssaultRifle(Weapon):
+    """Rapid-fire automatic weapon for mid-range combat."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="AssaultRifle",
+            damage=16.0,
+            fire_rate=9.0,
+            magazine_size=30,
+            reserve_ammo=120,
+            projectile_speed=95.0,
+            projectile_radius=0.07,
+            projectile_kind="bullet",
+        )
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index f017ee8cd0dc4356b2cbe59dffe73feb87f6b86a..2acc4800b055b1fd5ca5a4497bee97330482cc53
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -6,15 +6,19 @@
 ## Files
 - `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
 - `pistol.py`: starter `Pistol` implementation with tuned default stats.
+- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
+- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
+- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
   - ammo remains in the magazine, and
   - cooldown time since last shot has elapsed.
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
+- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
+- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
   - magazine size `12`
   - reserve ammo `48`
-
diff --git a/src/weapons/rpg.py b/src/weapons/rpg.py
new file mode 100644
index 0000000000000000000000000000000000000000..41387119273b10ce431892fb397e9ff317e4eb15
--- /dev/null
+++ b/src/weapons/rpg.py
@@ -0,0 +1,28 @@
+"""RPG weapon implementation with special crash trigger behavior."""
+
+from __future__ import annotations
+
+from src.weapons.weapon import Weapon
+
+
+class RPG(Weapon):
+    """Endgame launcher that triggers the glitch sequence on fire."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="RPG",
+            damage=200.0,
+            fire_rate=0.5,
+            magazine_size=1,
+            reserve_ammo=3,
+            projectile_speed=45.0,
+            projectile_radius=0.3,
+            projectile_kind="rocket",
+        )
+        self.crash_triggered = False
+
+    def fire(self, now: float) -> bool:
+        fired = super().fire(now)
+        if fired:
+            self.crash_triggered = True
+        return fired
diff --git a/src/weapons/shotgun.py b/src/weapons/shotgun.py
new file mode 100644
index 0000000000000000000000000000000000000000..73f92ed067715f58f37d7ff658905cffaaee1cb1
--- /dev/null
+++ b/src/weapons/shotgun.py
@@ -0,0 +1,48 @@
+"""Shotgun weapon implementation."""
+
+from __future__ import annotations
+
+import math
+
+from src.weapons.weapon import Weapon
+
+
+class Shotgun(Weapon):
+    """High-damage close-range weapon with pellet spread."""
+
+    def __init__(self) -> None:
+        super().__init__(
+            name="Shotgun",
+            damage=12.0,
+            fire_rate=1.0,
+            magazine_size=8,
+            reserve_ammo=32,
+            projectile_speed=70.0,
+            projectile_radius=0.1,
+            projectile_kind="pellet",
+        )
+        self.pellet_count = 8
+        self.spread_degrees = 6.0
+
+    def create_projectile_payload(
+        self,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+    ) -> list[dict]:
+        base = super().create_projectile_payload(origin=origin, direction=direction)[0]
+        spread_rad = math.radians(self.spread_degrees)
+        payload: list[dict] = []
+        for index in range(self.pellet_count):
+            # Deterministic circular distribution keeps tests stable.
+            ratio = 0.0 if self.pellet_count == 1 else (index / (self.pellet_count - 1)) - 0.5
+            yaw_offset = ratio * spread_rad
+            direction_x = base["direction"][0] + yaw_offset
+            direction_y = base["direction"][1]
+            direction_z = base["direction"][2] - abs(yaw_offset) * 0.15
+            payload.append(
+                {
+                    **base,
+                    "direction": (direction_x, direction_y, direction_z),
+                }
+            )
+        return payload
diff --git a/src/weapons/weapon.py b/src/weapons/weapon.py
index b25dd6e3cb62f85171c2587edb745143eae24d76..0cb1c5368f8a83f58bf9d44c8895b11d9ff9562c
--- a/src/weapons/weapon.py
+++ b/src/weapons/weapon.py
@@ -3,8 +3,27 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
 
 
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
 @dataclass
 class Weapon:
     """Shared weapon attributes and firing cooldown logic."""
@@ -14,6 +33,9 @@
     fire_rate: float
     magazine_size: int
     reserve_ammo: int
+    projectile_speed: float = 80.0
+    projectile_radius: float = 0.08
+    projectile_kind: str = "bullet"
     ammo_in_magazine: int | None = None
     _last_fired_at: float = -1_000_000.0
 
@@ -22,11 +44,23 @@
             self.ammo_in_magazine = self.magazine_size
         if self.fire_rate <= 0:
             raise ValueError(f"fire_rate must be positive, got {self.fire_rate}")
+        if self.projectile_speed <= 0:
+            raise ValueError(f"projectile_speed must be positive, got {self.projectile_speed}")
 
     @property
     def cooldown_seconds(self) -> float:
         return 1.0 / self.fire_rate
 
+    @property
+    def total_remaining_ammo(self) -> int:
+        return self.reserve_ammo + self.ammo_in_magazine
+
+    def is_magazine_full(self) -> bool:
+        return self.ammo_in_magazine >= self.magazine_size
+
+    def can_reload(self) -> bool:
+        return (not self.is_magazine_full()) and self.reserve_ammo > 0
+
     def can_fire(self, now: float) -> bool:
         """Return True when weapon has ammo and cooldown is ready."""
         has_ammo = self.ammo_in_magazine > 0
@@ -41,3 +75,26 @@
         self._last_fired_at = now
         return True
 
+    def reload(self) -> int:
+        """Move reserve ammo into magazine and return rounds loaded."""
+        if not self.can_reload():
+            return 0
+        missing_rounds = self.magazine_size - self.ammo_in_magazine
+        rounds_loaded = min(missing_rounds, self.reserve_ammo)
+        self.ammo_in_magazine += rounds_loaded
+        self.reserve_ammo -= rounds_loaded
+        return rounds_loaded
+
+    def create_projectile_payload(self, origin: Vector3, direction: Vector3) -> list[dict]:
+        """Return projectile payload for a successful shot."""
+        normalized = _normalize(direction)
+        return [
+            {
+                "kind": self.projectile_kind,
+                "origin": origin,
+                "direction": normalized,
+                "speed": self.projectile_speed,
+                "radius": self.projectile_radius,
+                "damage": self.damage,
+            }
+        ]
diff --git a/tasks.md b/tasks.md
index 770ff01b25baf8262f6012c025852e3bde9193f0..e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f
--- a/tasks.md
+++ b/tasks.md
@@ -12,10 +12,10 @@
 
 - [x] Implement main game loop with frame updates and delta time handling
 - [x] Create game state manager to handle different states (menu, playing, paused, crashed)
-- [ ] Implement camera system with first-person perspective and mouse look controls
+- [x] Implement camera system with first-person perspective and mouse look controls
 - [x] Create input handler for WASD movement and mouse controls
-- [ ] Implement player movement with collision detection
-- [ ] Create physics system for projectile movement and collision
+- [x] Implement player movement with collision detection
+- [x] Create physics system for projectile movement and collision
 - [ ] Implement raycasting system for shooting mechanics
 - [ ] Create game clock and time management system
 
@@ -25,21 +25,21 @@
 - [x] Implement player health system with damage and death handling
 - [x] Create player money/currency tracking system
 - [x] Implement player inventory system to track owned weapons
-- [ ] Create player weapon switching logic
+- [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
-- [ ] Add player respawn or game over logic on death
+- [x] Add player respawn or game over logic on death
 - [ ] Create src/player folder developer-guide.md
 
 ## Weapon System
 
 - [x] Create base Weapon class with common properties (damage, ammo, fire rate)
 - [x] Implement Pistol weapon with stats and firing behavior
-- [ ] Implement Shotgun weapon with spread pattern and high damage
-- [ ] Implement Assault Rifle weapon with rapid fire mechanics
-- [ ] Implement RPG weapon with special "crash" trigger behavior
+- [x] Implement Shotgun weapon with spread pattern and high damage
+- [x] Implement Assault Rifle weapon with rapid fire mechanics
+- [x] Implement RPG weapon with special "crash" trigger behavior
 - [ ] Create weapon switching system with smooth transitions
-- [ ] Implement ammo management and reload mechanics
-- [ ] Create projectile system for bullets and rockets
+- [x] Implement ammo management and reload mechanics
+- [x] Create projectile system for bullets and rockets
 - [ ] Add weapon visual representations using geometric primitives
 - [ ] Create src/weapons folder developer-guide.md
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 6c1bc5780d8c0fd4ec59223480d74aaab239f16d..540f1701a37b66aec941fba6e4268e37f7d7af47
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -16,6 +16,7 @@
 - `test_config.py`: validates immutable config defaults.
 - `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
+- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
new file mode 100644
index 0000000000000000000000000000000000000000..326ff73a4ad035ef91e3dc1938d6d9010dfc04a2
--- /dev/null
+++ b/tests/test_advanced_combat_and_movement.py
@@ -0,0 +1,100 @@
+from src.core.camera import FirstPersonCamera
+from src.core.collision import AABB, CollisionWorld
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.core.movement import PlayerMovementController
+from src.player.player import Player
+from src.projectiles.physics import ProjectilePhysicsSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+
+
+def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    camera = FirstPersonCamera()
+    frame = handler.build_frame(
+        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
+    )
+    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
+    assert yaw == 12.0
+    assert pitch == 89.0
+
+
+def test_player_movement_resolves_wall_collision_with_slide():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-5.0, 0.0, -5.0), max_corner=(5.0, 3.0, 5.0)),
+        static_walls=[AABB(min_corner=(0.8, 0.0, 1.0), max_corner=(1.8, 3.0, 2.5))],
+    )
+    movement = PlayerMovementController(walk_speed=4.0)
+    next_pos = movement.move(
+        player_position=(0.0, 1.8, 0.3),
+        player_yaw_degrees=0.0,
+        move_x=1.0,
+        move_z=1.0,
+        delta_time=0.5,
+        collision_world=world,
+    )
+    assert next_pos[0] > 0.0
+    assert next_pos[2] == 0.3
+
+
+def test_player_weapon_switch_reload_and_game_over_respawn():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    player.add_weapon(AssaultRifle())
+    assert player.cycle_weapon(1) == "Shotgun"
+    assert player.cycle_weapon(1) == "AssaultRifle"
+    assert player.cycle_weapon(-1) == "Shotgun"
+
+    player.equipped_weapon.ammo_in_magazine = 2
+    player.equipped_weapon.reserve_ammo = 10
+    loaded = player.reload_weapon()
+    assert loaded == 6
+    assert player.equipped_weapon.ammo_in_magazine == 8
+    assert player.equipped_weapon.reserve_ammo == 4
+
+    player.apply_damage(999)
+    assert player.is_game_over is True
+    assert player.shoot(10.0) is False
+    player.respawn((1.0, 1.8, 2.0))
+    assert player.is_game_over is False
+    assert player.health == 100
+    assert player.position == (1.0, 1.8, 2.0)
+
+
+def test_shotgun_assault_rifle_and_rpg_behaviors():
+    shotgun = Shotgun()
+    payload = shotgun.create_projectile_payload(
+        origin=(0.0, 0.0, 0.0),
+        direction=(0.0, 0.0, 1.0),
+    )
+    assert len(payload) == shotgun.pellet_count
+    assert payload[0]["kind"] == "pellet"
+
+    rifle = AssaultRifle()
+    assert rifle.fire(1.0) is True
+    assert rifle.fire(1.05) is False
+    assert rifle.fire(1.12) is True
+
+    rpg = RPG()
+    assert rpg.crash_triggered is False
+    assert rpg.fire(2.0) is True
+    assert rpg.crash_triggered is True
+
+
+def test_projectile_system_and_collision_physics():
+    world = CollisionWorld(
+        world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
+        static_walls=[AABB(min_corner=(0.9, -1.0, -1.0), max_corner=(1.1, 1.0, 1.0))],
+    )
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    projectiles = player.shoot_projectiles(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+    )
+    assert len(projectiles) == 1
+    physics = ProjectilePhysicsSystem()
+    collisions = physics.step(projectiles, delta_time=0.05, world=world)
+    assert collisions == 1
+    assert projectiles[0].is_active is False

tokens used
75,166
Implemented 10 incomplete tasks and updated tracking/docs as requested.

Completed and marked in `tasks.md`:
1. `Implement camera system with first-person perspective and mouse look controls`
2. `Implement player movement with collision detection`
3. `Create physics system for projectile movement and collision`
4. `Create player weapon switching logic`
5. `Add player respawn or game over logic on death`
6. `Implement Shotgun weapon with spread pattern and high damage`
7. `Implement Assault Rifle weapon with rapid fire mechanics`
8. `Implement RPG weapon with special "crash" trigger behavior`
9. `Implement ammo management and reload mechanics`
10. `Create projectile system for bullets and rockets`

Key code changes:
- Added `src/core/camera.py`, `src/core/collision.py`, `src/core/movement.py`
- Added `src/weapons/shotgun.py`, `src/weapons/assault_rifle.py`, `src/weapons/rpg.py`
- Added `src/projectiles/projectile.py`, `src/projectiles/physics.py`, `src/projectiles/developer-guide.md`
- Extended `src/weapons/weapon.py` with reload/ammo/projectile payload logic
- Extended `src/player/player.py` with weapon cycling, reload delegation, projectile firing, game-over, respawn
- Updated exports in `src/core/__init__.py`, `src/player/__init__.py`, `src/weapons/__init__.py`

Documentation updates:
- Updated `recent-changes.md` with a full summary of this implementation
- Updated developer guides:
  - `developer-guide.md`
  - `src/developer-guide.md`
  - `src/core/developer-guide.md`
  - `src/player/developer-guide.md`
  - `src/weapons/developer-guide.md`
  - `tests/developer-guide.md`

Validation:
- Ran test suite successfully: `19 passed` (`pytest -q`)

No additional new tasks were discovered that needed to be added to `tasks.md`.
Implemented 10 incomplete tasks and updated tracking/docs as requested.

Completed and marked in `tasks.md`:
1. `Implement camera system with first-person perspective and mouse look controls`
2. `Implement player movement with collision detection`
3. `Create physics system for projectile movement and collision`
4. `Create player weapon switching logic`
5. `Add player respawn or game over logic on death`
6. `Implement Shotgun weapon with spread pattern and high damage`
7. `Implement Assault Rifle weapon with rapid fire mechanics`
8. `Implement RPG weapon with special "crash" trigger behavior`
9. `Implement ammo management and reload mechanics`
10. `Create projectile system for bullets and rockets`

Key code changes:
- Added `src/core/camera.py`, `src/core/collision.py`, `src/core/movement.py`
- Added `src/weapons/shotgun.py`, `src/weapons/assault_rifle.py`, `src/weapons/rpg.py`
- Added `src/projectiles/projectile.py`, `src/projectiles/physics.py`, `src/projectiles/developer-guide.md`
- Extended `src/weapons/weapon.py` with reload/ammo/projectile payload logic
- Extended `src/player/player.py` with weapon cycling, reload delegation, projectile firing, game-over, respawn
- Updated exports in `src/core/__init__.py`, `src/player/__init__.py`, `src/weapons/__init__.py`

Documentation updates:
- Updated `recent-changes.md` with a full summary of this implementation
- Updated developer guides:
  - `developer-guide.md`
  - `src/developer-guide.md`
  - `src/core/developer-guide.md`
  - `src/player/developer-guide.md`
  - `src/weapons/developer-guide.md`
  - `tests/developer-guide.md`

Validation:
- Ran test suite successfully: `19 passed` (`pytest -q`)

No additional new tasks were discovered that needed to be added to `tasks.md`.
Process exited with code 0. Output length: 1393755 chars.
End: 2026-02-08T18:16:04
__AGENTHARNESS_LIVE_DONE__
