AgentHarness LLM Live Output
Start: 2026-02-08T18:19:38
CWD: C:/Users/shlob/Pycharm Projects/harness-test/harness-test-4
Command: codex exec --skip-git-repo-check --full-auto --output-last-message "C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.codex_last_message.txt" --model gpt-5.3-codex -

Provider: Codex, Model: gpt-5.3-codex | Timeout: 600s
Prompt transport: stdin (678 chars)
LLM prompt begin (stdin)

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md
LLM prompt end (stdin)
Process PID: 18136
OpenAI Codex v0.98.0 (research preview)
--------
workdir: C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019c3e0d-3343-7870-b692-6a2a396bf391
--------
user

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md

deprecated: `enable_experimental_windows_sandbox` is deprecated. Use `[features].experimental_windows_sandbox` instead.
  Enable it with `--enable experimental_windows_sandbox` or `[features].experimental_windows_sandbox` in config.toml. See https://github.com/openai/codex/blob/main/docs/config.md#feature-flags for details.
mcp startup: no servers

thinking
**Starting product description review**
codex
I’m going to first read `product-description.md`, then review `recent-changes.md` and `tasks.md` to pick up to 10 unchecked tasks and implement them end-to-end. After code changes, I’ll update the relevant `developer-guide.md` files, `tasks.md`, and `recent-changes.md`.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path tasks.md) { Get-Content tasks.md } else { Write-Output 'MISSING: tasks.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path recent-changes.md) { Get-Content recent-changes.md } else { Write-Output 'MISSING: recent-changes.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path product-description.md) { Get-Content product-description.md } else { Write-Output 'MISSING: product-description.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Force' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 213ms:
# FPS Bot Arena Implementation Tasks

## Project Setup & Architecture

- [x] Choose and document the technology stack (Python + Ursina or Web + Three.js)
- [x] Set up project structure with main folders (src, assets, config, tests)
- [x] Create root developer-guide.md documenting overall project architecture
- [x] Initialize package.json or requirements.txt with core dependencies
- [x] Set up basic project configuration files (config.py or config.js)

## Core Game Engine

- [x] Implement main game loop with frame updates and delta time handling
- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
- [x] Implement camera system with first-person perspective and mouse look controls
- [x] Create input handler for WASD movement and mouse controls
- [x] Implement player movement with collision detection
- [x] Create physics system for projectile movement and collision
- [ ] Implement raycasting system for shooting mechanics
- [ ] Create game clock and time management system
 succeeded in 213ms:
# Product Description: FPS Bot Arena with "The Glitch"

## Overview
A First-Person Shooter (FPS) game where the player fights against waves of tactical AI bots in a multi-room indoor facility. The core loop involves combat, earning money from kills, and upgrading weapons. The game features a meta-twist ending where the final weapon, an RPG, triggers a simulated game crash (Fake BSOD/Error) upon use.

## Gameplay Mechanics
*   **Perspective:** First-Person.
*   **Controls:** Standard FPS controls (WASD + Mouse).
*   **Interaction:** Pressing 'B' opens a real-time inventory/shop wheel to buy and switch weapons.
*   **Win/Loss:**
    *   **Loss:** Player health reaches zero.
    *   **"Win":** Acquiring and firing the final RPG, triggering the "crash" ending.

## Economy & Progression
*   **Income:** Bots drop money as physical items upon death, which the player must collect.
*   **Weapon Progression:**
    1.  **Pistol:** Starting weapon.
    2.  **Shotgun:** High close-range damage.
    3.  **Assault Rifle:** Rapid fire, medium range.
    4.  **RPG (Final Weapon):** Expensive endgame item. Firing it causes a fake "Blue Screen of Death" or critical error message, effectively ending the session.
 succeeded in 217ms:
# Recent Changes

 succeeded in 239ms:


    Directory: C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4


Mode                 LastWriteTime         Length Name                                                                                                                                                        
----                 -------------         ------ ----                                                                                                                                                        
d-----          2/8/2026   5:53 PM                .agentharness                                                                                                                                               
d--h--          2/8/2026   6:19 PM                .git                                                                                                                                                        
d-----          2/8/2026   5:56 PM                .pytest_cache                                                                                                                                               
d-----          2/8/2026   5:54 PM                assets                                                                                                                                                      
d-----          2/8/2026   5:56 PM                config                                                                                                                                                      
d-----          2/8/2026   6:18 PM                review                                                                                                                                                      
d-----          2/8/2026   6:12 PM                src                                                                                                                                                         
d-----          2/8/2026   6:13 PM                tests                                                                                                                                                       
-a----          2/8/2026   5:39 PM           1086 AGENTS.md                                                                                                                                                   
-a----          2/8/2026   5:39 PM           1086 CLAUDE.md                                                                                                                                                   
-a----          2/8/2026   6:14 PM           2888 developer-guide.md                                                                                                                                          
-a----          2/8/2026   5:39 PM           1086 GEMINI.md                                                                                                                                                   
-a----          2/8/2026   5:51 PM           2003 product-description.md                                                                                                                                      

thinking
**Planning task selection**
codex
I’ve loaded the task list and confirmed many unchecked items. Next I’m mapping current implementation in `src/` and existing folder guides so I can choose up to 10 tasks that can be fully completed and validated in this pass.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File | Select-Object -ExpandProperty FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 184ms:
# Developer Guide

## Project Architecture
This project uses **Python + Ursina** for a lightweight FPS prototype.

The current codebase implements engine-agnostic gameplay foundations in pure Python:
- Core runtime loop and timing
- State machine for high-level game flow
- Input normalization for WASD + mouse look
- First-person camera and movement/collision simulation
- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
- Weapon system with pistol, shotgun, assault rifle, and RPG
- Projectile entities and physics for bullets, pellets, and rockets

## Directory Map
- `src/`: runtime game systems.
  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
  - `src/weapons/`: weapon base model and concrete implementations.
  - `src/projectiles/`: projectile entity construction and world collision physics.
 succeeded in 278ms:
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\AGENTS.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\CLAUDE.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\GEMINI.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\product-description.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\questions.json
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\recent-changes.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\requirements.txt
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tasks.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.agentharness\git-commit-message.txt
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.agentharness\project-settings.json
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.agentharness\live-llm\llm_20260208_175333_acd02c09.log
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.agentharness\live-llm\llm_20260208_175451_253b905c.log
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.agentharness\live-llm\llm_20260208_175818_d4551b9f.log
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.agentharness\live-llm\llm_20260208_175854_d07e6ea1.log
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.agentharness\live-llm\llm_20260208_175912_29261c77.log
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.agentharness\live-llm\llm_20260208_175933_5049f763.log
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.agentharness\live-llm\llm_20260208_175957_361b638d.log
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.agentharness\live-llm\llm_20260208_180437_ac1c8cb8.log
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.agentharness\live-llm\llm_20260208_180623_f83a0722.log

thinking
**Assessing task feasibility and guides**
codex
I found that some unchecked tasks may already be partially implemented, so I’m now verifying actual code behavior per module before selecting the final task set to complete and mark done.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/projectiles/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/player/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 243ms:
# Src Developer Guide

## Purpose
`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.

## Folder Overview
- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
- `projectiles/`: projectile entities plus physics stepping and world collision checks.

## Integration Flow
1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 succeeded in 242ms:
# Core Developer Guide

## Purpose
`src/core/` provides engine-level systems that are independent from rendering backends.

## Files
- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.

## Behavior Notes
- `GameStateManager` blocks invalid transitions with `ValueError`.
- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
- Camera pitch is clamped to avoid flipping.
- Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 succeeded in 245ms:
# Projectiles Developer Guide

## Purpose
`src/projectiles/` models fired projectiles (bullets/pellets/rockets) and simulates their movement/collision.

## Files
- `projectile.py`: `Projectile` entity with movement, distance lifetime, and payload-based construction.
- `physics.py`: `ProjectilePhysicsSystem` frame-step logic that deactivates projectiles on wall or bounds collisions.

## Runtime Flow
1. A weapon returns payload dictionaries describing projectile spawn info.
2. `Projectile.from_payload(...)` converts payload into a normalized velocity-based entity.
3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
4. Projectiles are deactivated when exceeding max distance, hitting static walls, or leaving world bounds.
 succeeded in 246ms:
# Weapons Developer Guide

## Purpose
`src/weapons/` defines weapon behavior shared across loadout items.

## Files
- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
- `pistol.py`: starter `Pistol` implementation with tuned default stats.
- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.

## Key Behaviors
- `Weapon.fire(now)` returns `True` only when:
  - ammo remains in the magazine, and
  - cooldown time since last shot has elapsed.
- Successful fire events decrement `ammo_in_magazine` by exactly one.
- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
- `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
- `Pistol` defaults:
 succeeded in 246ms:
# Player Developer Guide

## Purpose
`src/player/` owns all player-centric gameplay state and actions.

## Files
- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.

## Key Behaviors
- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
- Health logic:
  - `apply_damage` clamps health at `0`.
  - `heal` clamps health at `max_health`.
  - `is_alive` becomes `False` at `0` health.
- Economy logic:
  - `add_money` and `spend_money` reject negative inputs.
  - `spend_money` returns `False` when balance is insufficient.
- Inventory logic:
  - Weapons are stored by name.
  - `equip_weapon` requires ownership.

thinking
**Preparing code inspection**
codex
I’m now reading the core/player/weapons code and tests to identify which unchecked tasks can be completed fully with passing coverage in one batch.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/game_loop.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/player/player.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/game_clock.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/camera.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/pistol.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/movement.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/shotgun.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/assault_rifle.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/weapon.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/collision.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/rpg.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 301ms:
"""Player model with health, currency, inventory, and shooting."""

from __future__ import annotations

from dataclasses import dataclass, field

from src.projectiles.projectile import Projectile
from src.weapons.pistol import Pistol
from src.weapons.weapon import Weapon


@dataclass
class Player:
    """Encapsulates runtime player state and core gameplay actions."""

    max_health: int
    health: int
    money: int
    position: tuple[float, float, float] = (0.0, 1.8, 0.0)
    rotation: tuple[float, float] = (0.0, 0.0)
 succeeded in 302ms:
"""Lightweight game clock and delta-time tracking."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class GameClock:
    """Tracks elapsed and per-frame timing."""

    elapsed_time: float = 0.0
    frame_count: int = 0
    _last_timestamp: float | None = None

    def tick(self, now: float) -> float:
        """Advance the clock and return frame delta-time in seconds."""
        if self._last_timestamp is None:
            self._last_timestamp = now
            return 0.0
 succeeded in 318ms:
"""Pistol weapon implementation."""

from __future__ import annotations

from src.weapons.weapon import Weapon


class Pistol(Weapon):
    """Default starter weapon with reliable semi-auto fire."""

    def __init__(self) -> None:
        super().__init__(
            name="Pistol",
            damage=20.0,
            fire_rate=3.0,
            magazine_size=12,
            reserve_ammo=48,
        )

 succeeded in 314ms:
"""Assault rifle weapon implementation."""

from __future__ import annotations

from src.weapons.weapon import Weapon


class AssaultRifle(Weapon):
    """Rapid-fire automatic weapon for mid-range combat."""

    def __init__(self) -> None:
        super().__init__(
            name="AssaultRifle",
            damage=16.0,
            fire_rate=9.0,
            magazine_size=30,
            reserve_ammo=120,
            projectile_speed=95.0,
            projectile_radius=0.07,
            projectile_kind="bullet",
 succeeded in 313ms:
"""Main game loop orchestration with delta-time updates."""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import Callable

from src.core.game_clock import GameClock
from src.core.game_state import GameState, GameStateManager

logger = logging.getLogger(__name__)


FrameCallback = Callable[[float], None]


@dataclass
class GameLoop:
    """Owns frame stepping and update dispatch for active gameplay."""
 succeeded in 316ms:
"""First-person camera state and mouse-look handling."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class FirstPersonCamera:
    """Tracks first-person yaw/pitch with clamped vertical look."""

    yaw: float = 0.0
    pitch: float = 0.0
    min_pitch: float = -89.0
    max_pitch: float = 89.0
    eye_height: float = 1.8

    def apply_look_delta(self, look_yaw: float, look_pitch: float) -> tuple[float, float]:
        self.yaw += look_yaw
        self.pitch += look_pitch
 succeeded in 312ms:
"""Base weapon model used by all weapon types."""

from __future__ import annotations

from dataclasses import dataclass
from math import sqrt


Vector3 = tuple[float, float, float]


def _normalize(direction: Vector3) -> Vector3:
    length = sqrt(
        (direction[0] * direction[0])
        + (direction[1] * direction[1])
        + (direction[2] * direction[2])
    )
    if length <= 0.0:
        raise ValueError("Direction vector must be non-zero.")
    return (
 succeeded in 311ms:
"""AABB collision primitives used by movement and projectiles."""

from __future__ import annotations

from dataclasses import dataclass


Vector3 = tuple[float, float, float]


@dataclass(frozen=True)
class AABB:
    """Axis-aligned bounding box."""

    min_corner: Vector3
    max_corner: Vector3

    def intersects(self, other: "AABB") -> bool:
        return (
            self.min_corner[0] <= other.max_corner[0]
 succeeded in 313ms:
"""Shotgun weapon implementation."""

from __future__ import annotations

import math

from src.weapons.weapon import Weapon


class Shotgun(Weapon):
    """High-damage close-range weapon with pellet spread."""

    def __init__(self) -> None:
        super().__init__(
            name="Shotgun",
            damage=12.0,
            fire_rate=1.0,
            magazine_size=8,
            reserve_ammo=32,
            projectile_speed=70.0,
 succeeded in 304ms:
"""RPG weapon implementation with special crash trigger behavior."""

from __future__ import annotations

from src.weapons.weapon import Weapon


class RPG(Weapon):
    """Endgame launcher that triggers the glitch sequence on fire."""

    def __init__(self) -> None:
        super().__init__(
            name="RPG",
            damage=200.0,
            fire_rate=0.5,
            magazine_size=1,
            reserve_ammo=3,
            projectile_speed=45.0,
            projectile_radius=0.3,
            projectile_kind="rocket",
 succeeded in 304ms:
"""Player movement with collision detection against world geometry."""

from __future__ import annotations

import math
from dataclasses import dataclass

from src.core.collision import AABB, CollisionWorld


@dataclass
class PlayerMovementController:
    """Moves a player in local-space input while resolving collisions."""

    walk_speed: float
    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)

    def move(
        self,
        *,

thinking
**Prioritizing task selection and test inspection**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tests/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tests/test_core_systems.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tests/test_player_and_weapons.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/__init__.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/player/__init__.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tests/test_advanced_combat_and_movement.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/projectiles/physics.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/__init__.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/projectiles/projectile.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 276ms:
import pytest

from src.core.game_clock import GameClock
from src.core.game_loop import GameLoop
from src.core.game_state import GameState, GameStateManager
from src.core.input_handler import InputHandler, InputSnapshot


def test_game_clock_tracks_delta_and_elapsed_time():
    clock = GameClock()

    assert clock.tick(10.0) == 0.0
    assert clock.elapsed_time == 0.0
    assert clock.frame_count == 0

    assert clock.tick(10.25) == 0.25
    assert clock.tick(10.75) == 0.5
    assert clock.elapsed_time == 0.75
    assert clock.frame_count == 2

 succeeded in 291ms:
"""Core runtime systems for FPS Bot Arena."""

from src.core.camera import FirstPersonCamera
from src.core.collision import AABB, CollisionWorld
from src.core.game_clock import GameClock
from src.core.game_loop import GameLoop
from src.core.game_state import GameState, GameStateManager
from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
from src.core.movement import PlayerMovementController

__all__ = [
    "AABB",
    "CollisionWorld",
    "FirstPersonCamera",
    "GameClock",
    "GameLoop",
    "GameState",
    "GameStateManager",
    "InputFrame",
    "InputHandler",
 succeeded in 295ms:
# Tests Developer Guide

## Overview
This directory contains the automated test suite for the FPS Bot Arena project.

## Testing Framework
- **Framework:** `pytest`
- **Rationale:** Standard, powerful, and easy-to-use testing framework for Python.

## Structure
- Test files should be named `test_<module_name>.py`.
- Tests should mirror the structure of the `src/` and `config/` directories where applicable.
- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.

## Current Test Modules
- `test_config.py`: validates immutable config defaults.
- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.

 succeeded in 295ms:
import pytest

from src.player.player import Player
from src.weapons.pistol import Pistol
from src.weapons.weapon import Weapon


def test_player_starter_loadout_and_properties():
    player = Player.with_starter_loadout(start_health=100, start_money=0)

    assert player.health == 100
    assert player.money == 0
    assert player.position == (0.0, 1.8, 0.0)
    assert player.rotation == (0.0, 0.0)
    assert player.equipped_weapon_name == "Pistol"
    assert isinstance(player.equipped_weapon, Pistol)


def test_player_health_system_damage_heal_and_death():
    player = Player.with_starter_loadout(start_health=100, start_money=0)
 succeeded in 269ms:
"""Player state and gameplay behavior."""

from src.player.player import Player

__all__ = ["Player"]
 succeeded in 293ms:
from src.core.camera import FirstPersonCamera
from src.core.collision import AABB, CollisionWorld
from src.core.input_handler import InputHandler, InputSnapshot
from src.core.movement import PlayerMovementController
from src.player.player import Player
from src.projectiles.physics import ProjectilePhysicsSystem
from src.weapons.assault_rifle import AssaultRifle
from src.weapons.rpg import RPG
from src.weapons.shotgun import Shotgun


def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
    handler = InputHandler(mouse_sensitivity=1.0)
    camera = FirstPersonCamera()
    frame = handler.build_frame(
        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
    )
    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
    assert yaw == 12.0
    assert pitch == 89.0
 succeeded in 271ms:
"""Projectile simulation with world collision detection."""

from __future__ import annotations

from dataclasses import dataclass

from src.core.collision import AABB, CollisionWorld
from src.projectiles.projectile import Projectile


@dataclass
class ProjectilePhysicsSystem:
    """Advances projectiles and deactivates on world collision."""

    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
        collision_count = 0
        for projectile in projectiles:
            if not projectile.is_active:
                continue
            projectile.advance(delta_time)
 succeeded in 272ms:
"""Projectile entities for bullets, pellets, and rockets."""

from __future__ import annotations

import math
from dataclasses import dataclass


Vector3 = tuple[float, float, float]


def _normalize(direction: Vector3) -> Vector3:
    length = math.sqrt(
        (direction[0] * direction[0])
        + (direction[1] * direction[1])
        + (direction[2] * direction[2])
    )
    if length <= 0.0:
        raise ValueError("Projectile direction must be non-zero.")
    return (
 succeeded in 261ms:
"""Weapon definitions and shared weapon behavior."""

from src.weapons.assault_rifle import AssaultRifle
from src.weapons.pistol import Pistol
from src.weapons.rpg import RPG
from src.weapons.shotgun import Shotgun
from src.weapons.weapon import Weapon

__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]

thinking
**Selecting and planning 10 tasks**
codex
I’ve identified a concrete batch of 10 unchecked tasks that are feasible to complete fully now: raycasting, richer game clock/time management, smooth weapon switching transitions, weapon visual primitives, the two missing/unchecked folder-guide tasks, and four documentation/polish tasks (`README`, controls doc, root architecture guide, and guide currency checks). I’m now implementing code and tests first, then I’ll update all affected developer guides, mark only finished tasks in `tasks.md`, and log changes in `recent-changes.md`.

thinking
**Planning multi-file patch**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/game_clock.py
@@ -1,2 +1,2 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
@@ -9,6 +9,9 @@
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
@@ -16,3 +19,3 @@
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
@@ -21,7 +24,29 @@
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
apply_patch(auto_approved=true) exited 0 in 53ms:
Success. Updated the following files:
M src/core/game_clock.py
file update:
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp

file update:
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp


thinking
**Adding raycasting file**
codex
I’m applying the gameplay code changes now: adding a raycasting module in `src/core`, then wiring smooth switching and hit-scan support into player/weapons models.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/raycasting.py
"""Raycasting primitives used for hit-scan shooting mechanics."""

from __future__ import annotations

from dataclasses import dataclass
from math import sqrt


Vector3 = tuple[float, float, float]


def _normalize(direction: Vector3) -> Vector3:
    length = sqrt(
        (direction[0] * direction[0])
        + (direction[1] * direction[1])
        + (direction[2] * direction[2])
    )
    if length <= 0.0:
        raise ValueError("Ray direction must be non-zero.")
    return (
        direction[0] / length,
        direction[1] / length,
        direction[2] / length,
    )


def _subtract(a: Vector3, b: Vector3) -> Vector3:
    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])


def _dot(a: Vector3, b: Vector3) -> float:
    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])


@dataclass(frozen=True)
class RaycastTarget:
    """Sphere target used by hit-scan line traces."""

    target_id: str
    center: Vector3
    radius: float
    is_active: bool = True


@dataclass(frozen=True)
class RaycastHit:
    """Result of a successful line trace hit."""

    target_id: str
    distance: float
    hit_point: Vector3


@dataclass
class RaycastingSystem:
    """Performs nearest-hit raycasts against spherical targets."""

    def cast_ray(
        self,
        *,
        origin: Vector3,
        direction: Vector3,
        max_distance: float,
        targets: list[RaycastTarget],
    ) -> RaycastHit | None:
        if max_distance <= 0.0:
            raise ValueError("max_distance must be positive.")

        normalized_direction = _normalize(direction)
        nearest_distance = max_distance
        nearest_hit: RaycastHit | None = None

        for target in targets:
            if (not target.is_active) or target.radius <= 0.0:
                continue

            to_center = _subtract(target.center, origin)
            projection = _dot(to_center, normalized_direction)
            if projection < 0.0:
                continue

            center_distance_sq = _dot(to_center, to_center)
            perpendicular_sq = center_distance_sq - (projection * projection)
            radius_sq = target.radius * target.radius
            if perpendicular_sq > radius_sq:
                continue

            half_chord = sqrt(radius_sq - perpendicular_sq)
            near_distance = projection - half_chord
            if near_distance < 0.0:
                near_distance = projection + half_chord
            if near_distance < 0.0 or near_distance > nearest_distance:
                continue

            nearest_distance = near_distance
            nearest_hit = RaycastHit(
                target_id=target.target_id,
                distance=near_distance,
                hit_point=(
                    origin[0] + (normalized_direction[0] * near_distance),
                    origin[1] + (normalized_direction[1] * near_distance),
                    origin[2] + (normalized_direction[2] * near_distance),
                ),
            )

        return nearest_hit
apply_patch(auto_approved=true) exited 0 in 63ms:
Success. Updated the following files:
A src/core/raycasting.py
file update:
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit

file update:
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit


thinking
**Updating core module exports**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/__init__.py
@@ -9,2 +9,3 @@
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
@@ -22,2 +23,5 @@
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
apply_patch(auto_approved=true) exited 0 in 87ms:
Success. Updated the following files:
M src/core/__init__.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit


thinking
**Creating weapons switching and visuals files**
codex
I’ve added the raycasting system and am now adding weapon transition/visual modules plus player integration and tests so these tasks are objectively complete.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/switching.py
"""Smooth weapon switching state machine."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class WeaponSwitchState:
    """Tracks in-progress weapon transition timing."""

    switch_duration_seconds: float = 0.2
    source_weapon_name: str | None = None
    pending_weapon_name: str | None = None
    started_at: float | None = None

    def __post_init__(self) -> None:
        if self.switch_duration_seconds <= 0.0:
            raise ValueError("switch_duration_seconds must be positive.")

    @property
    def is_switching(self) -> bool:
        return self.pending_weapon_name is not None and self.started_at is not None

    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
        """Begin a new smooth switch. Returns False when no switch is needed."""
        if current_weapon_name == next_weapon_name:
            return False
        self.source_weapon_name = current_weapon_name
        self.pending_weapon_name = next_weapon_name
        self.started_at = now
        return True

    def progress(self, now: float) -> float:
        """Current normalized transition progress [0, 1]."""
        if not self.is_switching:
            return 1.0
        elapsed = max(0.0, now - self.started_at)
        return min(1.0, elapsed / self.switch_duration_seconds)

    def complete_if_ready(self, now: float) -> str | None:
        """Finalize switch when duration elapsed and return new weapon name."""
        if not self.is_switching:
            return None
        if self.progress(now) < 1.0:
            return None
        equipped = self.pending_weapon_name
        self.source_weapon_name = None
        self.pending_weapon_name = None
        self.started_at = None
        return equipped

apply_patch(auto_approved=true) exited 0 in 107ms:
Success. Updated the following files:
A src/weapons/switching.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/visuals.py
"""Weapon visual definitions built from geometric primitives."""

from __future__ import annotations

from dataclasses import dataclass


Vector3 = tuple[float, float, float]
ColorRGB = tuple[int, int, int]


@dataclass(frozen=True)
class PrimitiveVisual:
    """Single geometric primitive used by a weapon model."""

    shape: str
    size: Vector3
    offset: Vector3
    color: ColorRGB


@dataclass(frozen=True)
class WeaponVisual:
    """Renderable visual recipe for a weapon."""

    weapon_name: str
    primitives: tuple[PrimitiveVisual, ...]


WEAPON_VISUALS: dict[str, WeaponVisual] = {
    "Pistol": WeaponVisual(
        weapon_name="Pistol",
        primitives=(
            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
        ),
    ),
    "Shotgun": WeaponVisual(
        weapon_name="Shotgun",
        primitives=(
            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
        ),
    ),
    "AssaultRifle": WeaponVisual(
        weapon_name="AssaultRifle",
        primitives=(
            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
        ),
    ),
    "RPG": WeaponVisual(
        weapon_name="RPG",
        primitives=(
            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
        ),
    ),
}


def get_weapon_visual(weapon_name: str) -> WeaponVisual:
    """Return geometric primitive recipe for a known weapon."""
    if weapon_name not in WEAPON_VISUALS:
        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
    return WEAPON_VISUALS[weapon_name]

apply_patch(auto_approved=true) exited 0 in 130ms:
Success. Updated the following files:
A src/weapons/visuals.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+


thinking
**Updating weapons initialization**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/__init__.py
@@ -6,4 +6,16 @@
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
apply_patch(auto_approved=true) exited 0 in 149ms:
Success. Updated the following files:
M src/weapons/__init__.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+


thinking
**Integrating switch and raycast hitscan**
codex
Next I’m updating `Player` to support smooth switch transitions and hit-scan shooting against the new raycasting system while preserving existing APIs.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/player/player.py
@@ -6,4 +6,7 @@
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
@@ -22,2 +25,3 @@
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
@@ -109,2 +113,37 @@
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
@@ -133,2 +172,22 @@
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
apply_patch(auto_approved=true) exited 0 in 176ms:
Success. Updated the following files:
M src/player/player.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..eed3163c8d207b82317f848bbdbab0179c8fb0b0
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,11 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +23,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +111,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +170,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..eed3163c8d207b82317f848bbdbab0179c8fb0b0
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,11 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +23,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +111,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +170,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+


thinking
**Fixing duplicated import**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/player/player.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 198ms:
"""Player model with health, currency, inventory, and shooting."""

from __future__ import annotations

from dataclasses import dataclass, field

from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
from src.projectiles.projectile import Projectile
from src.weapons.pistol import Pistol
from src.weapons.switching import WeaponSwitchState
from src.weapons.pistol import Pistol
from src.weapons.weapon import Weapon


@dataclass
class Player:
    """Encapsulates runtime player state and core gameplay actions."""

    max_health: int
    health: int
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..eed3163c8d207b82317f848bbdbab0179c8fb0b0
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,11 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +23,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +111,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +170,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+


thinking
**Removing duplicate import**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/player/player.py
@@ -10,3 +10,2 @@
 from src.weapons.switching import WeaponSwitchState
-from src.weapons.pistol import Pistol
 from src.weapons.weapon import Weapon
apply_patch(auto_approved=true) exited 0 in 172ms:
Success. Updated the following files:
M src/player/player.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+


thinking
**Planning test coverage updates**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_core_systems.py
@@ -4,2 +4,3 @@
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
@@ -21,2 +22,42 @@
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
apply_patch(auto_approved=true) exited 0 in 190ms:
Success. Updated the following files:
M tests/test_core_systems.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Updating weapon tests**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_advanced_combat_and_movement.py
@@ -4,2 +4,3 @@
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
@@ -9,2 +10,3 @@
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
@@ -64,2 +66,35 @@
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.2)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
@@ -84,2 +119,9 @@
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
apply_patch(auto_approved=true) exited 0 in 213ms:
Success. Updated the following files:
M tests/test_advanced_combat_and_movement.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..7e0c6011182afa7d022928c2886519e481a52d82
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.2)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..7e0c6011182afa7d022928c2886519e481a52d82
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.2)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Considering adding edge case tests**
codex
Code and test updates are in place for raycasting, time controls, smooth switching, and weapon visuals. I’m running the full test suite now to validate everything before documentation/task updates.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 exited 1 in 594ms:
...F....................                                                 [100%]
================================== FAILURES ===================================
__________________ test_smooth_weapon_switch_transition_flow __________________

    def test_smooth_weapon_switch_transition_flow():
        player = Player.with_starter_loadout(start_health=100, start_money=0)
        player.add_weapon(Shotgun())
        started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
        assert started is True
        assert player.is_weapon_switching is True
        assert player.equipped_weapon_name == "Pistol"
        assert player.update_weapon_switch(1.1) is None
        equipped = player.update_weapon_switch(1.2)
>       assert equipped == "Shotgun"
E       AssertionError: assert None == 'Shotgun'

tests\test_advanced_combat_and_movement.py:76: AssertionError
=========================== short test summary info ===========================
FAILED tests/test_advanced_combat_and_movement.py::test_smooth_weapon_switch_transition_flow
1 failed, 23 passed in 0.10s
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..7e0c6011182afa7d022928c2886519e481a52d82
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.2)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Fixing floating-point precision in test**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_advanced_combat_and_movement.py
@@ -74,3 +74,3 @@
     assert player.update_weapon_switch(1.1) is None
-    equipped = player.update_weapon_switch(1.2)
+    equipped = player.update_weapon_switch(1.21)
     assert equipped == "Shotgun"
apply_patch(auto_approved=true) exited 0 in 210ms:
Success. Updated the following files:
M tests/test_advanced_combat_and_movement.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Rerunning tests**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 559ms:
........................                                                 [100%]
24 passed in 0.06s
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Planning developer guide updates**
codex
All tests are passing. I’m now updating `developer-guide.md` files (changed folders plus ancestors), then creating user-facing docs (`README.md`, gameplay/controls) and finally updating `tasks.md` and `recent-changes.md`.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/developer-guide.md
@@ -7,3 +7,3 @@
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
@@ -13,2 +13,3 @@
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
@@ -17,2 +18,3 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
@@ -22 +24,2 @@
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
apply_patch(auto_approved=true) exited 0 in 234ms:
Success. Updated the following files:
M src/core/developer-guide.md
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Updating player guide content**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/player/developer-guide.md
@@ -21,2 +21,3 @@
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
@@ -25,2 +26,3 @@
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
apply_patch(auto_approved=true) exited 0 in 254ms:
Success. Updated the following files:
M src/player/developer-guide.md
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Updating weapons guide**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/weapons/developer-guide.md
@@ -11,2 +11,4 @@
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
@@ -19,2 +21,4 @@
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
apply_patch(auto_approved=true) exited 0 in 269ms:
Success. Updated the following files:
M src/weapons/developer-guide.md
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Updating developer guide**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/developer-guide.md
@@ -6,5 +6,5 @@
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -16,3 +16,4 @@
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
apply_patch(auto_approved=true) exited 0 in 290ms:
Success. Updated the following files:
M src/developer-guide.md
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Updating root developer guide**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md
@@ -8,6 +8,8 @@
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
@@ -16,5 +18,5 @@
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -36,2 +38,3 @@
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
@@ -40,5 +43,7 @@
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
apply_patch(auto_approved=true) exited 0 in 325ms:
Success. Updated the following files:
M developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Updating test guide for new features**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/developer-guide.md
@@ -16,5 +16,5 @@
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
apply_patch(auto_approved=true) exited 0 in 338ms:
Success. Updated the following files:
M tests/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Creating README and gameplay docs**
codex
I’m now adding the user-facing documentation deliverables (`README.md` and a dedicated controls/gameplay guide), then I’ll finalize task checklist and change log updates.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\README.md
# FPS Bot Arena Prototype

Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.

## Requirements
- Python 3.11+
- `pip`

## Installation
```bash
python -m venv .venv
.venv\Scripts\activate
pip install -r requirements.txt
```

## Run Tests
```bash
pytest
```

## Project Layout
- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
- `src/projectiles/`: projectile entities and projectile physics simulation.
- `config/`: centralized runtime configuration.
- `tests/`: pytest suite validating gameplay foundations.

## Current Gameplay Foundations
- WASD/mouse input normalization and first-person camera state.
- Collision-aware movement against world AABBs.
- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
- Projectile and hit-scan shooting paths.
- Smooth timed weapon-switch state model.
- RPG crash trigger flag for glitch-sequence integration.

## Controls and Gameplay Doc
See `GAMEPLAY.md` for player controls, loop, and progression summary.
apply_patch(auto_approved=true) exited 0 in 372ms:
Success. Updated the following files:
A README.md
file update:
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\GAMEPLAY.md
# Gameplay And Controls

## Core Loop
1. Start with a pistol.
2. Fight bots and collect money drops.
3. Buy and switch to stronger weapons.
4. Reach RPG and fire it to trigger the glitch ending sequence.

## Controls
- `W`: move forward
- `A`: strafe left
- `S`: move backward
- `D`: strafe right
- `Mouse`: look/aim (first-person yaw + pitch)
- `Left Mouse` (planned runtime binding): shoot equipped weapon
- `R` (planned runtime binding): reload equipped weapon
- `B` (planned runtime binding): open inventory/shop wheel

## Weapon Progression
1. `Pistol`: starter, reliable semi-auto.
2. `Shotgun`: short-range burst with pellet spread.
3. `AssaultRifle`: rapid sustained fire.
4. `RPG`: high damage; firing triggers crash/glitch state.

## HUD Expectations
- Health
- Ammo (magazine + reserve)
- Money balance
- Crosshair

## Current Prototype Scope
The codebase currently provides backend gameplay systems (logic and tests). Full rendering/UI integration is the next layer on top of these modules.
apply_patch(auto_approved=true) exited 0 in 394ms:
Success. Updated the following files:
A GAMEPLAY.md
file update:
diff --git a/GAMEPLAY.md b/GAMEPLAY.md
new file mode 100644
index 0000000000000000000000000000000000000000..c95f7cf450a897ff1ef8bc7e8ffd96e9a5f0f04a
--- /dev/null
+++ b/GAMEPLAY.md
@@ -0,0 +1,32 @@
+# Gameplay And Controls
+
+## Core Loop
+1. Start with a pistol.
+2. Fight bots and collect money drops.
+3. Buy and switch to stronger weapons.
+4. Reach RPG and fire it to trigger the glitch ending sequence.
+
+## Controls
+- `W`: move forward
+- `A`: strafe left
+- `S`: move backward
+- `D`: strafe right
+- `Mouse`: look/aim (first-person yaw + pitch)
+- `Left Mouse` (planned runtime binding): shoot equipped weapon
+- `R` (planned runtime binding): reload equipped weapon
+- `B` (planned runtime binding): open inventory/shop wheel
+
+## Weapon Progression
+1. `Pistol`: starter, reliable semi-auto.
+2. `Shotgun`: short-range burst with pellet spread.
+3. `AssaultRifle`: rapid sustained fire.
+4. `RPG`: high damage; firing triggers crash/glitch state.
+
+## HUD Expectations
+- Health
+- Ammo (magazine + reserve)
+- Money balance
+- Crosshair
+
+## Current Prototype Scope
+The codebase currently provides backend gameplay systems (logic and tests). Full rendering/UI integration is the next layer on top of these modules.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/GAMEPLAY.md b/GAMEPLAY.md
new file mode 100644
index 0000000000000000000000000000000000000000..c95f7cf450a897ff1ef8bc7e8ffd96e9a5f0f04a
--- /dev/null
+++ b/GAMEPLAY.md
@@ -0,0 +1,32 @@
+# Gameplay And Controls
+
+## Core Loop
+1. Start with a pistol.
+2. Fight bots and collect money drops.
+3. Buy and switch to stronger weapons.
+4. Reach RPG and fire it to trigger the glitch ending sequence.
+
+## Controls
+- `W`: move forward
+- `A`: strafe left
+- `S`: move backward
+- `D`: strafe right
+- `Mouse`: look/aim (first-person yaw + pitch)
+- `Left Mouse` (planned runtime binding): shoot equipped weapon
+- `R` (planned runtime binding): reload equipped weapon
+- `B` (planned runtime binding): open inventory/shop wheel
+
+## Weapon Progression
+1. `Pistol`: starter, reliable semi-auto.
+2. `Shotgun`: short-range burst with pellet spread.
+3. `AssaultRifle`: rapid sustained fire.
+4. `RPG`: high damage; firing triggers crash/glitch state.
+
+## HUD Expectations
+- Health
+- Ammo (magazine + reserve)
+- Money balance
+- Crosshair
+
+## Current Prototype Scope
+The codebase currently provides backend gameplay systems (logic and tests). Full rendering/UI integration is the next layer on top of these modules.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Marking specific developer tasks**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Select-String -Path tasks.md -Pattern "Implement raycasting system for shooting mechanics|Create game clock and time management system|Create src/player folder developer-guide.md|Create weapon switching system with smooth transitions|Add weapon visual representations using geometric primitives|Create src/weapons folder developer-guide.md|Update root developer-guide.md with complete architecture overview|Ensure all code folders have up-to-date developer-guide.md files|Create README.md with installation and running instructions|Document controls and gameplay in user-facing documentation" | ForEach-Object { $_.Line }' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 242ms:
- [ ] Implement raycasting system for shooting mechanics
- [ ] Create game clock and time management system
- [ ] Create src/player folder developer-guide.md
- [ ] Create weapon switching system with smooth transitions
- [ ] Add weapon visual representations using geometric primitives
- [ ] Create src/weapons folder developer-guide.md
- [ ] Update root developer-guide.md with complete architecture overview
- [ ] Ensure all code folders have up-to-date developer-guide.md files
- [ ] Create README.md with installation and running instructions
- [ ] Document controls and gameplay in user-facing documentation
file update:
diff --git a/GAMEPLAY.md b/GAMEPLAY.md
new file mode 100644
index 0000000000000000000000000000000000000000..c95f7cf450a897ff1ef8bc7e8ffd96e9a5f0f04a
--- /dev/null
+++ b/GAMEPLAY.md
@@ -0,0 +1,32 @@
+# Gameplay And Controls
+
+## Core Loop
+1. Start with a pistol.
+2. Fight bots and collect money drops.
+3. Buy and switch to stronger weapons.
+4. Reach RPG and fire it to trigger the glitch ending sequence.
+
+## Controls
+- `W`: move forward
+- `A`: strafe left
+- `S`: move backward
+- `D`: strafe right
+- `Mouse`: look/aim (first-person yaw + pitch)
+- `Left Mouse` (planned runtime binding): shoot equipped weapon
+- `R` (planned runtime binding): reload equipped weapon
+- `B` (planned runtime binding): open inventory/shop wheel
+
+## Weapon Progression
+1. `Pistol`: starter, reliable semi-auto.
+2. `Shotgun`: short-range burst with pellet spread.
+3. `AssaultRifle`: rapid sustained fire.
+4. `RPG`: high damage; firing triggers crash/glitch state.
+
+## HUD Expectations
+- Health
+- Ammo (magazine + reserve)
+- Money balance
+- Crosshair
+
+## Current Prototype Scope
+The codebase currently provides backend gameplay systems (logic and tests). Full rendering/UI integration is the next layer on top of these modules.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Applying patch-related changes**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tasks.md
@@ -18,4 +18,4 @@
 - [x] Create physics system for projectile movement and collision
-- [ ] Implement raycasting system for shooting mechanics
-- [ ] Create game clock and time management system
+- [x] Implement raycasting system for shooting mechanics
+- [x] Create game clock and time management system
 
@@ -30,3 +30,3 @@
 - [x] Add player respawn or game over logic on death
-- [ ] Create src/player folder developer-guide.md
+- [x] Create src/player folder developer-guide.md
 
@@ -39,7 +39,7 @@
 - [x] Implement RPG weapon with special "crash" trigger behavior
-- [ ] Create weapon switching system with smooth transitions
+- [x] Create weapon switching system with smooth transitions
 - [x] Implement ammo management and reload mechanics
 - [x] Create projectile system for bullets and rockets
-- [ ] Add weapon visual representations using geometric primitives
-- [ ] Create src/weapons folder developer-guide.md
+- [x] Add weapon visual representations using geometric primitives
+- [x] Create src/weapons folder developer-guide.md
 
@@ -162,6 +162,6 @@
 
-- [ ] Update root developer-guide.md with complete architecture overview
-- [ ] Ensure all code folders have up-to-date developer-guide.md files
-- [ ] Create README.md with installation and running instructions
-- [ ] Document controls and gameplay in user-facing documentation
+- [x] Update root developer-guide.md with complete architecture overview
+- [x] Ensure all code folders have up-to-date developer-guide.md files
+- [x] Create README.md with installation and running instructions
+- [x] Document controls and gameplay in user-facing documentation
 - [ ] Add code comments for complex algorithms
apply_patch(auto_approved=true) exited 0 in 413ms:
Success. Updated the following files:
M tasks.md
file update:
diff --git a/GAMEPLAY.md b/GAMEPLAY.md
new file mode 100644
index 0000000000000000000000000000000000000000..c95f7cf450a897ff1ef8bc7e8ffd96e9a5f0f04a
--- /dev/null
+++ b/GAMEPLAY.md
@@ -0,0 +1,32 @@
+# Gameplay And Controls
+
+## Core Loop
+1. Start with a pistol.
+2. Fight bots and collect money drops.
+3. Buy and switch to stronger weapons.
+4. Reach RPG and fire it to trigger the glitch ending sequence.
+
+## Controls
+- `W`: move forward
+- `A`: strafe left
+- `S`: move backward
+- `D`: strafe right
+- `Mouse`: look/aim (first-person yaw + pitch)
+- `Left Mouse` (planned runtime binding): shoot equipped weapon
+- `R` (planned runtime binding): reload equipped weapon
+- `B` (planned runtime binding): open inventory/shop wheel
+
+## Weapon Progression
+1. `Pistol`: starter, reliable semi-auto.
+2. `Shotgun`: short-range burst with pellet spread.
+3. `AssaultRifle`: rapid sustained fire.
+4. `RPG`: high damage; firing triggers crash/glitch state.
+
+## HUD Expectations
+- Health
+- Ammo (magazine + reserve)
+- Money balance
+- Crosshair
+
+## Current Prototype Scope
+The codebase currently provides backend gameplay systems (logic and tests). Full rendering/UI integration is the next layer on top of these modules.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tasks.md b/tasks.md
index e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f..8fe22338f9a340171f61ba4279558cc62712a380
--- a/tasks.md
+++ b/tasks.md
@@ -16,8 +16,8 @@
 - [x] Create input handler for WASD movement and mouse controls
 - [x] Implement player movement with collision detection
 - [x] Create physics system for projectile movement and collision
-- [ ] Implement raycasting system for shooting mechanics
-- [ ] Create game clock and time management system
+- [x] Implement raycasting system for shooting mechanics
+- [x] Create game clock and time management system
 
 ## Player Systems
 
@@ -28,7 +28,7 @@
 - [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
 - [x] Add player respawn or game over logic on death
-- [ ] Create src/player folder developer-guide.md
+- [x] Create src/player folder developer-guide.md
 
 ## Weapon System
 
@@ -37,11 +37,11 @@
 - [x] Implement Shotgun weapon with spread pattern and high damage
 - [x] Implement Assault Rifle weapon with rapid fire mechanics
 - [x] Implement RPG weapon with special "crash" trigger behavior
-- [ ] Create weapon switching system with smooth transitions
+- [x] Create weapon switching system with smooth transitions
 - [x] Implement ammo management and reload mechanics
 - [x] Create projectile system for bullets and rockets
-- [ ] Add weapon visual representations using geometric primitives
-- [ ] Create src/weapons folder developer-guide.md
+- [x] Add weapon visual representations using geometric primitives
+- [x] Create src/weapons folder developer-guide.md
 
 ## Shop/Inventory UI
 
@@ -160,10 +160,10 @@
 
 ## Documentation & Polish
 
-- [ ] Update root developer-guide.md with complete architecture overview
-- [ ] Ensure all code folders have up-to-date developer-guide.md files
-- [ ] Create README.md with installation and running instructions
-- [ ] Document controls and gameplay in user-facing documentation
+- [x] Update root developer-guide.md with complete architecture overview
+- [x] Ensure all code folders have up-to-date developer-guide.md files
+- [x] Create README.md with installation and running instructions
+- [x] Document controls and gameplay in user-facing documentation
 - [ ] Add code comments for complex algorithms
 - [ ] Review and compact any developer-guide.md files over 500 lines
 - [ ] Verify no code files exceed 1000 lines
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/GAMEPLAY.md b/GAMEPLAY.md
new file mode 100644
index 0000000000000000000000000000000000000000..c95f7cf450a897ff1ef8bc7e8ffd96e9a5f0f04a
--- /dev/null
+++ b/GAMEPLAY.md
@@ -0,0 +1,32 @@
+# Gameplay And Controls
+
+## Core Loop
+1. Start with a pistol.
+2. Fight bots and collect money drops.
+3. Buy and switch to stronger weapons.
+4. Reach RPG and fire it to trigger the glitch ending sequence.
+
+## Controls
+- `W`: move forward
+- `A`: strafe left
+- `S`: move backward
+- `D`: strafe right
+- `Mouse`: look/aim (first-person yaw + pitch)
+- `Left Mouse` (planned runtime binding): shoot equipped weapon
+- `R` (planned runtime binding): reload equipped weapon
+- `B` (planned runtime binding): open inventory/shop wheel
+
+## Weapon Progression
+1. `Pistol`: starter, reliable semi-auto.
+2. `Shotgun`: short-range burst with pellet spread.
+3. `AssaultRifle`: rapid sustained fire.
+4. `RPG`: high damage; firing triggers crash/glitch state.
+
+## HUD Expectations
+- Health
+- Ammo (magazine + reserve)
+- Money balance
+- Crosshair
+
+## Current Prototype Scope
+The codebase currently provides backend gameplay systems (logic and tests). Full rendering/UI integration is the next layer on top of these modules.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tasks.md b/tasks.md
index e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f..8fe22338f9a340171f61ba4279558cc62712a380
--- a/tasks.md
+++ b/tasks.md
@@ -16,8 +16,8 @@
 - [x] Create input handler for WASD movement and mouse controls
 - [x] Implement player movement with collision detection
 - [x] Create physics system for projectile movement and collision
-- [ ] Implement raycasting system for shooting mechanics
-- [ ] Create game clock and time management system
+- [x] Implement raycasting system for shooting mechanics
+- [x] Create game clock and time management system
 
 ## Player Systems
 
@@ -28,7 +28,7 @@
 - [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
 - [x] Add player respawn or game over logic on death
-- [ ] Create src/player folder developer-guide.md
+- [x] Create src/player folder developer-guide.md
 
 ## Weapon System
 
@@ -37,11 +37,11 @@
 - [x] Implement Shotgun weapon with spread pattern and high damage
 - [x] Implement Assault Rifle weapon with rapid fire mechanics
 - [x] Implement RPG weapon with special "crash" trigger behavior
-- [ ] Create weapon switching system with smooth transitions
+- [x] Create weapon switching system with smooth transitions
 - [x] Implement ammo management and reload mechanics
 - [x] Create projectile system for bullets and rockets
-- [ ] Add weapon visual representations using geometric primitives
-- [ ] Create src/weapons folder developer-guide.md
+- [x] Add weapon visual representations using geometric primitives
+- [x] Create src/weapons folder developer-guide.md
 
 ## Shop/Inventory UI
 
@@ -160,10 +160,10 @@
 
 ## Documentation & Polish
 
-- [ ] Update root developer-guide.md with complete architecture overview
-- [ ] Ensure all code folders have up-to-date developer-guide.md files
-- [ ] Create README.md with installation and running instructions
-- [ ] Document controls and gameplay in user-facing documentation
+- [x] Update root developer-guide.md with complete architecture overview
+- [x] Ensure all code folders have up-to-date developer-guide.md files
+- [x] Create README.md with installation and running instructions
+- [x] Document controls and gameplay in user-facing documentation
 - [ ] Add code comments for complex algorithms
 - [ ] Review and compact any developer-guide.md files over 500 lines
 - [ ] Verify no code files exceed 1000 lines
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Adding entries to changelog**
codex
I’m finishing by updating `tasks.md` and `recent-changes.md` with the exact completed items and concrete implementation details.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\recent-changes.md
@@ -1,2 +1,23 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented hit-scan raycasting in `src/core/raycasting.py` with nearest-hit sphere target detection and exported it via `src/core/__init__.py`.
+- Upgraded `GameClock` in `src/core/game_clock.py` with pause/resume support, time scaling, unscaled elapsed tracking, and reset behavior.
+- Added smooth weapon switch transitions via `src/weapons/switching.py` and integrated the workflow into `src/player/player.py`.
+- Added geometric weapon visual definitions in `src/weapons/visuals.py` for Pistol, Shotgun, AssaultRifle, and RPG; exported through `src/weapons/__init__.py`.
+- Added player hit-scan firing API (`shoot_hitscan`) using the new raycasting system.
+- Expanded tests:
+  - `tests/test_core_systems.py`: time controls and raycasting coverage.
+  - `tests/test_advanced_combat_and_movement.py`: smooth switching, hit-scan firing, and weapon visual definitions.
+- Added user-facing docs:
+  - `README.md` with install/test/run overview.
+  - `GAMEPLAY.md` with controls and gameplay loop documentation.
+- Updated developer guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+- Updated `tasks.md` to mark 10 completed tasks as done.
 
apply_patch(auto_approved=true) exited 0 in 426ms:
Success. Updated the following files:
M recent-changes.md
file update:
diff --git a/GAMEPLAY.md b/GAMEPLAY.md
new file mode 100644
index 0000000000000000000000000000000000000000..c95f7cf450a897ff1ef8bc7e8ffd96e9a5f0f04a
--- /dev/null
+++ b/GAMEPLAY.md
@@ -0,0 +1,32 @@
+# Gameplay And Controls
+
+## Core Loop
+1. Start with a pistol.
+2. Fight bots and collect money drops.
+3. Buy and switch to stronger weapons.
+4. Reach RPG and fire it to trigger the glitch ending sequence.
+
+## Controls
+- `W`: move forward
+- `A`: strafe left
+- `S`: move backward
+- `D`: strafe right
+- `Mouse`: look/aim (first-person yaw + pitch)
+- `Left Mouse` (planned runtime binding): shoot equipped weapon
+- `R` (planned runtime binding): reload equipped weapon
+- `B` (planned runtime binding): open inventory/shop wheel
+
+## Weapon Progression
+1. `Pistol`: starter, reliable semi-auto.
+2. `Shotgun`: short-range burst with pellet spread.
+3. `AssaultRifle`: rapid sustained fire.
+4. `RPG`: high damage; firing triggers crash/glitch state.
+
+## HUD Expectations
+- Health
+- Ammo (magazine + reserve)
+- Money balance
+- Crosshair
+
+## Current Prototype Scope
+The codebase currently provides backend gameplay systems (logic and tests). Full rendering/UI integration is the next layer on top of these modules.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..2c703415e2a0fe8e9340c1856f7e90299c25bfde
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,23 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented hit-scan raycasting in `src/core/raycasting.py` with nearest-hit sphere target detection and exported it via `src/core/__init__.py`.
+- Upgraded `GameClock` in `src/core/game_clock.py` with pause/resume support, time scaling, unscaled elapsed tracking, and reset behavior.
+- Added smooth weapon switch transitions via `src/weapons/switching.py` and integrated the workflow into `src/player/player.py`.
+- Added geometric weapon visual definitions in `src/weapons/visuals.py` for Pistol, Shotgun, AssaultRifle, and RPG; exported through `src/weapons/__init__.py`.
+- Added player hit-scan firing API (`shoot_hitscan`) using the new raycasting system.
+- Expanded tests:
+  - `tests/test_core_systems.py`: time controls and raycasting coverage.
+  - `tests/test_advanced_combat_and_movement.py`: smooth switching, hit-scan firing, and weapon visual definitions.
+- Added user-facing docs:
+  - `README.md` with install/test/run overview.
+  - `GAMEPLAY.md` with controls and gameplay loop documentation.
+- Updated developer guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+- Updated `tasks.md` to mark 10 completed tasks as done.
 
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tasks.md b/tasks.md
index e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f..8fe22338f9a340171f61ba4279558cc62712a380
--- a/tasks.md
+++ b/tasks.md
@@ -16,8 +16,8 @@
 - [x] Create input handler for WASD movement and mouse controls
 - [x] Implement player movement with collision detection
 - [x] Create physics system for projectile movement and collision
-- [ ] Implement raycasting system for shooting mechanics
-- [ ] Create game clock and time management system
+- [x] Implement raycasting system for shooting mechanics
+- [x] Create game clock and time management system
 
 ## Player Systems
 
@@ -28,7 +28,7 @@
 - [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
 - [x] Add player respawn or game over logic on death
-- [ ] Create src/player folder developer-guide.md
+- [x] Create src/player folder developer-guide.md
 
 ## Weapon System
 
@@ -37,11 +37,11 @@
 - [x] Implement Shotgun weapon with spread pattern and high damage
 - [x] Implement Assault Rifle weapon with rapid fire mechanics
 - [x] Implement RPG weapon with special "crash" trigger behavior
-- [ ] Create weapon switching system with smooth transitions
+- [x] Create weapon switching system with smooth transitions
 - [x] Implement ammo management and reload mechanics
 - [x] Create projectile system for bullets and rockets
-- [ ] Add weapon visual representations using geometric primitives
-- [ ] Create src/weapons folder developer-guide.md
+- [x] Add weapon visual representations using geometric primitives
+- [x] Create src/weapons folder developer-guide.md
 
 ## Shop/Inventory UI
 
@@ -160,10 +160,10 @@
 
 ## Documentation & Polish
 
-- [ ] Update root developer-guide.md with complete architecture overview
-- [ ] Ensure all code folders have up-to-date developer-guide.md files
-- [ ] Create README.md with installation and running instructions
-- [ ] Document controls and gameplay in user-facing documentation
+- [x] Update root developer-guide.md with complete architecture overview
+- [x] Ensure all code folders have up-to-date developer-guide.md files
+- [x] Create README.md with installation and running instructions
+- [x] Document controls and gameplay in user-facing documentation
 - [ ] Add code comments for complex algorithms
 - [ ] Review and compact any developer-guide.md files over 500 lines
 - [ ] Verify no code files exceed 1000 lines
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

file update:
diff --git a/GAMEPLAY.md b/GAMEPLAY.md
new file mode 100644
index 0000000000000000000000000000000000000000..c95f7cf450a897ff1ef8bc7e8ffd96e9a5f0f04a
--- /dev/null
+++ b/GAMEPLAY.md
@@ -0,0 +1,32 @@
+# Gameplay And Controls
+
+## Core Loop
+1. Start with a pistol.
+2. Fight bots and collect money drops.
+3. Buy and switch to stronger weapons.
+4. Reach RPG and fire it to trigger the glitch ending sequence.
+
+## Controls
+- `W`: move forward
+- `A`: strafe left
+- `S`: move backward
+- `D`: strafe right
+- `Mouse`: look/aim (first-person yaw + pitch)
+- `Left Mouse` (planned runtime binding): shoot equipped weapon
+- `R` (planned runtime binding): reload equipped weapon
+- `B` (planned runtime binding): open inventory/shop wheel
+
+## Weapon Progression
+1. `Pistol`: starter, reliable semi-auto.
+2. `Shotgun`: short-range burst with pellet spread.
+3. `AssaultRifle`: rapid sustained fire.
+4. `RPG`: high damage; firing triggers crash/glitch state.
+
+## HUD Expectations
+- Health
+- Ammo (magazine + reserve)
+- Money balance
+- Crosshair
+
+## Current Prototype Scope
+The codebase currently provides backend gameplay systems (logic and tests). Full rendering/UI integration is the next layer on top of these modules.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..2c703415e2a0fe8e9340c1856f7e90299c25bfde
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,23 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented hit-scan raycasting in `src/core/raycasting.py` with nearest-hit sphere target detection and exported it via `src/core/__init__.py`.
+- Upgraded `GameClock` in `src/core/game_clock.py` with pause/resume support, time scaling, unscaled elapsed tracking, and reset behavior.
+- Added smooth weapon switch transitions via `src/weapons/switching.py` and integrated the workflow into `src/player/player.py`.
+- Added geometric weapon visual definitions in `src/weapons/visuals.py` for Pistol, Shotgun, AssaultRifle, and RPG; exported through `src/weapons/__init__.py`.
+- Added player hit-scan firing API (`shoot_hitscan`) using the new raycasting system.
+- Expanded tests:
+  - `tests/test_core_systems.py`: time controls and raycasting coverage.
+  - `tests/test_advanced_combat_and_movement.py`: smooth switching, hit-scan firing, and weapon visual definitions.
+- Added user-facing docs:
+  - `README.md` with install/test/run overview.
+  - `GAMEPLAY.md` with controls and gameplay loop documentation.
+- Updated developer guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+- Updated `tasks.md` to mark 10 completed tasks as done.
 
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tasks.md b/tasks.md
index e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f..8fe22338f9a340171f61ba4279558cc62712a380
--- a/tasks.md
+++ b/tasks.md
@@ -16,8 +16,8 @@
 - [x] Create input handler for WASD movement and mouse controls
 - [x] Implement player movement with collision detection
 - [x] Create physics system for projectile movement and collision
-- [ ] Implement raycasting system for shooting mechanics
-- [ ] Create game clock and time management system
+- [x] Implement raycasting system for shooting mechanics
+- [x] Create game clock and time management system
 
 ## Player Systems
 
@@ -28,7 +28,7 @@
 - [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
 - [x] Add player respawn or game over logic on death
-- [ ] Create src/player folder developer-guide.md
+- [x] Create src/player folder developer-guide.md
 
 ## Weapon System
 
@@ -37,11 +37,11 @@
 - [x] Implement Shotgun weapon with spread pattern and high damage
 - [x] Implement Assault Rifle weapon with rapid fire mechanics
 - [x] Implement RPG weapon with special "crash" trigger behavior
-- [ ] Create weapon switching system with smooth transitions
+- [x] Create weapon switching system with smooth transitions
 - [x] Implement ammo management and reload mechanics
 - [x] Create projectile system for bullets and rockets
-- [ ] Add weapon visual representations using geometric primitives
-- [ ] Create src/weapons folder developer-guide.md
+- [x] Add weapon visual representations using geometric primitives
+- [x] Create src/weapons folder developer-guide.md
 
 ## Shop/Inventory UI
 
@@ -160,10 +160,10 @@
 
 ## Documentation & Polish
 
-- [ ] Update root developer-guide.md with complete architecture overview
-- [ ] Ensure all code folders have up-to-date developer-guide.md files
-- [ ] Create README.md with installation and running instructions
-- [ ] Document controls and gameplay in user-facing documentation
+- [x] Update root developer-guide.md with complete architecture overview
+- [x] Ensure all code folders have up-to-date developer-guide.md files
+- [x] Create README.md with installation and running instructions
+- [x] Document controls and gameplay in user-facing documentation
 - [ ] Add code comments for complex algorithms
 - [ ] Review and compact any developer-guide.md files over 500 lines
 - [ ] Verify no code files exceed 1000 lines
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Checking for code changes**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'git status --short' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 207ms:
 M .agentharness/git-commit-message.txt
 D .codex_last_message.txt
 M developer-guide.md
 M recent-changes.md
 M src/core/__init__.py
 M src/core/__pycache__/__init__.cpython-311.pyc
 M src/core/__pycache__/game_clock.cpython-311.pyc
 M src/core/developer-guide.md
 M src/core/game_clock.py
 M src/developer-guide.md
 M src/player/__pycache__/player.cpython-311.pyc
 M src/player/developer-guide.md
 M src/player/player.py
 M src/weapons/__init__.py
 M src/weapons/__pycache__/__init__.cpython-311.pyc
 M src/weapons/developer-guide.md
 M tasks.md
 M tests/__pycache__/test_advanced_combat_and_movement.cpython-311-pytest-9.0.2.pyc
 M tests/__pycache__/test_core_systems.cpython-311-pytest-9.0.2.pyc
 M tests/developer-guide.md
file update:
diff --git a/GAMEPLAY.md b/GAMEPLAY.md
new file mode 100644
index 0000000000000000000000000000000000000000..c95f7cf450a897ff1ef8bc7e8ffd96e9a5f0f04a
--- /dev/null
+++ b/GAMEPLAY.md
@@ -0,0 +1,32 @@
+# Gameplay And Controls
+
+## Core Loop
+1. Start with a pistol.
+2. Fight bots and collect money drops.
+3. Buy and switch to stronger weapons.
+4. Reach RPG and fire it to trigger the glitch ending sequence.
+
+## Controls
+- `W`: move forward
+- `A`: strafe left
+- `S`: move backward
+- `D`: strafe right
+- `Mouse`: look/aim (first-person yaw + pitch)
+- `Left Mouse` (planned runtime binding): shoot equipped weapon
+- `R` (planned runtime binding): reload equipped weapon
+- `B` (planned runtime binding): open inventory/shop wheel
+
+## Weapon Progression
+1. `Pistol`: starter, reliable semi-auto.
+2. `Shotgun`: short-range burst with pellet spread.
+3. `AssaultRifle`: rapid sustained fire.
+4. `RPG`: high damage; firing triggers crash/glitch state.
+
+## HUD Expectations
+- Health
+- Ammo (magazine + reserve)
+- Money balance
+- Crosshair
+
+## Current Prototype Scope
+The codebase currently provides backend gameplay systems (logic and tests). Full rendering/UI integration is the next layer on top of these modules.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..2c703415e2a0fe8e9340c1856f7e90299c25bfde
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,23 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented hit-scan raycasting in `src/core/raycasting.py` with nearest-hit sphere target detection and exported it via `src/core/__init__.py`.
+- Upgraded `GameClock` in `src/core/game_clock.py` with pause/resume support, time scaling, unscaled elapsed tracking, and reset behavior.
+- Added smooth weapon switch transitions via `src/weapons/switching.py` and integrated the workflow into `src/player/player.py`.
+- Added geometric weapon visual definitions in `src/weapons/visuals.py` for Pistol, Shotgun, AssaultRifle, and RPG; exported through `src/weapons/__init__.py`.
+- Added player hit-scan firing API (`shoot_hitscan`) using the new raycasting system.
+- Expanded tests:
+  - `tests/test_core_systems.py`: time controls and raycasting coverage.
+  - `tests/test_advanced_combat_and_movement.py`: smooth switching, hit-scan firing, and weapon visual definitions.
+- Added user-facing docs:
+  - `README.md` with install/test/run overview.
+  - `GAMEPLAY.md` with controls and gameplay loop documentation.
+- Updated developer guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+- Updated `tasks.md` to mark 10 completed tasks as done.
 
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tasks.md b/tasks.md
index e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f..8fe22338f9a340171f61ba4279558cc62712a380
--- a/tasks.md
+++ b/tasks.md
@@ -16,8 +16,8 @@
 - [x] Create input handler for WASD movement and mouse controls
 - [x] Implement player movement with collision detection
 - [x] Create physics system for projectile movement and collision
-- [ ] Implement raycasting system for shooting mechanics
-- [ ] Create game clock and time management system
+- [x] Implement raycasting system for shooting mechanics
+- [x] Create game clock and time management system
 
 ## Player Systems
 
@@ -28,7 +28,7 @@
 - [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
 - [x] Add player respawn or game over logic on death
-- [ ] Create src/player folder developer-guide.md
+- [x] Create src/player folder developer-guide.md
 
 ## Weapon System
 
@@ -37,11 +37,11 @@
 - [x] Implement Shotgun weapon with spread pattern and high damage
 - [x] Implement Assault Rifle weapon with rapid fire mechanics
 - [x] Implement RPG weapon with special "crash" trigger behavior
-- [ ] Create weapon switching system with smooth transitions
+- [x] Create weapon switching system with smooth transitions
 - [x] Implement ammo management and reload mechanics
 - [x] Create projectile system for bullets and rockets
-- [ ] Add weapon visual representations using geometric primitives
-- [ ] Create src/weapons folder developer-guide.md
+- [x] Add weapon visual representations using geometric primitives
+- [x] Create src/weapons folder developer-guide.md
 
 ## Shop/Inventory UI
 
@@ -160,10 +160,10 @@
 
 ## Documentation & Polish
 
-- [ ] Update root developer-guide.md with complete architecture overview
-- [ ] Ensure all code folders have up-to-date developer-guide.md files
-- [ ] Create README.md with installation and running instructions
-- [ ] Document controls and gameplay in user-facing documentation
+- [x] Update root developer-guide.md with complete architecture overview
+- [x] Ensure all code folders have up-to-date developer-guide.md files
+- [x] Create README.md with installation and running instructions
+- [x] Document controls and gameplay in user-facing documentation
 - [ ] Add code comments for complex algorithms
 - [ ] Review and compact any developer-guide.md files over 500 lines
 - [ ] Verify no code files exceed 1000 lines
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 


thinking
**Addressing unexpected unrelated changes**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tasks.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content recent-changes.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 221ms:
# Recent Changes

## 2026-02-08
- Implemented hit-scan raycasting in `src/core/raycasting.py` with nearest-hit sphere target detection and exported it via `src/core/__init__.py`.
- Upgraded `GameClock` in `src/core/game_clock.py` with pause/resume support, time scaling, unscaled elapsed tracking, and reset behavior.
- Added smooth weapon switch transitions via `src/weapons/switching.py` and integrated the workflow into `src/player/player.py`.
- Added geometric weapon visual definitions in `src/weapons/visuals.py` for Pistol, Shotgun, AssaultRifle, and RPG; exported through `src/weapons/__init__.py`.
- Added player hit-scan firing API (`shoot_hitscan`) using the new raycasting system.
- Expanded tests:
  - `tests/test_core_systems.py`: time controls and raycasting coverage.
  - `tests/test_advanced_combat_and_movement.py`: smooth switching, hit-scan firing, and weapon visual definitions.
- Added user-facing docs:
  - `README.md` with install/test/run overview.
  - `GAMEPLAY.md` with controls and gameplay loop documentation.
- Updated developer guides to reflect current behavior:
  - `developer-guide.md`
  - `src/developer-guide.md`
  - `src/core/developer-guide.md`
  - `src/player/developer-guide.md`
  - `src/weapons/developer-guide.md`
 succeeded in 226ms:
# FPS Bot Arena Implementation Tasks

## Project Setup & Architecture

- [x] Choose and document the technology stack (Python + Ursina or Web + Three.js)
- [x] Set up project structure with main folders (src, assets, config, tests)
- [x] Create root developer-guide.md documenting overall project architecture
- [x] Initialize package.json or requirements.txt with core dependencies
- [x] Set up basic project configuration files (config.py or config.js)

## Core Game Engine

- [x] Implement main game loop with frame updates and delta time handling
- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
- [x] Implement camera system with first-person perspective and mouse look controls
- [x] Create input handler for WASD movement and mouse controls
- [x] Implement player movement with collision detection
- [x] Create physics system for projectile movement and collision
- [x] Implement raycasting system for shooting mechanics
- [x] Create game clock and time management system
file update:
diff --git a/GAMEPLAY.md b/GAMEPLAY.md
new file mode 100644
index 0000000000000000000000000000000000000000..c95f7cf450a897ff1ef8bc7e8ffd96e9a5f0f04a
--- /dev/null
+++ b/GAMEPLAY.md
@@ -0,0 +1,32 @@
+# Gameplay And Controls
+
+## Core Loop
+1. Start with a pistol.
+2. Fight bots and collect money drops.
+3. Buy and switch to stronger weapons.
+4. Reach RPG and fire it to trigger the glitch ending sequence.
+
+## Controls
+- `W`: move forward
+- `A`: strafe left
+- `S`: move backward
+- `D`: strafe right
+- `Mouse`: look/aim (first-person yaw + pitch)
+- `Left Mouse` (planned runtime binding): shoot equipped weapon
+- `R` (planned runtime binding): reload equipped weapon
+- `B` (planned runtime binding): open inventory/shop wheel
+
+## Weapon Progression
+1. `Pistol`: starter, reliable semi-auto.
+2. `Shotgun`: short-range burst with pellet spread.
+3. `AssaultRifle`: rapid sustained fire.
+4. `RPG`: high damage; firing triggers crash/glitch state.
+
+## HUD Expectations
+- Health
+- Ammo (magazine + reserve)
+- Money balance
+- Crosshair
+
+## Current Prototype Scope
+The codebase currently provides backend gameplay systems (logic and tests). Full rendering/UI integration is the next layer on top of these modules.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..2c703415e2a0fe8e9340c1856f7e90299c25bfde
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,23 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented hit-scan raycasting in `src/core/raycasting.py` with nearest-hit sphere target detection and exported it via `src/core/__init__.py`.
+- Upgraded `GameClock` in `src/core/game_clock.py` with pause/resume support, time scaling, unscaled elapsed tracking, and reset behavior.
+- Added smooth weapon switch transitions via `src/weapons/switching.py` and integrated the workflow into `src/player/player.py`.
+- Added geometric weapon visual definitions in `src/weapons/visuals.py` for Pistol, Shotgun, AssaultRifle, and RPG; exported through `src/weapons/__init__.py`.
+- Added player hit-scan firing API (`shoot_hitscan`) using the new raycasting system.
+- Expanded tests:
+  - `tests/test_core_systems.py`: time controls and raycasting coverage.
+  - `tests/test_advanced_combat_and_movement.py`: smooth switching, hit-scan firing, and weapon visual definitions.
+- Added user-facing docs:
+  - `README.md` with install/test/run overview.
+  - `GAMEPLAY.md` with controls and gameplay loop documentation.
+- Updated developer guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+- Updated `tasks.md` to mark 10 completed tasks as done.
 
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tasks.md b/tasks.md
index e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f..8fe22338f9a340171f61ba4279558cc62712a380
--- a/tasks.md
+++ b/tasks.md
@@ -16,8 +16,8 @@
 - [x] Create input handler for WASD movement and mouse controls
 - [x] Implement player movement with collision detection
 - [x] Create physics system for projectile movement and collision
-- [ ] Implement raycasting system for shooting mechanics
-- [ ] Create game clock and time management system
+- [x] Implement raycasting system for shooting mechanics
+- [x] Create game clock and time management system
 
 ## Player Systems
 
@@ -28,7 +28,7 @@
 - [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
 - [x] Add player respawn or game over logic on death
-- [ ] Create src/player folder developer-guide.md
+- [x] Create src/player folder developer-guide.md
 
 ## Weapon System
 
@@ -37,11 +37,11 @@
 - [x] Implement Shotgun weapon with spread pattern and high damage
 - [x] Implement Assault Rifle weapon with rapid fire mechanics
 - [x] Implement RPG weapon with special "crash" trigger behavior
-- [ ] Create weapon switching system with smooth transitions
+- [x] Create weapon switching system with smooth transitions
 - [x] Implement ammo management and reload mechanics
 - [x] Create projectile system for bullets and rockets
-- [ ] Add weapon visual representations using geometric primitives
-- [ ] Create src/weapons folder developer-guide.md
+- [x] Add weapon visual representations using geometric primitives
+- [x] Create src/weapons folder developer-guide.md
 
 ## Shop/Inventory UI
 
@@ -160,10 +160,10 @@
 
 ## Documentation & Polish
 
-- [ ] Update root developer-guide.md with complete architecture overview
-- [ ] Ensure all code folders have up-to-date developer-guide.md files
-- [ ] Create README.md with installation and running instructions
-- [ ] Document controls and gameplay in user-facing documentation
+- [x] Update root developer-guide.md with complete architecture overview
+- [x] Ensure all code folders have up-to-date developer-guide.md files
+- [x] Create README.md with installation and running instructions
+- [x] Document controls and gameplay in user-facing documentation
 - [ ] Add code comments for complex algorithms
 - [ ] Review and compact any developer-guide.md files over 500 lines
 - [ ] Verify no code files exceed 1000 lines
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

codex
Implemented 10 incomplete tasks end-to-end and updated all required tracking/docs.

Completed tasks marked in `tasks.md`:
1. `Implement raycasting system for shooting mechanics`
2. `Create game clock and time management system`
3. `Create src/player folder developer-guide.md`
4. `Create weapon switching system with smooth transitions`
5. `Add weapon visual representations using geometric primitives`
6. `Create src/weapons folder developer-guide.md`
7. `Update root developer-guide.md with complete architecture overview`
8. `Ensure all code folders have up-to-date developer-guide.md files`
9. `Create README.md with installation and running instructions`
10. `Document controls and gameplay in user-facing documentation`

Key implementation changes:
- Added raycasting: `src/core/raycasting.py`
- Extended clock/time controls: `src/core/game_clock.py`
- Added smooth switch state machine: `src/weapons/switching.py`
- Added weapon primitive visual definitions: `src/weapons/visuals.py`
- Integrated smooth switching + hitscan shooting in player: `src/player/player.py`
- Updated exports: `src/core/__init__.py`, `src/weapons/__init__.py`
- Added docs: `README.md`, `GAMEPLAY.md`
- Updated developer guides:
  - `developer-guide.md`
  - `src/developer-guide.md`
  - `src/core/developer-guide.md`
  - `src/player/developer-guide.md`
  - `src/weapons/developer-guide.md`
  - `tests/developer-guide.md`
- Updated changelog: `recent-changes.md`
- Updated checklist: `tasks.md`

Validation:
- Ran `pytest -q`
- Result: `24 passed`

Additional tasks discovered:
- None added to `tasks.md`.
file update:
diff --git a/GAMEPLAY.md b/GAMEPLAY.md
new file mode 100644
index 0000000000000000000000000000000000000000..c95f7cf450a897ff1ef8bc7e8ffd96e9a5f0f04a
--- /dev/null
+++ b/GAMEPLAY.md
@@ -0,0 +1,32 @@
+# Gameplay And Controls
+
+## Core Loop
+1. Start with a pistol.
+2. Fight bots and collect money drops.
+3. Buy and switch to stronger weapons.
+4. Reach RPG and fire it to trigger the glitch ending sequence.
+
+## Controls
+- `W`: move forward
+- `A`: strafe left
+- `S`: move backward
+- `D`: strafe right
+- `Mouse`: look/aim (first-person yaw + pitch)
+- `Left Mouse` (planned runtime binding): shoot equipped weapon
+- `R` (planned runtime binding): reload equipped weapon
+- `B` (planned runtime binding): open inventory/shop wheel
+
+## Weapon Progression
+1. `Pistol`: starter, reliable semi-auto.
+2. `Shotgun`: short-range burst with pellet spread.
+3. `AssaultRifle`: rapid sustained fire.
+4. `RPG`: high damage; firing triggers crash/glitch state.
+
+## HUD Expectations
+- Health
+- Ammo (magazine + reserve)
+- Money balance
+- Crosshair
+
+## Current Prototype Scope
+The codebase currently provides backend gameplay systems (logic and tests). Full rendering/UI integration is the next layer on top of these modules.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..382b082347547f512eee8bdbf1938e8d74fdf76f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,38 @@
+# FPS Bot Arena Prototype
+
+Python/Ursina foundation for a first-person wave-shooter prototype with progression weapons and a glitch ending path.
+
+## Requirements
+- Python 3.11+
+- `pip`
+
+## Installation
+```bash
+python -m venv .venv
+.venv\Scripts\activate
+pip install -r requirements.txt
+```
+
+## Run Tests
+```bash
+pytest
+```
+
+## Project Layout
+- `src/core/`: game loop, state manager, clock/time controls, camera/input, movement/collision, raycasting.
+- `src/player/`: player state, health/economy, inventory, weapon switching, firing logic.
+- `src/weapons/`: weapon definitions, switch transitions, weapon visual primitive definitions.
+- `src/projectiles/`: projectile entities and projectile physics simulation.
+- `config/`: centralized runtime configuration.
+- `tests/`: pytest suite validating gameplay foundations.
+
+## Current Gameplay Foundations
+- WASD/mouse input normalization and first-person camera state.
+- Collision-aware movement against world AABBs.
+- Weapon progression classes: Pistol, Shotgun, Assault Rifle, RPG.
+- Projectile and hit-scan shooting paths.
+- Smooth timed weapon-switch state model.
+- RPG crash trigger flag for glitch-sequence integration.
+
+## Controls and Gameplay Doc
+See `GAMEPLAY.md` for player controls, loop, and progression summary.
diff --git a/developer-guide.md b/developer-guide.md
index eb9009057b8c8475899900f6470b552c82ed8836..bed6307a499756adf4eb394b824402b8ca9fdce8
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..2c703415e2a0fe8e9340c1856f7e90299c25bfde
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,23 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Implemented hit-scan raycasting in `src/core/raycasting.py` with nearest-hit sphere target detection and exported it via `src/core/__init__.py`.
+- Upgraded `GameClock` in `src/core/game_clock.py` with pause/resume support, time scaling, unscaled elapsed tracking, and reset behavior.
+- Added smooth weapon switch transitions via `src/weapons/switching.py` and integrated the workflow into `src/player/player.py`.
+- Added geometric weapon visual definitions in `src/weapons/visuals.py` for Pistol, Shotgun, AssaultRifle, and RPG; exported through `src/weapons/__init__.py`.
+- Added player hit-scan firing API (`shoot_hitscan`) using the new raycasting system.
+- Expanded tests:
+  - `tests/test_core_systems.py`: time controls and raycasting coverage.
+  - `tests/test_advanced_combat_and_movement.py`: smooth switching, hit-scan firing, and weapon visual definitions.
+- Added user-facing docs:
+  - `README.md` with install/test/run overview.
+  - `GAMEPLAY.md` with controls and gameplay loop documentation.
+- Updated developer guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+- Updated `tasks.md` to mark 10 completed tasks as done.
 
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6a3693ac2041df3a21f591ddf4717b1246..61af34f368f93d5dcf1060c9147f96ca7fe2baeb
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e20b6f374d2e970c80ca9f8dec98a4a4c84..102838a669b88c86f57f85187b15f4f90e8ec78c
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141973b942bfeb63aaac21425807f83ce656..620f7fc18ad7d9b361d26abb6a09b09313cff5c4
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/core/raycasting.py b/src/core/raycasting.py
new file mode 100644
index 0000000000000000000000000000000000000000..4005c9f2a34c7758a90f5bed924f0fe6d6cf7428
--- /dev/null
+++ b/src/core/raycasting.py
@@ -0,0 +1,106 @@
+"""Raycasting primitives used for hit-scan shooting mechanics."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Ray direction must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _subtract(a: Vector3, b: Vector3) -> Vector3:
+    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])
+
+
+def _dot(a: Vector3, b: Vector3) -> float:
+    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2])
+
+
+@dataclass(frozen=True)
+class RaycastTarget:
+    """Sphere target used by hit-scan line traces."""
+
+    target_id: str
+    center: Vector3
+    radius: float
+    is_active: bool = True
+
+
+@dataclass(frozen=True)
+class RaycastHit:
+    """Result of a successful line trace hit."""
+
+    target_id: str
+    distance: float
+    hit_point: Vector3
+
+
+@dataclass
+class RaycastingSystem:
+    """Performs nearest-hit raycasts against spherical targets."""
+
+    def cast_ray(
+        self,
+        *,
+        origin: Vector3,
+        direction: Vector3,
+        max_distance: float,
+        targets: list[RaycastTarget],
+    ) -> RaycastHit | None:
+        if max_distance <= 0.0:
+            raise ValueError("max_distance must be positive.")
+
+        normalized_direction = _normalize(direction)
+        nearest_distance = max_distance
+        nearest_hit: RaycastHit | None = None
+
+        for target in targets:
+            if (not target.is_active) or target.radius <= 0.0:
+                continue
+
+            to_center = _subtract(target.center, origin)
+            projection = _dot(to_center, normalized_direction)
+            if projection < 0.0:
+                continue
+
+            center_distance_sq = _dot(to_center, to_center)
+            perpendicular_sq = center_distance_sq - (projection * projection)
+            radius_sq = target.radius * target.radius
+            if perpendicular_sq > radius_sq:
+                continue
+
+            half_chord = sqrt(radius_sq - perpendicular_sq)
+            near_distance = projection - half_chord
+            if near_distance < 0.0:
+                near_distance = projection + half_chord
+            if near_distance < 0.0 or near_distance > nearest_distance:
+                continue
+
+            nearest_distance = near_distance
+            nearest_hit = RaycastHit(
+                target_id=target.target_id,
+                distance=near_distance,
+                hit_point=(
+                    origin[0] + (normalized_direction[0] * near_distance),
+                    origin[1] + (normalized_direction[1] * near_distance),
+                    origin[2] + (normalized_direction[2] * near_distance),
+                ),
+            )
+
+        return nearest_hit
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf429fd50ca29f10e5af2043969a049a56f..c459e0f0f049744750b8da9632016ea262601070
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7452244bee07e7bfe7e19216c245d67e75..866f2fdfc018d1391a74e9728cd4cea80efec8e3
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc91b9cc3d0bb574c54aa03f61148ebeb35..80abc4d05e77d575876c9e881648e187637128e6
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab326e591915f25bc22f1f3bf6ce3297d433..c2713e8aef63aa2fb6239772bbc13118f7bd9f7a
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc4800b055b1fd5ca5a4497bee97330482cc53..498722d6c62a312c757bfc15bfc6edf4fac38c3d
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/src/weapons/switching.py b/src/weapons/switching.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e9ca5487aa3b2ca72cde1a2d76fbd1e43cdccb0
--- /dev/null
+++ b/src/weapons/switching.py
@@ -0,0 +1,52 @@
+"""Smooth weapon switching state machine."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+@dataclass
+class WeaponSwitchState:
+    """Tracks in-progress weapon transition timing."""
+
+    switch_duration_seconds: float = 0.2
+    source_weapon_name: str | None = None
+    pending_weapon_name: str | None = None
+    started_at: float | None = None
+
+    def __post_init__(self) -> None:
+        if self.switch_duration_seconds <= 0.0:
+            raise ValueError("switch_duration_seconds must be positive.")
+
+    @property
+    def is_switching(self) -> bool:
+        return self.pending_weapon_name is not None and self.started_at is not None
+
+    def start_switch(self, current_weapon_name: str, next_weapon_name: str, now: float) -> bool:
+        """Begin a new smooth switch. Returns False when no switch is needed."""
+        if current_weapon_name == next_weapon_name:
+            return False
+        self.source_weapon_name = current_weapon_name
+        self.pending_weapon_name = next_weapon_name
+        self.started_at = now
+        return True
+
+    def progress(self, now: float) -> float:
+        """Current normalized transition progress [0, 1]."""
+        if not self.is_switching:
+            return 1.0
+        elapsed = max(0.0, now - self.started_at)
+        return min(1.0, elapsed / self.switch_duration_seconds)
+
+    def complete_if_ready(self, now: float) -> str | None:
+        """Finalize switch when duration elapsed and return new weapon name."""
+        if not self.is_switching:
+            return None
+        if self.progress(now) < 1.0:
+            return None
+        equipped = self.pending_weapon_name
+        self.source_weapon_name = None
+        self.pending_weapon_name = None
+        self.started_at = None
+        return equipped
+
diff --git a/src/weapons/visuals.py b/src/weapons/visuals.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed989f506ae30a4ade420d8b9cf75a3f05ceeec8
--- /dev/null
+++ b/src/weapons/visuals.py
@@ -0,0 +1,69 @@
+"""Weapon visual definitions built from geometric primitives."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+
+Vector3 = tuple[float, float, float]
+ColorRGB = tuple[int, int, int]
+
+
+@dataclass(frozen=True)
+class PrimitiveVisual:
+    """Single geometric primitive used by a weapon model."""
+
+    shape: str
+    size: Vector3
+    offset: Vector3
+    color: ColorRGB
+
+
+@dataclass(frozen=True)
+class WeaponVisual:
+    """Renderable visual recipe for a weapon."""
+
+    weapon_name: str
+    primitives: tuple[PrimitiveVisual, ...]
+
+
+WEAPON_VISUALS: dict[str, WeaponVisual] = {
+    "Pistol": WeaponVisual(
+        weapon_name="Pistol",
+        primitives=(
+            PrimitiveVisual("box", (0.35, 0.12, 0.6), (0.0, -0.08, 0.0), (35, 35, 35)),
+            PrimitiveVisual("box", (0.2, 0.22, 0.2), (0.0, -0.24, -0.1), (60, 60, 60)),
+        ),
+    ),
+    "Shotgun": WeaponVisual(
+        weapon_name="Shotgun",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.09, 0.9, 0.09), (0.0, -0.03, 0.2), (50, 50, 50)),
+            PrimitiveVisual("box", (0.2, 0.16, 0.45), (0.0, -0.08, -0.15), (95, 70, 40)),
+        ),
+    ),
+    "AssaultRifle": WeaponVisual(
+        weapon_name="AssaultRifle",
+        primitives=(
+            PrimitiveVisual("box", (0.38, 0.14, 0.92), (0.0, -0.05, 0.12), (40, 70, 45)),
+            PrimitiveVisual("box", (0.18, 0.3, 0.16), (0.0, -0.22, -0.12), (25, 25, 25)),
+            PrimitiveVisual("box", (0.16, 0.18, 0.28), (0.0, -0.02, 0.0), (30, 30, 30)),
+        ),
+    ),
+    "RPG": WeaponVisual(
+        weapon_name="RPG",
+        primitives=(
+            PrimitiveVisual("cylinder", (0.16, 1.2, 0.16), (0.0, -0.04, 0.2), (55, 80, 50)),
+            PrimitiveVisual("cone", (0.3, 0.24, 0.3), (0.0, -0.04, 0.82), (120, 55, 40)),
+            PrimitiveVisual("box", (0.22, 0.14, 0.22), (0.0, -0.2, -0.1), (30, 30, 30)),
+        ),
+    ),
+}
+
+
+def get_weapon_visual(weapon_name: str) -> WeaponVisual:
+    """Return geometric primitive recipe for a known weapon."""
+    if weapon_name not in WEAPON_VISUALS:
+        raise ValueError(f"No visual definition for weapon '{weapon_name}'.")
+    return WEAPON_VISUALS[weapon_name]
+
diff --git a/tasks.md b/tasks.md
index e1a63fca12b6de3ef3b5cb3e70ea0ada20d0d62f..8fe22338f9a340171f61ba4279558cc62712a380
--- a/tasks.md
+++ b/tasks.md
@@ -16,8 +16,8 @@
 - [x] Create input handler for WASD movement and mouse controls
 - [x] Implement player movement with collision detection
 - [x] Create physics system for projectile movement and collision
-- [ ] Implement raycasting system for shooting mechanics
-- [ ] Create game clock and time management system
+- [x] Implement raycasting system for shooting mechanics
+- [x] Create game clock and time management system
 
 ## Player Systems
 
@@ -28,7 +28,7 @@
 - [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
 - [x] Add player respawn or game over logic on death
-- [ ] Create src/player folder developer-guide.md
+- [x] Create src/player folder developer-guide.md
 
 ## Weapon System
 
@@ -37,11 +37,11 @@
 - [x] Implement Shotgun weapon with spread pattern and high damage
 - [x] Implement Assault Rifle weapon with rapid fire mechanics
 - [x] Implement RPG weapon with special "crash" trigger behavior
-- [ ] Create weapon switching system with smooth transitions
+- [x] Create weapon switching system with smooth transitions
 - [x] Implement ammo management and reload mechanics
 - [x] Create projectile system for bullets and rockets
-- [ ] Add weapon visual representations using geometric primitives
-- [ ] Create src/weapons folder developer-guide.md
+- [x] Add weapon visual representations using geometric primitives
+- [x] Create src/weapons folder developer-guide.md
 
 ## Shop/Inventory UI
 
@@ -160,10 +160,10 @@
 
 ## Documentation & Polish
 
-- [ ] Update root developer-guide.md with complete architecture overview
-- [ ] Ensure all code folders have up-to-date developer-guide.md files
-- [ ] Create README.md with installation and running instructions
-- [ ] Document controls and gameplay in user-facing documentation
+- [x] Update root developer-guide.md with complete architecture overview
+- [x] Ensure all code folders have up-to-date developer-guide.md files
+- [x] Create README.md with installation and running instructions
+- [x] Document controls and gameplay in user-facing documentation
 - [ ] Add code comments for complex algorithms
 - [ ] Review and compact any developer-guide.md files over 500 lines
 - [ ] Verify no code files exceed 1000 lines
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f1701a37b66aec941fba6e4268e37f7d7af47..c994bd8a115b73790c0ff85a15e05f2353a7af2f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73a4ad035ef91e3dc1938d6d9010dfc04a2..81ec3b8a8c81fa6cfb099095d6ed1a970a9e88f3
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6ab9c70c305ffe8153ca5ba04763e394ab..35815703c3cd0a2ad37f693066bc2bcfda4587c5
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
 

tokens used
81,011
Implemented 10 incomplete tasks end-to-end and updated all required tracking/docs.

Completed tasks marked in `tasks.md`:
1. `Implement raycasting system for shooting mechanics`
2. `Create game clock and time management system`
3. `Create src/player folder developer-guide.md`
4. `Create weapon switching system with smooth transitions`
5. `Add weapon visual representations using geometric primitives`
6. `Create src/weapons folder developer-guide.md`
7. `Update root developer-guide.md with complete architecture overview`
8. `Ensure all code folders have up-to-date developer-guide.md files`
9. `Create README.md with installation and running instructions`
10. `Document controls and gameplay in user-facing documentation`

Key implementation changes:
- Added raycasting: `src/core/raycasting.py`
- Extended clock/time controls: `src/core/game_clock.py`
- Added smooth switch state machine: `src/weapons/switching.py`
- Added weapon primitive visual definitions: `src/weapons/visuals.py`
- Integrated smooth switching + hitscan shooting in player: `src/player/player.py`
- Updated exports: `src/core/__init__.py`, `src/weapons/__init__.py`
- Added docs: `README.md`, `GAMEPLAY.md`
- Updated developer guides:
  - `developer-guide.md`
  - `src/developer-guide.md`
  - `src/core/developer-guide.md`
  - `src/player/developer-guide.md`
  - `src/weapons/developer-guide.md`
  - `tests/developer-guide.md`
- Updated changelog: `recent-changes.md`
- Updated checklist: `tasks.md`

Validation:
- Ran `pytest -q`
- Result: `24 passed`

Additional tasks discovered:
- None added to `tasks.md`.
Implemented 10 incomplete tasks end-to-end and updated all required tracking/docs.

Completed tasks marked in `tasks.md`:
1. `Implement raycasting system for shooting mechanics`
2. `Create game clock and time management system`
3. `Create src/player folder developer-guide.md`
4. `Create weapon switching system with smooth transitions`
5. `Add weapon visual representations using geometric primitives`
6. `Create src/weapons folder developer-guide.md`
7. `Update root developer-guide.md with complete architecture overview`
8. `Ensure all code folders have up-to-date developer-guide.md files`
9. `Create README.md with installation and running instructions`
10. `Document controls and gameplay in user-facing documentation`

Key implementation changes:
- Added raycasting: `src/core/raycasting.py`
- Extended clock/time controls: `src/core/game_clock.py`
- Added smooth switch state machine: `src/weapons/switching.py`
- Added weapon primitive visual definitions: `src/weapons/visuals.py`
- Integrated smooth switching + hitscan shooting in player: `src/player/player.py`
- Updated exports: `src/core/__init__.py`, `src/weapons/__init__.py`
- Added docs: `README.md`, `GAMEPLAY.md`
- Updated developer guides:
  - `developer-guide.md`
  - `src/developer-guide.md`
  - `src/core/developer-guide.md`
  - `src/player/developer-guide.md`
  - `src/weapons/developer-guide.md`
  - `tests/developer-guide.md`
- Updated changelog: `recent-changes.md`
- Updated checklist: `tasks.md`

Validation:
- Ran `pytest -q`
- Result: `24 passed`

Additional tasks discovered:
- None added to `tasks.md`.
Process exited with code 0. Output length: 1146873 chars.
End: 2026-02-08T18:24:46
__AGENTHARNESS_LIVE_DONE__
