AgentHarness LLM Live Output
Start: 2026-02-08T18:27:16
CWD: C:/Users/shlob/Pycharm Projects/harness-test/harness-test-4
Command: gemini --model gemini-3-pro-preview --yolo

Provider: Gemini, Model: gemini-3-pro-preview | Timeout: 300s
Prompt transport: stdin (32541 chars)
LLM prompt begin (stdin)
Create a git commit message and write it to `.agentharness/git-commit-message.txt`.

Rules:
1. Only edit `.agentharness/git-commit-message.txt`.
2. Write a concise commit message following standards.
3. Use the provided git status and diff snapshot; do not run git commands.
4. Do not create or modify any other file.

Commit message quality:
- Start with a verb (Add, Fix, Update, Implement, Refactor, etc.)
- Be concise but specific
- Reflect the main change just completed in the provided git diff snapshot and in the recent changes file

GIT STATUS (PORCELAIN):
M .agentharness/git-commit-message.txt
 M developer-guide.md
 M recent-changes.md
 M src/core/__init__.py
D  src/core/__pycache__/__init__.cpython-311.pyc
D  src/core/__pycache__/camera.cpython-311.pyc
D  src/core/__pycache__/collision.cpython-311.pyc
D  src/core/__pycache__/game_clock.cpython-311.pyc
D  src/core/__pycache__/game_loop.cpython-311.pyc
D  src/core/__pycache__/game_state.cpython-311.pyc
D  src/core/__pycache__/input_handler.cpython-311.pyc
D  src/core/__pycache__/movement.cpython-311.pyc
 M src/core/developer-guide.md
 M src/core/game_clock.py
 M src/developer-guide.md
D  src/player/__pycache__/__init__.cpython-311.pyc
D  src/player/__pycache__/player.cpython-311.pyc
 M src/player/developer-guide.md
 M src/player/player.py
 M src/weapons/__init__.py
D  src/weapons/__pycache__/__init__.cpython-311.pyc
D  src/weapons/__pycache__/assault_rifle.cpython-311.pyc
D  src/weapons/__pycache__/pistol.cpython-311.pyc
D  src/weapons/__pycache__/rpg.cpython-311.pyc
D  src/weapons/__pycache__/shotgun.cpython-311.pyc
D  src/weapons/__pycache__/weapon.cpython-311.pyc
 M src/weapons/developer-guide.md
 M tasks.md
D  tests/__pycache__/conftest.cpython-311-pytest-9.0.2.pyc
D  tests/__pycache__/test_advanced_combat_and_movement.cpython-311-pytest-9.0.2.pyc
D  tests/__pycache__/test_config.cpython-311-pytest-9.0.2.pyc
D  tests/__pycache__/test_core_systems.cpython-311-pytest-9.0.2.pyc
D  tests/__pycache__/test_player_and_weapons.cpython-311-pytest-9.0.2.pyc
 M tests/developer-guide.md
 M tests/test_advanced_combat_and_movement.py
 M tests/test_core_systems.py
?? .agentharness/live-llm/llm_20260208_181938_202956f6.log
?? .agentharness/live-llm/llm_20260208_182446_fc0aca0b.log
?? .agentharness/live-llm/llm_20260208_182541_f5123945.log
?? .agentharness/live-llm/llm_20260208_182648_3b363b87.log
?? .gitignore
?? GAMEPLAY.md
?? README.md
?? src/core/raycasting.py
?? src/weapons/switching.py
?? src/weapons/visuals.py

GIT DIFF:
diff --git a/.agentharness/git-commit-message.txt b/.agentharness/git-commit-message.txt
index f6a1100..e69de29 100644
--- a/.agentharness/git-commit-message.txt
+++ b/.agentharness/git-commit-message.txt
@@ -1,8 +0,0 @@
-Implement advanced combat, movement, collision, and projectile systems
-
-- Implement `FirstPersonCamera`, `CollisionWorld`, and `PlayerMovementController` with wall sliding and bounds checking.
-- Add `Shotgun`, `AssaultRifle`, and `RPG` weapons; implement weapon cycling and reload mechanics.
-- Implement `Projectile` system foundation with physics stepping and collision deactivation.
-- Update `Player` to support projectile firing, game-over state on death, and respawning.
-- Add `tests/test_advanced_combat_and_movement.py` covering new systems.
-- Update documentation and task tracking.
\ No newline at end of file
diff --git a/developer-guide.md b/developer-guide.md
index eb90090..bed6307 100644
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -6,17 +6,19 @@ This project uses **Python + Ursina** for a lightweight FPS prototype.
 The current codebase implements engine-agnostic gameplay foundations in pure Python:
 - Core runtime loop and timing
 - State machine for high-level game flow
+- Clock pause/resume and time scaling controls
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
-- Player model with health, money, inventory, weapon switching, reload, and respawn/game-over
-- Weapon system with pistol, shotgun, assault rifle, and RPG
+- Raycasting-based hit-scan traces
+- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
+- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, and collision primitives.
-  - `src/player/`: player runtime state, combat APIs, inventory switching, reload, and respawn.
-  - `src/weapons/`: weapon base model and concrete implementations.
+  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
+  - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -34,13 +36,16 @@ The current codebase implements engine-agnostic gameplay foundations in pure Pyt
 
 ## Implemented Gameplay Foundations
 - `GameLoop.step(now)` advances time each frame and dispatches updates only while in `playing`.
+- `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
-- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, reload, projectile firing, and respawn.
+- `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
+- `Player` enforces bounded health, game-over on death, validated currency operations, inventory ownership checks, weapon cycling, smooth timed switching, reload, projectile/hit-scan firing, and respawn.
 - `Weapon` enforces cooldown/ammo, reload behavior, and projectile payload generation.
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
+- `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 
 ## Development Notes
diff --git a/recent-changes.md b/recent-changes.md
index 52c11ab..1da48fc 100644
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,21 +1,28 @@
 # Recent Changes
 
-## 2026-02-08 (Code Review Fix)
-- Fixed `CollisionWorld.outside_world_bounds` in `src/core/collision.py` to use containment check instead of intersection check. Now correctly returns `True` when any part of a box is outside world bounds, preventing players/projectiles from drifting outside world edges.
+## 2026-02-08 (Code Review Fixes)
+- Fixed raycasting bug in `src/core/raycasting.py`: Removed incorrect early rejection of targets when `projection < 0`, which was causing false negatives for rays originating inside spheres or near large targets.
+- Added `.gitignore` to properly exclude Python bytecode files (`*.pyc`, `__pycache__/`) and other build artifacts from version control.
+- Removed all tracked `.pyc` files from git to reduce repository noise.
 
 ## 2026-02-08
-- Implemented first-person camera state in `src/core/camera.py` with yaw/pitch mouse-look updates and pitch clamping.
-- Implemented collision primitives and movement controller in `src/core/collision.py` and `src/core/movement.py` for player movement with wall/bounds collision and slide resolution.
-- Added new weapon implementations:
-  - `src/weapons/shotgun.py` (pellet spread payload)
-  - `src/weapons/assault_rifle.py` (rapid fire)
-  - `src/weapons/rpg.py` (crash trigger flag when fired)
-- Extended `src/weapons/weapon.py` with ammo reload mechanics, total ammo tracking, and projectile payload generation.
-- Extended `src/player/player.py` with weapon cycling, reload delegation, projectile firing API, game-over state on death, and respawn handling.
-- Added projectile package `src/projectiles/`:
-  - `projectile.py` for projectile entities and movement/lifetime
-  - `physics.py` for projectile movement and world collision deactivation
-- Updated package exports in `src/core/__init__.py`, `src/player/__init__.py`, and `src/weapons/__init__.py`.
-- Added `tests/test_advanced_combat_and_movement.py` covering camera look, movement collision, weapon switching/reload/respawn, new weapons, and projectile physics.
-- Verified full test suite passes: `19 passed`.
+- Implemented hit-scan raycasting in `src/core/raycasting.py` with nearest-hit sphere target detection and exported it via `src/core/__init__.py`.
+- Upgraded `GameClock` in `src/core/game_clock.py` with pause/resume support, time scaling, unscaled elapsed tracking, and reset behavior.
+- Added smooth weapon switch transitions via `src/weapons/switching.py` and integrated the workflow into `src/player/player.py`.
+- Added geometric weapon visual definitions in `src/weapons/visuals.py` for Pistol, Shotgun, AssaultRifle, and RPG; exported through `src/weapons/__init__.py`.
+- Added player hit-scan firing API (`shoot_hitscan`) using the new raycasting system.
+- Expanded tests:
+  - `tests/test_core_systems.py`: time controls and raycasting coverage.
+  - `tests/test_advanced_combat_and_movement.py`: smooth switching, hit-scan firing, and weapon visual definitions.
+- Added user-facing docs:
+  - `README.md` with install/test/run overview.
+  - `GAMEPLAY.md` with controls and gameplay loop documentation.
+- Updated developer guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `src/player/developer-guide.md`
+  - `src/weapons/developer-guide.md`
+  - `tests/developer-guide.md`
+- Updated `tasks.md` to mark 10 completed tasks as done.
 
diff --git a/src/core/__init__.py b/src/core/__init__.py
index b79dce6..61af34f 100644
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -7,6 +7,7 @@ from src.core.game_loop import GameLoop
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 
 __all__ = [
     "AABB",
@@ -20,4 +21,7 @@ __all__ = [
     "InputHandler",
     "InputSnapshot",
     "PlayerMovementController",
+    "RaycastHit",
+    "RaycastingSystem",
+    "RaycastTarget",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 52f31e2..102838a 100644
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -5,18 +5,21 @@
 
 ## Files
 - `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
-- `game_clock.py`: `GameClock` for frame delta-time and total elapsed time tracking.
+- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
 - `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
 - `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
 - `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
+- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
+- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
+- `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
diff --git a/src/core/game_clock.py b/src/core/game_clock.py
index 333d141..620f7fc 100644
--- a/src/core/game_clock.py
+++ b/src/core/game_clock.py
@@ -1,4 +1,4 @@
-"""Lightweight game clock and delta-time tracking."""
+"""Lightweight game clock and time-management controls."""
 
 from __future__ import annotations
 
@@ -7,21 +7,46 @@ from dataclasses import dataclass
 
 @dataclass
 class GameClock:
-    """Tracks elapsed and per-frame timing."""
+    """Tracks elapsed time, pause state, and time scaling."""
 
     elapsed_time: float = 0.0
+    unscaled_elapsed_time: float = 0.0
     frame_count: int = 0
+    is_paused: bool = False
+    time_scale: float = 1.0
     _last_timestamp: float | None = None
 
     def tick(self, now: float) -> float:
-        """Advance the clock and return frame delta-time in seconds."""
+        """Advance the clock and return scaled frame delta-time in seconds."""
         if self._last_timestamp is None:
             self._last_timestamp = now
             return 0.0
 
-        delta_time = max(0.0, now - self._last_timestamp)
+        unscaled_delta = max(0.0, now - self._last_timestamp)
         self._last_timestamp = now
+        self.unscaled_elapsed_time += unscaled_delta
+        if self.is_paused:
+            return 0.0
+
+        delta_time = unscaled_delta * self.time_scale
         self.elapsed_time += delta_time
-        self.frame_count += 1
+        if delta_time > 0.0:
+            self.frame_count += 1
         return delta_time
 
+    def set_paused(self, paused: bool) -> None:
+        """Pause or resume scaled time progression."""
+        self.is_paused = paused
+
+    def set_time_scale(self, scale: float) -> None:
+        """Configure non-zero positive scale applied to frame delta."""
+        if scale <= 0.0:
+            raise ValueError("time scale must be positive.")
+        self.time_scale = scale
+
+    def reset(self, timestamp: float | None = None) -> None:
+        """Reset elapsed counters and optionally set a new last timestamp."""
+        self.elapsed_time = 0.0
+        self.unscaled_elapsed_time = 0.0
+        self.frame_count = 0
+        self._last_timestamp = timestamp
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e8a3abf..c459e0f 100644
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,9 +4,9 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock, state machine, input normalization, first-person camera state, movement, and collision primitives.
-- `player/`: player runtime model (health, money, inventory, weapon switching, reload, shooting, game-over/respawn).
-- `weapons/`: reusable weapon abstractions and concrete weapon implementations (pistol/shotgun/assault rifle/RPG).
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
+- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 
 ## Integration Flow
@@ -14,5 +14,6 @@
 2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
 3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
-5. Player actions call weapon models for cooldown/ammo/reload behavior and projectile payload generation.
+5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
+7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
diff --git a/src/player/developer-guide.md b/src/player/developer-guide.md
index 2e946f7..866f2fd 100644
--- a/src/player/developer-guide.md
+++ b/src/player/developer-guide.md
@@ -19,10 +19,12 @@
   - Weapons are stored by name.
   - `equip_weapon` requires ownership.
   - `cycle_weapon(direction)` supports next/previous switching through owned weapons.
+  - Smooth transitions are available through `start_smooth_weapon_switch`, `start_smooth_cycle_weapon`, and `update_weapon_switch`.
 - Combat logic:
   - `shoot(now)` delegates to the equipped weapon and consumes ammo only on successful shots.
   - `reload_weapon()` delegates magazine refill from reserve ammo.
   - `shoot_projectiles(...)` returns instantiated projectile entities for projectile simulation systems.
+  - `shoot_hitscan(...)` performs a raycast-backed hit-scan shot and returns nearest hit metadata.
 - Death/respawn logic:
   - Health reaching `0` marks `is_game_over=True`.
   - `shoot` is blocked while game over.
diff --git a/src/player/player.py b/src/player/player.py
index 04eedcc..80abc4d 100644
--- a/src/player/player.py
+++ b/src/player/player.py
@@ -4,8 +4,10 @@ from __future__ import annotations
 
 from dataclasses import dataclass, field
 
+from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
 from src.projectiles.projectile import Projectile
 from src.weapons.pistol import Pistol
+from src.weapons.switching import WeaponSwitchState
 from src.weapons.weapon import Weapon
 
 
@@ -20,6 +22,7 @@ class Player:
     rotation: tuple[float, float] = (0.0, 0.0)
     inventory: dict[str, Weapon] = field(default_factory=dict)
     equipped_weapon_name: str | None = None
+    switch_state: WeaponSwitchState = field(default_factory=WeaponSwitchState)
     is_game_over: bool = False
 
     @classmethod
@@ -107,6 +110,41 @@ class Player:
         self.equipped_weapon_name = weapon_names[next_index]
         return self.equipped_weapon_name
 
+    @property
+    def is_weapon_switching(self) -> bool:
+        return self.switch_state.is_switching
+
+    def start_smooth_weapon_switch(self, weapon_name: str, now: float) -> bool:
+        """Begin a timed switch transition to an owned weapon."""
+        if weapon_name not in self.inventory:
+            raise ValueError(f"Weapon '{weapon_name}' not in inventory.")
+        if self.equipped_weapon_name is None:
+            self.equipped_weapon_name = weapon_name
+            return False
+        return self.switch_state.start_switch(self.equipped_weapon_name, weapon_name, now)
+
+    def start_smooth_cycle_weapon(self, now: float, direction: int = 1) -> bool:
+        """Begin a timed switch to the next/previous inventory weapon."""
+        if direction == 0:
+            raise ValueError("direction cannot be 0.")
+        weapon_names = list(self.inventory.keys())
+        if not weapon_names:
+            raise ValueError("No weapons available in inventory.")
+        if self.equipped_weapon_name not in weapon_names:
+            self.equipped_weapon_name = weapon_names[0]
+            return False
+        current_index = weapon_names.index(self.equipped_weapon_name)
+        next_index = (current_index + direction) % len(weapon_names)
+        return self.start_smooth_weapon_switch(weapon_names[next_index], now)
+
+    def update_weapon_switch(self, now: float) -> str | None:
+        """Complete active smooth transition and return equipped weapon when done."""
+        next_weapon = self.switch_state.complete_if_ready(now)
+        if next_weapon is None:
+            return None
+        self.equipped_weapon_name = next_weapon
+        return next_weapon
+
     def reload_weapon(self) -> int:
         return self.equipped_weapon.reload()
 
@@ -131,6 +169,26 @@ class Player:
         )
         return [Projectile.from_payload(item) for item in payload]
 
+    def shoot_hitscan(
+        self,
+        *,
+        now: float,
+        origin: tuple[float, float, float],
+        direction: tuple[float, float, float],
+        targets: list[RaycastTarget],
+        raycasting_system: RaycastingSystem,
+        max_distance: float = 120.0,
+    ) -> RaycastHit | None:
+        """Fire equipped weapon and return nearest hit-scan hit, if any."""
+        if not self.shoot(now):
+            return None
+        return raycasting_system.cast_ray(
+            origin=origin,
+            direction=direction,
+            max_distance=max_distance,
+            targets=targets,
+        )
+
     def respawn(self, spawn_position: tuple[float, float, float]) -> None:
         """Reset player death/game-over state and place at spawn."""
         self.health = self.max_health
diff --git a/src/weapons/__init__.py b/src/weapons/__init__.py
index d6f6ab3..c2713e8 100644
--- a/src/weapons/__init__.py
+++ b/src/weapons/__init__.py
@@ -4,6 +4,18 @@ from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.pistol import Pistol
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.switching import WeaponSwitchState
+from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
 from src.weapons.weapon import Weapon
 
-__all__ = ["Weapon", "Pistol", "Shotgun", "AssaultRifle", "RPG"]
+__all__ = [
+    "Weapon",
+    "Pistol",
+    "Shotgun",
+    "AssaultRifle",
+    "RPG",
+    "WeaponSwitchState",
+    "PrimitiveVisual",
+    "WeaponVisual",
+    "get_weapon_visual",
+]
diff --git a/src/weapons/developer-guide.md b/src/weapons/developer-guide.md
index 2acc480..498722d 100644
--- a/src/weapons/developer-guide.md
+++ b/src/weapons/developer-guide.md
@@ -9,6 +9,8 @@
 - `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
 - `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
 - `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
+- `switching.py`: timed weapon transition state machine for smooth switching UX.
+- `visuals.py`: geometric primitive visual definitions for each progression weapon.
 
 ## Key Behaviors
 - `Weapon.fire(now)` returns `True` only when:
@@ -17,6 +19,8 @@
 - Successful fire events decrement `ammo_in_magazine` by exactly one.
 - `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.
 - `Weapon.create_projectile_payload(...)` produces normalized projectile spawn payload consumed by the projectile system.
+- `WeaponSwitchState` tracks source/pending weapon names, switch progress, and completion timing.
+- `get_weapon_visual(...)` returns renderer-ready primitive recipes (`box`, `cylinder`, `cone`) for weapon models.
 - `Pistol` defaults:
   - damage `20`
   - fire rate `3` shots/sec
diff --git a/tasks.md b/tasks.md
index e1a63fc..8fe2233 100644
--- a/tasks.md
+++ b/tasks.md
@@ -16,8 +16,8 @@
 - [x] Create input handler for WASD movement and mouse controls
 - [x] Implement player movement with collision detection
 - [x] Create physics system for projectile movement and collision
-- [ ] Implement raycasting system for shooting mechanics
-- [ ] Create game clock and time management system
+- [x] Implement raycasting system for shooting mechanics
+- [x] Create game clock and time management system
 
 ## Player Systems
 
@@ -28,7 +28,7 @@
 - [x] Create player weapon switching logic
 - [x] Implement player shooting mechanics with ammo consumption
 - [x] Add player respawn or game over logic on death
-- [ ] Create src/player folder developer-guide.md
+- [x] Create src/player folder developer-guide.md
 
 ## Weapon System
 
@@ -37,11 +37,11 @@
 - [x] Implement Shotgun weapon with spread pattern and high damage
 - [x] Implement Assault Rifle weapon with rapid fire mechanics
 - [x] Implement RPG weapon with special "crash" trigger behavior
-- [ ] Create weapon switching system with smooth transitions
+- [x] Create weapon switching system with smooth transitions
 - [x] Implement ammo management and reload mechanics
 - [x] Create projectile system for bullets and rockets
-- [ ] Add weapon visual representations using geometric primitives
-- [ ] Create src/weapons folder developer-guide.md
+- [x] Add weapon visual representations using geometric primitives
+- [x] Create src/weapons folder developer-guide.md
 
 ## Shop/Inventory UI
 
@@ -160,10 +160,10 @@
 
 ## Documentation & Polish
 
-- [ ] Update root developer-guide.md with complete architecture overview
-- [ ] Ensure all code folders have up-to-date developer-guide.md files
-- [ ] Create README.md with installation and running instructions
-- [ ] Document controls and gameplay in user-facing documentation
+- [x] Update root developer-guide.md with complete architecture overview
+- [x] Ensure all code folders have up-to-date developer-guide.md files
+- [x] Create README.md with installation and running instructions
+- [x] Document controls and gameplay in user-facing documentation
 - [ ] Add code comments for complex algorithms
 - [ ] Review and compact any developer-guide.md files over 500 lines
 - [ ] Verify no code files exceed 1000 lines
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 540f170..c994bd8 100644
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,9 +14,9 @@ This directory contains the automated test suite for the FPS Bot Arena project.
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
-- `test_advanced_combat_and_movement.py`: validates first-person camera look, movement collision/slide, weapon switching + reload + respawn, new weapon behaviors, and projectile physics collisions.
+- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_advanced_combat_and_movement.py b/tests/test_advanced_combat_and_movement.py
index 326ff73..81ec3b8 100644
--- a/tests/test_advanced_combat_and_movement.py
+++ b/tests/test_advanced_combat_and_movement.py
@@ -2,11 +2,13 @@ from src.core.camera import FirstPersonCamera
 from src.core.collision import AABB, CollisionWorld
 from src.core.input_handler import InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.player.player import Player
 from src.projectiles.physics import ProjectilePhysicsSystem
 from src.weapons.assault_rifle import AssaultRifle
 from src.weapons.rpg import RPG
 from src.weapons.shotgun import Shotgun
+from src.weapons.visuals import get_weapon_visual
 
 
 def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
@@ -62,6 +64,39 @@ def test_player_weapon_switch_reload_and_game_over_respawn():
     assert player.position == (1.0, 1.8, 2.0)
 
 
+def test_smooth_weapon_switch_transition_flow():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.add_weapon(Shotgun())
+    started = player.start_smooth_weapon_switch("Shotgun", now=1.0)
+    assert started is True
+    assert player.is_weapon_switching is True
+    assert player.equipped_weapon_name == "Pistol"
+    assert player.update_weapon_switch(1.1) is None
+    equipped = player.update_weapon_switch(1.21)
+    assert equipped == "Shotgun"
+    assert player.equipped_weapon_name == "Shotgun"
+    assert player.is_weapon_switching is False
+
+
+def test_player_hitscan_shooting_uses_raycasting():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    raycasting = RaycastingSystem()
+    hit = player.shoot_hitscan(
+        now=1.0,
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=30.0,
+        raycasting_system=raycasting,
+        targets=[
+            RaycastTarget(target_id="bot-a", center=(5.0, 0.0, 0.0), radius=0.6),
+            RaycastTarget(target_id="bot-b", center=(12.0, 0.0, 0.0), radius=1.0),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "bot-a"
+    assert player.equipped_weapon.ammo_in_magazine == 11
+
+
 def test_shotgun_assault_rifle_and_rpg_behaviors():
     shotgun = Shotgun()
     payload = shotgun.create_projectile_payload(
@@ -82,6 +117,13 @@ def test_shotgun_assault_rifle_and_rpg_behaviors():
     assert rpg.crash_triggered is True
 
 
+def test_weapon_visual_definitions_exist_for_progression_weapons():
+    for weapon_name in ("Pistol", "Shotgun", "AssaultRifle", "RPG"):
+        visual = get_weapon_visual(weapon_name)
+        assert visual.weapon_name == weapon_name
+        assert len(visual.primitives) > 0
+
+
 def test_projectile_system_and_collision_physics():
     world = CollisionWorld(
         world_bounds=AABB(min_corner=(-2.0, -2.0, -2.0), max_corner=(2.0, 2.0, 2.0)),
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index f2d04f6..3581570 100644
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -2,6 +2,7 @@ import pytest
 
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
+from src.core.raycasting import RaycastingSystem, RaycastTarget
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
 
@@ -19,6 +20,46 @@ def test_game_clock_tracks_delta_and_elapsed_time():
     assert clock.frame_count == 2
 
 
+def test_game_clock_pause_and_time_scale_controls():
+    clock = GameClock()
+    clock.tick(0.0)
+
+    clock.set_time_scale(0.5)
+    assert clock.tick(2.0) == 1.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 2.0
+
+    clock.set_paused(True)
+    assert clock.tick(3.0) == 0.0
+    assert clock.elapsed_time == 1.0
+    assert clock.unscaled_elapsed_time == 3.0
+
+    clock.set_paused(False)
+    assert clock.tick(5.0) == 1.0
+    assert clock.elapsed_time == 2.0
+    assert clock.frame_count == 2
+
+    with pytest.raises(ValueError):
+        clock.set_time_scale(0.0)
+
+
+def test_raycasting_system_returns_closest_valid_target():
+    system = RaycastingSystem()
+    hit = system.cast_ray(
+        origin=(0.0, 0.0, 0.0),
+        direction=(1.0, 0.0, 0.0),
+        max_distance=20.0,
+        targets=[
+            RaycastTarget(target_id="far", center=(10.0, 0.0, 0.0), radius=1.0),
+            RaycastTarget(target_id="near", center=(4.0, 0.0, 0.0), radius=0.5),
+            RaycastTarget(target_id="inactive", center=(2.0, 0.0, 0.0), radius=0.5, is_active=False),
+        ],
+    )
+    assert hit is not None
+    assert hit.target_id == "near"
+    assert hit.distance == pytest.approx(3.5)
+
+
 def test_state_manager_validates_transitions():
     manager = GameStateManager()
LLM prompt end (stdin)
Process PID: 30368
YOLO mode is enabled. All tool calls will be automatically approved.
Loaded cached credentials.
YOLO mode is enabled. All tool calls will be automatically approved.
Hook registry initialized with 0 hook entries
The commit message has been written to `.agentharness/git-commit-message.txt`.
Process exited with code 0. Output length: 290 chars.
End: 2026-02-08T18:27:59
__AGENTHARNESS_LIVE_DONE__
