AgentHarness LLM Live Output
Start: 2026-02-08T18:28:01
CWD: C:/Users/shlob/Pycharm Projects/harness-test/harness-test-4
Command: codex exec --skip-git-repo-check --full-auto --output-last-message "C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.codex_last_message.txt" --model gpt-5.3-codex -

Provider: Codex, Model: gpt-5.3-codex | Timeout: 600s
Prompt transport: stdin (678 chars)
LLM prompt begin (stdin)

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md
LLM prompt end (stdin)
Process PID: 11016
OpenAI Codex v0.98.0 (research preview)
--------
workdir: C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019c3e14-e197-7182-bb42-f6a80cc78cec
--------
user

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md

deprecated: `enable_experimental_windows_sandbox` is deprecated. Use `[features].experimental_windows_sandbox` instead.
  Enable it with `--enable experimental_windows_sandbox` or `[features].experimental_windows_sandbox` in config.toml. See https://github.com/openai/codex/blob/main/docs/config.md#feature-flags for details.
mcp startup: no servers
codex
I’m going to follow your repo workflow: first read `product-description.md`, then `recent-changes.md` and `tasks.md`, pick up to 10 unchecked tasks, and implement them with developer-guide updates in each touched folder. I’ll start by scanning those docs now.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw recent-changes.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Force' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw product-description.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tasks.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 260ms:
# Recent Changes


 succeeded in 265ms:


    Directory: C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4


Mode                 LastWriteTime         Length Name                                                                                                                                                        
----                 -------------         ------ ----                                                                                                                                                        
d-----          2/8/2026   5:53 PM                .agentharness                                                                                                                                               
d--h--          2/8/2026   6:28 PM                .git                                                                                                                                                        
d-----          2/8/2026   5:56 PM                .pytest_cache                                                                                                                                               
d-----          2/8/2026   5:54 PM                assets                                                                                                                                                      
d-----          2/8/2026   5:56 PM                config                                                                                                                                                      
d-----          2/8/2026   6:27 PM                review                                                                                                                                                      
d-----          2/8/2026   6:12 PM                src                                                                                                                                                         
d-----          2/8/2026   6:13 PM                tests                                                                                                                                                       
-a----          2/8/2026   6:26 PM            613 .gitignore                                                                                                                                                  
-a----          2/8/2026   5:39 PM           1086 AGENTS.md                                                                                                                                                   
-a----          2/8/2026   5:39 PM           1086 CLAUDE.md                                                                                                                                                   
-a----          2/8/2026   6:23 PM           3448 developer-guide.md                                                                                                                                          
-a----          2/8/2026   6:23 PM           1003 GAMEPLAY.md                                                                                                                                                 
 succeeded in 199ms:
# Product Description: FPS Bot Arena with "The Glitch"

## Overview
A First-Person Shooter (FPS) game where the player fights against waves of tactical AI bots in a multi-room indoor facility. The core loop involves combat, earning money from kills, and upgrading weapons. The game features a meta-twist ending where the final weapon, an RPG, triggers a simulated game crash (Fake BSOD/Error) upon use.

## Gameplay Mechanics
*   **Perspective:** First-Person.
*   **Controls:** Standard FPS controls (WASD + Mouse).
*   **Interaction:** Pressing 'B' opens a real-time inventory/shop wheel to buy and switch weapons.
*   **Win/Loss:**
    *   **Loss:** Player health reaches zero.
    *   **"Win":** Acquiring and firing the final RPG, triggering the "crash" ending.

## Economy & Progression
*   **Income:** Bots drop money as physical items upon death, which the player must collect.
*   **Weapon Progression:**
    1.  **Pistol:** Starting weapon.
    2.  **Shotgun:** High close-range damage.
    3.  **Assault Rifle:** Rapid fire, medium range.
    4.  **RPG (Final Weapon):** Expensive endgame item. Firing it causes a fake "Blue Screen of Death" or critical error message, effectively ending the session.
 succeeded in 199ms:
# FPS Bot Arena Implementation Tasks

## Project Setup & Architecture

- [x] Choose and document the technology stack (Python + Ursina or Web + Three.js)
- [x] Set up project structure with main folders (src, assets, config, tests)
- [x] Create root developer-guide.md documenting overall project architecture
- [x] Initialize package.json or requirements.txt with core dependencies
- [x] Set up basic project configuration files (config.py or config.js)

## Core Game Engine

- [x] Implement main game loop with frame updates and delta time handling
- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
- [x] Implement camera system with first-person perspective and mouse look controls
- [x] Create input handler for WASD movement and mouse controls
- [x] Implement player movement with collision detection
- [x] Create physics system for projectile movement and collision
- [x] Implement raycasting system for shooting mechanics
- [x] Create game clock and time management system

thinking
**Planning task selection**
codex
I’ve loaded the backlog and there are many unchecked items. Next I’m inspecting the current `src` layout and existing developer guides so I can choose a coherent set of up to 10 tasks that can be fully completed in this pass.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse src | Select-Object FullName,Length,LastWriteTime' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse tests | Select-Object FullName,Length,LastWriteTime' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -Filter developer-guide.md | Select-Object FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 261ms:

FullName                                                                                      
--------                                                                                      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\config\developer-guide.md         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\review\developer-guide.md         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\developer-guide.md            
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\developer-guide.md       
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\player\developer-guide.md     
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\projectiles\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\weapons\developer-guide.md    
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\developer-guide.md          


 succeeded in 261ms:
# Developer Guide

## Project Architecture
This project uses **Python + Ursina** for a lightweight FPS prototype.

The current codebase implements engine-agnostic gameplay foundations in pure Python:
- Core runtime loop and timing
- State machine for high-level game flow
- Clock pause/resume and time scaling controls
- Input normalization for WASD + mouse look
- First-person camera and movement/collision simulation
- Raycasting-based hit-scan traces
- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
- Projectile entities and physics for bullets, pellets, and rockets

## Directory Map
- `src/`: runtime game systems.
  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
  - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
 succeeded in 266ms:

FullName                                                                                                                                     Length LastWriteTime      
--------                                                                                                                                     ------ -------------      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__                                                                       2/8/2026 6:22:46 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\conftest.py                                                                233    2/8/2026 6:02:49 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\developer-guide.md                                                         1204   2/8/2026 6:23:36 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_advanced_combat_and_movement.py                                       5182   2/8/2026 6:22:42 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_config.py                                                             1025   2/8/2026 5:56:18 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_core_systems.py                                                       3215   2/8/2026 6:22:22 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_player_and_weapons.py                                                 3248   2/8/2026 6:05:54 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\conftest.cpython-311-pytest-9.0.2.pyc                          867    2/8/2026 6:02:54 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_advanced_combat_and_movement.cpython-311-pytest-9.0.2.pyc 34892  2/8/2026 6:22:46 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_config.cpython-311-pytest-9.0.2.pyc                       9418   2/8/2026 5:56:19 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_core_systems.cpython-311-pytest-9.0.2.pyc                 24711  2/8/2026 6:22:39 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_player_and_weapons.cpython-311-pytest-9.0.2.pyc           30359  2/8/2026 6:05:59 PM


 succeeded in 281ms:

FullName                                                                                                           Length LastWriteTime      
--------                                                                                                           ------ -------------      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core                                                      2/8/2026 6:26:01 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\player                                                    2/8/2026 6:09:10 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\projectiles                                               2/8/2026 6:15:15 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\weapons                                                   2/8/2026 6:21:41 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\.gitkeep                                           0      2/8/2026 5:54:14 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\developer-guide.md                                 1509   2/8/2026 6:23:14 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\__pycache__                                          2/8/2026 6:26:31 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\camera.py                                     628    2/8/2026 6:12:21 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\collision.py                                  1487   2/8/2026 6:18:01 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\developer-guide.md                            1760   2/8/2026 6:22:55 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\game_clock.py                                 1685   2/8/2026 6:20:58 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\game_loop.py                                  1309   2/8/2026 6:08:51 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\game_state.py                                 1448   2/8/2026 6:00:45 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\input_handler.py                              1584   2/8/2026 6:00:59 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\movement.py                                   2693   2/8/2026 6:12:34 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\raycasting.py                                 2950   2/8/2026 6:26:01 PM
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\__init__.py                                   795    2/8/2026 6:21:18 PM

thinking
**Scoping integration and inspection**
codex
I found no UI/AI/economy/environment modules yet, so the best fully-completable chunk is the Shop/Inventory UI track. I’m now reading `src` and `tests` code to align new modules with existing APIs before editing anything.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/core/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/player/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/weapons/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 225ms:
# Core Developer Guide

## Purpose
`src/core/` provides engine-level systems that are independent from rendering backends.

## Files
- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.

## Behavior Notes
- `GameStateManager` blocks invalid transitions with `ValueError`.
- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 succeeded in 224ms:
# Tests Developer Guide

## Overview
This directory contains the automated test suite for the FPS Bot Arena project.

## Testing Framework
- **Framework:** `pytest`
- **Rationale:** Standard, powerful, and easy-to-use testing framework for Python.

## Structure
- Test files should be named `test_<module_name>.py`.
- Tests should mirror the structure of the `src/` and `config/` directories where applicable.
- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.

## Current Test Modules
- `test_config.py`: validates immutable config defaults.
- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.

 succeeded in 230ms:
# Player Developer Guide

## Purpose
`src/player/` owns all player-centric gameplay state and actions.

## Files
- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.

## Key Behaviors
- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
- Health logic:
  - `apply_damage` clamps health at `0`.
  - `heal` clamps health at `max_health`.
  - `is_alive` becomes `False` at `0` health.
- Economy logic:
  - `add_money` and `spend_money` reject negative inputs.
  - `spend_money` returns `False` when balance is insufficient.
- Inventory logic:
  - Weapons are stored by name.
  - `equip_weapon` requires ownership.
 succeeded in 278ms:
# Src Developer Guide

## Purpose
`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.

## Folder Overview
- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
- `projectiles/`: projectile entities plus physics stepping and world collision checks.

## Integration Flow
1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.

 succeeded in 214ms:
# Weapons Developer Guide

## Purpose
`src/weapons/` defines weapon behavior shared across loadout items.

## Files
- `weapon.py`: base `Weapon` dataclass with ammo, fire-rate cooldown, and firing logic.
- `pistol.py`: starter `Pistol` implementation with tuned default stats.
- `shotgun.py`: close-range spread weapon with multi-pellet projectile payload.
- `assault_rifle.py`: rapid-fire automatic weapon with larger magazine.
- `rpg.py`: rocket launcher that sets a crash trigger flag when fired.
- `switching.py`: timed weapon transition state machine for smooth switching UX.
- `visuals.py`: geometric primitive visual definitions for each progression weapon.

## Key Behaviors
- `Weapon.fire(now)` returns `True` only when:
  - ammo remains in the magazine, and
  - cooldown time since last shot has elapsed.
- Successful fire events decrement `ammo_in_magazine` by exactly one.
- `Weapon.reload()` transfers reserve ammo into the magazine and returns rounds loaded.

thinking
**Inspecting input handler for key integration**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/core/input_handler.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/core/game_state.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/player/player.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/weapons/weapon.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw config/config.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 225ms:
"""Game state management for high-level flow transitions."""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum


class GameState(str, Enum):
    """Allowed top-level game states."""

    MENU = "menu"
    PLAYING = "playing"
    PAUSED = "paused"
    CRASHED = "crashed"


@dataclass
class GameStateManager:
    """Controls current state and validates state transitions."""
 succeeded in 235ms:
"""Input translation for keyboard movement and mouse look."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass(frozen=True)
class InputSnapshot:
    """Raw frame input values from platform layer."""

    pressed_keys: set[str]
    mouse_delta_x: float = 0.0
    mouse_delta_y: float = 0.0


@dataclass(frozen=True)
class InputFrame:
    """Normalized input values consumed by gameplay systems."""

 succeeded in 205ms:
"""Project-wide configuration for the FPS Bot Arena prototype.

This module centralizes tunable values so gameplay systems can import
one source of truth instead of hardcoding constants.
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class GameConfig:
    """Core configuration values for the current prototype."""

    game_title: str = "FPS Bot Arena: The Glitch"
    start_health: int = 100
    start_money: int = 0
    mouse_sensitivity: float = 40.0
    walk_speed: float = 5.0


 succeeded in 228ms:
"""Player model with health, currency, inventory, and shooting."""

from __future__ import annotations

from dataclasses import dataclass, field

from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
from src.projectiles.projectile import Projectile
from src.weapons.pistol import Pistol
from src.weapons.switching import WeaponSwitchState
from src.weapons.weapon import Weapon


@dataclass
class Player:
    """Encapsulates runtime player state and core gameplay actions."""

    max_health: int
    health: int
    money: int
 succeeded in 223ms:
"""Base weapon model used by all weapon types."""

from __future__ import annotations

from dataclasses import dataclass
from math import sqrt


Vector3 = tuple[float, float, float]


def _normalize(direction: Vector3) -> Vector3:
    length = sqrt(
        (direction[0] * direction[0])
        + (direction[1] * direction[1])
        + (direction[2] * direction[2])
    )
    if length <= 0.0:
        raise ValueError("Direction vector must be non-zero.")
    return (
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/test_player_and_weapons.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/weapons/__init__.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/core/__init__.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/test_advanced_combat_and_movement.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/test_core_systems.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 258ms:
"""Weapon definitions and shared weapon behavior."""

from src.weapons.assault_rifle import AssaultRifle
from src.weapons.pistol import Pistol
from src.weapons.rpg import RPG
from src.weapons.shotgun import Shotgun
from src.weapons.switching import WeaponSwitchState
from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
from src.weapons.weapon import Weapon

__all__ = [
    "Weapon",
    "Pistol",
    "Shotgun",
    "AssaultRifle",
    "RPG",
    "WeaponSwitchState",
    "PrimitiveVisual",
    "WeaponVisual",
    "get_weapon_visual",
 succeeded in 258ms:
import pytest

from src.player.player import Player
from src.weapons.pistol import Pistol
from src.weapons.weapon import Weapon


def test_player_starter_loadout_and_properties():
    player = Player.with_starter_loadout(start_health=100, start_money=0)

    assert player.health == 100
    assert player.money == 0
    assert player.position == (0.0, 1.8, 0.0)
    assert player.rotation == (0.0, 0.0)
    assert player.equipped_weapon_name == "Pistol"
    assert isinstance(player.equipped_weapon, Pistol)


def test_player_health_system_damage_heal_and_death():
    player = Player.with_starter_loadout(start_health=100, start_money=0)
 succeeded in 208ms:
"""Core runtime systems for FPS Bot Arena."""

from src.core.camera import FirstPersonCamera
from src.core.collision import AABB, CollisionWorld
from src.core.game_clock import GameClock
from src.core.game_loop import GameLoop
from src.core.game_state import GameState, GameStateManager
from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
from src.core.movement import PlayerMovementController
from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget

__all__ = [
    "AABB",
    "CollisionWorld",
    "FirstPersonCamera",
    "GameClock",
    "GameLoop",
    "GameState",
    "GameStateManager",
    "InputFrame",
 succeeded in 208ms:
from src.core.camera import FirstPersonCamera
from src.core.collision import AABB, CollisionWorld
from src.core.input_handler import InputHandler, InputSnapshot
from src.core.movement import PlayerMovementController
from src.core.raycasting import RaycastingSystem, RaycastTarget
from src.player.player import Player
from src.projectiles.physics import ProjectilePhysicsSystem
from src.weapons.assault_rifle import AssaultRifle
from src.weapons.rpg import RPG
from src.weapons.shotgun import Shotgun
from src.weapons.visuals import get_weapon_visual


def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
    handler = InputHandler(mouse_sensitivity=1.0)
    camera = FirstPersonCamera()
    frame = handler.build_frame(
        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
    )
    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
 succeeded in 196ms:
import pytest

from src.core.game_clock import GameClock
from src.core.game_loop import GameLoop
from src.core.raycasting import RaycastingSystem, RaycastTarget
from src.core.game_state import GameState, GameStateManager
from src.core.input_handler import InputHandler, InputSnapshot


def test_game_clock_tracks_delta_and_elapsed_time():
    clock = GameClock()

    assert clock.tick(10.0) == 0.0
    assert clock.elapsed_time == 0.0
    assert clock.frame_count == 0

    assert clock.tick(10.25) == 0.25
    assert clock.tick(10.75) == 0.5
    assert clock.elapsed_time == 0.75
    assert clock.frame_count == 2

thinking
**Planning task selection**
codex
I’m selecting 9 tasks from the Shop/Inventory UI section and implementing them end-to-end (including tests), since they’re cohesive and can be completed fully in one pass. I’ll now inspect weapon constructors to wire a safe purchase flow.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/weapons/rpg.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/weapons/pistol.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/weapons/shotgun.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw config/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/weapons/assault_rifle.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 241ms:
# Developer Guide

## Purpose
`config/` contains centralized, importable configuration for gameplay and economy values.

## Files
- `config.py`: frozen dataclass-based configuration models and exported singleton config objects.

## How To Use
- Import `GAME_CONFIG` for core player/runtime constants.
- Import `ECONOMY_CONFIG` for weapon price progression values.
- Prefer updating values here rather than scattering literals across systems.

 succeeded in 247ms:
"""Pistol weapon implementation."""

from __future__ import annotations

from src.weapons.weapon import Weapon


class Pistol(Weapon):
    """Default starter weapon with reliable semi-auto fire."""

    def __init__(self) -> None:
        super().__init__(
            name="Pistol",
            damage=20.0,
            fire_rate=3.0,
            magazine_size=12,
            reserve_ammo=48,
        )


 succeeded in 247ms:
"""Assault rifle weapon implementation."""

from __future__ import annotations

from src.weapons.weapon import Weapon


class AssaultRifle(Weapon):
    """Rapid-fire automatic weapon for mid-range combat."""

    def __init__(self) -> None:
        super().__init__(
            name="AssaultRifle",
            damage=16.0,
            fire_rate=9.0,
            magazine_size=30,
            reserve_ammo=120,
            projectile_speed=95.0,
            projectile_radius=0.07,
            projectile_kind="bullet",
 succeeded in 247ms:
"""RPG weapon implementation with special crash trigger behavior."""

from __future__ import annotations

from src.weapons.weapon import Weapon


class RPG(Weapon):
    """Endgame launcher that triggers the glitch sequence on fire."""

    def __init__(self) -> None:
        super().__init__(
            name="RPG",
            damage=200.0,
            fire_rate=0.5,
            magazine_size=1,
            reserve_ammo=3,
            projectile_speed=45.0,
            projectile_radius=0.3,
            projectile_kind="rocket",
 succeeded in 248ms:
"""Shotgun weapon implementation."""

from __future__ import annotations

import math

from src.weapons.weapon import Weapon


class Shotgun(Weapon):
    """High-damage close-range weapon with pellet spread."""

    def __init__(self) -> None:
        super().__init__(
            name="Shotgun",
            damage=12.0,
            fire_rate=1.0,
            magazine_size=8,
            reserve_ammo=32,
            projectile_speed=70.0,

thinking
**Planning modular shop wheel design**
codex
I have enough context and will implement a full `src/ui` shop wheel subsystem plus minimal core input integration and tests.  
Plan:
1. Add `src/ui/shop_wheel.py` with:
- radial layout generation for weapon slots,
- shop item catalog with prices/factories,
- wheel entry view-model containing price/ownership/equipped/affordability flags,
- open/close behavior wired to game pause/state,
- purchase-or-equip logic with money validation.
2. Add `src/ui/__init__.py` and `src/ui/developer-guide.md`.
3. Extend `src/core/input_handler.py` to detect `B` press edge and emit `toggle_shop` in `InputFrame`.
4. Add tests in `tests/test_shop_ui.py` for layout, B toggle behavior, pause/state sync, prices, affordability feedback, purchase flow, and inventory selection/equip.
5. Update developer guides (`src/core`, `src`, root, `tests`) and then update `tasks.md` and `recent-changes.md`.

thinking
**Applying input handler patch**
codex
I’m starting edits in `src/core` first to add explicit `B` toggle signaling in the normalized input frame, which the shop controller will consume.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/input_handler.py
@@ -24,2 +24,3 @@
     look_pitch: float
+    toggle_shop: bool = False
 
@@ -31,2 +32,3 @@
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
@@ -38,2 +40,4 @@
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
@@ -44,2 +48,3 @@
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
@@ -55,2 +60 @@
         return 0.0
-
apply_patch(auto_approved=true) exited 0 in 51ms:
Success. Updated the following files:
M src/core/input_handler.py
file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-

file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-


thinking
**Adding UI source files**
codex
Next I’m creating the new `src/ui` module with a radial shop layout and controller that handles open/close pausing plus purchase/equip flows.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ui/shop_wheel.py
"""Shop wheel layout and interaction logic."""

from __future__ import annotations

from dataclasses import dataclass, field
from math import cos, radians, sin
from typing import Callable

from config.config import ECONOMY_CONFIG
from src.core.game_clock import GameClock
from src.core.game_state import GameState, GameStateManager
from src.player.player import Player
from src.weapons.assault_rifle import AssaultRifle
from src.weapons.rpg import RPG
from src.weapons.shotgun import Shotgun
from src.weapons.weapon import Weapon


WeaponFactory = Callable[[], Weapon]


@dataclass(frozen=True)
class ShopCatalogItem:
    """Store-facing weapon metadata and constructor."""

    weapon_name: str
    price: int
    factory: WeaponFactory


@dataclass(frozen=True)
class ShopWheelEntry:
    """Derived UI entry consumed by rendering/HUD layer."""

    weapon_name: str
    price: int
    slot_index: int
    angle_degrees: float
    anchor_x: float
    anchor_y: float
    is_owned: bool
    is_equipped: bool
    can_afford: bool
    is_affordable_to_buy: bool


@dataclass(frozen=True)
class ShopActionResult:
    """Outcome of a shop interaction request."""

    success: bool
    action: str
    weapon_name: str | None = None
    reason: str | None = None
    amount_spent: int = 0


@dataclass
class ShopWheelLayout:
    """Generate radial placement for shop entries."""

    radius: float = 0.82
    center_x: float = 0.0
    center_y: float = 0.0
    start_angle_degrees: float = -90.0

    def build_entries(
        self,
        *,
        player: Player,
        catalog_items: list[ShopCatalogItem],
    ) -> list[ShopWheelEntry]:
        if not catalog_items:
            return []
        slot_count = len(catalog_items)
        angle_step = 360.0 / slot_count
        entries: list[ShopWheelEntry] = []
        for index, item in enumerate(catalog_items):
            angle = self.start_angle_degrees + (index * angle_step)
            theta = radians(angle)
            anchor_x = self.center_x + (self.radius * cos(theta))
            anchor_y = self.center_y + (self.radius * sin(theta))
            is_owned = item.weapon_name in player.inventory
            is_equipped = player.equipped_weapon_name == item.weapon_name
            can_afford = player.money >= item.price
            entries.append(
                ShopWheelEntry(
                    weapon_name=item.weapon_name,
                    price=item.price,
                    slot_index=index,
                    angle_degrees=angle,
                    anchor_x=anchor_x,
                    anchor_y=anchor_y,
                    is_owned=is_owned,
                    is_equipped=is_equipped,
                    can_afford=can_afford,
                    is_affordable_to_buy=(not is_owned) and can_afford,
                )
            )
        return entries


def default_shop_catalog() -> list[ShopCatalogItem]:
    """Return progression-aligned store inventory."""
    return [
        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
    ]


@dataclass
class ShopWheelController:
    """Manage shop open state and purchase/equip interactions."""

    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
    is_open: bool = False

    def __post_init__(self) -> None:
        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}

    def handle_shop_toggle(
        self,
        *,
        game_state_manager: GameStateManager,
        game_clock: GameClock,
    ) -> bool:
        """Toggle wheel visibility and synchronize pause state."""
        self.is_open = not self.is_open
        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
        return self.is_open

    def handle_input_frame(
        self,
        *,
        toggle_shop_requested: bool,
        game_state_manager: GameStateManager,
        game_clock: GameClock,
    ) -> bool:
        """Consume normalized input and return whether wheel is open."""
        if toggle_shop_requested:
            return self.handle_shop_toggle(
                game_state_manager=game_state_manager,
                game_clock=game_clock,
            )
        return self.is_open

    def close(
        self,
        *,
        game_state_manager: GameStateManager,
        game_clock: GameClock,
    ) -> None:
        if not self.is_open:
            return
        self.is_open = False
        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)

    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
        """Return render-ready entries with affordability/ownership status."""
        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)

    def purchase_or_equip(
        self,
        *,
        player: Player,
        weapon_name: str,
    ) -> ShopActionResult:
        """Buy unavailable weapon or equip owned one."""
        catalog_item = self._catalog_by_name.get(weapon_name)
        if catalog_item is None:
            return ShopActionResult(
                success=False,
                action="rejected",
                weapon_name=weapon_name,
                reason="unknown_weapon",
            )

        if weapon_name in player.inventory:
            player.equip_weapon(weapon_name)
            return ShopActionResult(
                success=True,
                action="equipped",
                weapon_name=weapon_name,
            )

        if not player.spend_money(catalog_item.price):
            return ShopActionResult(
                success=False,
                action="rejected",
                weapon_name=weapon_name,
                reason="insufficient_funds",
            )

        player.add_weapon(catalog_item.factory(), auto_equip=True)
        return ShopActionResult(
            success=True,
            action="purchased",
            weapon_name=weapon_name,
            amount_spent=catalog_item.price,
        )

    def _sync_pause_state(
        self,
        *,
        game_state_manager: GameStateManager,
        game_clock: GameClock,
    ) -> None:
        game_clock.set_paused(self.is_open)
        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
            game_state_manager.transition_to(GameState.PAUSED)
        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
            game_state_manager.transition_to(GameState.PLAYING)
apply_patch(auto_approved=true) exited 0 in 66ms:
Success. Updated the following files:
A src/ui/shop_wheel.py
file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)

file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)


thinking
**Adding init and dev guide**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ui/__init__.py
"""UI systems for menus, HUD, and the shop wheel."""

from src.ui.shop_wheel import (
    ShopActionResult,
    ShopCatalogItem,
    ShopWheelController,
    ShopWheelEntry,
    ShopWheelLayout,
    default_shop_catalog,
)

__all__ = [
    "ShopActionResult",
    "ShopCatalogItem",
    "ShopWheelController",
    "ShopWheelEntry",
    "ShopWheelLayout",
    "default_shop_catalog",
]
apply_patch(auto_approved=true) exited 0 in 81ms:
Success. Updated the following files:
A src/ui/__init__.py
file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)

file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)

codex
I’ve added the UI module itself; next I’m writing tests to prove each selected shop-wheel task is complete, then I’ll update guides and task tracking docs.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_shop_ui.py
import pytest

from src.core.game_clock import GameClock
from src.core.game_state import GameState, GameStateManager
from src.core.input_handler import InputHandler, InputSnapshot
from src.player.player import Player
from src.ui.shop_wheel import ShopWheelController


def test_shop_wheel_layout_distributes_entries_radially_with_prices():
    player = Player.with_starter_loadout(start_health=100, start_money=0)
    controller = ShopWheelController()

    entries = controller.get_entries(player)
    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
    assert [entry.price for entry in entries] == [300, 900, 2500]
    assert [entry.slot_index for entry in entries] == [0, 1, 2]
    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])


def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
    handler = InputHandler(mouse_sensitivity=1.0)
    manager = GameStateManager()
    manager.transition_to(GameState.PLAYING)
    clock = GameClock()
    clock.tick(0.0)
    controller = ShopWheelController()

    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
    assert first_press.toggle_shop is True
    assert (
        controller.handle_input_frame(
            toggle_shop_requested=first_press.toggle_shop,
            game_state_manager=manager,
            game_clock=clock,
        )
        is True
    )

    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
    assert held_press.toggle_shop is False
    assert (
        controller.handle_input_frame(
            toggle_shop_requested=held_press.toggle_shop,
            game_state_manager=manager,
            game_clock=clock,
        )
        is True
    )

    handler.build_frame(InputSnapshot(pressed_keys=set()))
    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
    assert second_press.toggle_shop is True
    assert (
        controller.handle_input_frame(
            toggle_shop_requested=second_press.toggle_shop,
            game_state_manager=manager,
            game_clock=clock,
        )
        is False
    )


def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
    manager = GameStateManager()
    manager.transition_to(GameState.PLAYING)
    clock = GameClock()
    clock.tick(1.0)
    controller = ShopWheelController()

    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
    assert controller.is_open is True
    assert manager.current_state == GameState.PAUSED
    assert clock.is_paused is True

    delta = clock.tick(2.0)
    assert delta == 0.0

    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
    assert controller.is_open is False
    assert manager.current_state == GameState.PLAYING
    assert clock.is_paused is False


def test_shop_entries_show_affordability_ownership_and_equipped_flags():
    player = Player.with_starter_loadout(start_health=100, start_money=850)
    controller = ShopWheelController()
    player.equip_weapon("Pistol")

    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
    assert entries["Shotgun"].can_afford is True
    assert entries["Shotgun"].is_affordable_to_buy is True
    assert entries["AssaultRifle"].can_afford is False
    assert entries["AssaultRifle"].is_affordable_to_buy is False
    assert entries["RPG"].can_afford is False
    assert entries["Pistol"].is_owned is False if "Pistol" in entries else True


def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
    player = Player.with_starter_loadout(start_health=100, start_money=350)
    controller = ShopWheelController()

    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
    assert shotgun_result.success is True
    assert shotgun_result.action == "purchased"
    assert shotgun_result.amount_spent == 300
    assert player.money == 50
    assert "Shotgun" in player.inventory
    assert player.equipped_weapon_name == "Shotgun"

    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
    assert rpg_result.success is False
    assert rpg_result.reason == "insufficient_funds"
    assert "RPG" not in player.inventory


def test_shop_selection_equips_owned_weapon_from_inventory():
    player = Player.with_starter_loadout(start_health=100, start_money=2000)
    controller = ShopWheelController()
    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
    assert player.equipped_weapon_name == "AssaultRifle"

    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
    assert equip_result.success is True
    assert equip_result.action == "equipped"
    assert player.equipped_weapon_name == "Shotgun"
apply_patch(auto_approved=true) exited 0 in 111ms:
Success. Updated the following files:
A tests/test_shop_ui.py
file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..bf95c170aeaddaaad4c1e7eb2651ce835c79c4ee
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,127 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    player.equip_weapon("Pistol")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is True
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+    assert entries["Pistol"].is_owned is False if "Pistol" in entries else True
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"

file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..bf95c170aeaddaaad4c1e7eb2651ce835c79c4ee
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,127 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    player.equip_weapon("Pistol")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is True
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+    assert entries["Pistol"].is_owned is False if "Pistol" in entries else True
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Fixing tests and adding UI dev guide**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_shop_ui.py
@@ -87,7 +87,9 @@
     controller = ShopWheelController()
-    player.equip_weapon("Pistol")
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
 
     entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
     assert entries["Shotgun"].can_afford is True
-    assert entries["Shotgun"].is_affordable_to_buy is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
     assert entries["AssaultRifle"].can_afford is False
@@ -95,3 +97,2 @@
     assert entries["RPG"].can_afford is False
-    assert entries["Pistol"].is_owned is False if "Pistol" in entries else True
 
apply_patch(auto_approved=true) exited 0 in 106ms:
Success. Updated the following files:
M tests/test_shop_ui.py
file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"

file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Creating developer guide directory**
codex
I’m now updating documentation: creating `src/ui/developer-guide.md` and refreshing ancestor guides so new shop behavior is fully described without reading code.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ui/developer-guide.md
# UI Developer Guide

## Purpose
`src/ui/` contains non-rendering UI logic for the in-game shop wheel.

## Files
- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
- `__init__.py`: package exports for shop wheel types and helpers.

## Core Concepts
- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
- `default_shop_catalog()` provides progression store inventory:
  - Shotgun (`300`)
  - AssaultRifle (`900`)
  - RPG (`2500`)
- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
  - ownership state (`is_owned`)
  - equipped state (`is_equipped`)
  - affordability state (`can_afford`, `is_affordable_to_buy`)

## Interaction Flow
1. Input layer emits a shop toggle request (from `B` key edge detection).
2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
3. Opening the shop:
  - pauses `GameClock`
  - transitions game state from `playing` to `paused`
4. Closing the shop:
  - unpauses `GameClock`
  - transitions game state from `paused` to `playing`
5. `purchase_or_equip(...)` behavior:
  - Owned weapon: equip it.
  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
  - Unowned weapon without enough money: reject with `insufficient_funds`.
apply_patch(auto_approved=true) exited 0 in 127ms:
Success. Updated the following files:
A src/ui/developer-guide.md
file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"

file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Updating developer guide formatting**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/developer-guide.md
@@ -10,2 +10,3 @@
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
@@ -19 +20,2 @@
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
apply_patch(auto_approved=true) exited 0 in 145ms:
Success. Updated the following files:
M src/developer-guide.md
file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"

file update:
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Updating developer guide on toggle detection**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/developer-guide.md
@@ -20,2 +20,3 @@
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
apply_patch(auto_approved=true) exited 0 in 176ms:
Success. Updated the following files:
M src/core/developer-guide.md
file update:
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"

file update:
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Updating developer guide**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md
@@ -15,2 +15,3 @@
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
@@ -22,2 +23,3 @@
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
@@ -41,2 +43,3 @@
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
@@ -49,2 +52,3 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
apply_patch(auto_approved=true) exited 0 in 200ms:
Success. Updated the following files:
M developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"

file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Updating developer guide with new module**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/developer-guide.md
@@ -19,2 +19,3 @@
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
apply_patch(auto_approved=true) exited 0 in 211ms:
Success. Updated the following files:
M tests/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index c994bd8a115b73790c0ff85a15e05f2353a7af2f..d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -17,6 +17,7 @@
 - `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"

file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index c994bd8a115b73790c0ff85a15e05f2353a7af2f..d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -17,6 +17,7 @@
 - `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Considering init and UI imports**
codex
I finished the code and docs for the UI/shop subsystem and will run the test suite now to verify behavior before updating `tasks.md` and `recent-changes.md`.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 693ms:
..............................                                           [100%]
30 passed in 0.08s
file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index c994bd8a115b73790c0ff85a15e05f2353a7af2f..d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -17,6 +17,7 @@
 - `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Updating and marking tasks**
codex
All tests pass. I’m now updating `tasks.md` to mark the 9 completed Shop/Inventory UI tasks and then recording a concise change log in `recent-changes.md`.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tasks.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 198ms:
# FPS Bot Arena Implementation Tasks

## Project Setup & Architecture

- [x] Choose and document the technology stack (Python + Ursina or Web + Three.js)
- [x] Set up project structure with main folders (src, assets, config, tests)
- [x] Create root developer-guide.md documenting overall project architecture
- [x] Initialize package.json or requirements.txt with core dependencies
- [x] Set up basic project configuration files (config.py or config.js)

## Core Game Engine

- [x] Implement main game loop with frame updates and delta time handling
- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
- [x] Implement camera system with first-person perspective and mouse look controls
- [x] Create input handler for WASD movement and mouse controls
- [x] Implement player movement with collision detection
- [x] Create physics system for projectile movement and collision
- [x] Implement raycasting system for shooting mechanics
- [x] Create game clock and time management system
file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index c994bd8a115b73790c0ff85a15e05f2353a7af2f..d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -17,6 +17,7 @@
 - `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Refining recent changes display**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tasks.md
@@ -47,11 +47,11 @@
 
-- [ ] Design radial/wheel menu layout for inventory and shop
-- [ ] Implement 'B' key to open and close the shop wheel
-- [ ] Create shop UI that pauses game time when open
-- [ ] Display available weapons with prices in the shop wheel
-- [ ] Implement weapon purchase logic with money validation
-- [ ] Show currently equipped weapon in the shop wheel
-- [ ] Add visual feedback for affordable vs unaffordable items
-- [ ] Implement weapon selection from inventory in the shop wheel
-- [ ] Create src/ui folder developer-guide.md
+- [x] Design radial/wheel menu layout for inventory and shop
+- [x] Implement 'B' key to open and close the shop wheel
+- [x] Create shop UI that pauses game time when open
+- [x] Display available weapons with prices in the shop wheel
+- [x] Implement weapon purchase logic with money validation
+- [x] Show currently equipped weapon in the shop wheel
+- [x] Add visual feedback for affordable vs unaffordable items
+- [x] Implement weapon selection from inventory in the shop wheel
+- [x] Create src/ui folder developer-guide.md
 
apply_patch(auto_approved=true) exited 0 in 241ms:
Success. Updated the following files:
M tasks.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tasks.md b/tasks.md
index 8fe22338f9a340171f61ba4279558cc62712a380..fccd3e05976d7ee27869a70f0a10a381f4645ea9
--- a/tasks.md
+++ b/tasks.md
@@ -45,15 +45,15 @@
 
 ## Shop/Inventory UI
 
-- [ ] Design radial/wheel menu layout for inventory and shop
-- [ ] Implement 'B' key to open and close the shop wheel
-- [ ] Create shop UI that pauses game time when open
-- [ ] Display available weapons with prices in the shop wheel
-- [ ] Implement weapon purchase logic with money validation
-- [ ] Show currently equipped weapon in the shop wheel
-- [ ] Add visual feedback for affordable vs unaffordable items
-- [ ] Implement weapon selection from inventory in the shop wheel
-- [ ] Create src/ui folder developer-guide.md
+- [x] Design radial/wheel menu layout for inventory and shop
+- [x] Implement 'B' key to open and close the shop wheel
+- [x] Create shop UI that pauses game time when open
+- [x] Display available weapons with prices in the shop wheel
+- [x] Implement weapon purchase logic with money validation
+- [x] Show currently equipped weapon in the shop wheel
+- [x] Add visual feedback for affordable vs unaffordable items
+- [x] Implement weapon selection from inventory in the shop wheel
+- [x] Create src/ui folder developer-guide.md
 
 ## Enemy AI System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index c994bd8a115b73790c0ff85a15e05f2353a7af2f..d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -17,6 +17,7 @@
 - `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"

file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tasks.md b/tasks.md
index 8fe22338f9a340171f61ba4279558cc62712a380..fccd3e05976d7ee27869a70f0a10a381f4645ea9
--- a/tasks.md
+++ b/tasks.md
@@ -45,15 +45,15 @@
 
 ## Shop/Inventory UI
 
-- [ ] Design radial/wheel menu layout for inventory and shop
-- [ ] Implement 'B' key to open and close the shop wheel
-- [ ] Create shop UI that pauses game time when open
-- [ ] Display available weapons with prices in the shop wheel
-- [ ] Implement weapon purchase logic with money validation
-- [ ] Show currently equipped weapon in the shop wheel
-- [ ] Add visual feedback for affordable vs unaffordable items
-- [ ] Implement weapon selection from inventory in the shop wheel
-- [ ] Create src/ui folder developer-guide.md
+- [x] Design radial/wheel menu layout for inventory and shop
+- [x] Implement 'B' key to open and close the shop wheel
+- [x] Create shop UI that pauses game time when open
+- [x] Display available weapons with prices in the shop wheel
+- [x] Implement weapon purchase logic with money validation
+- [x] Show currently equipped weapon in the shop wheel
+- [x] Add visual feedback for affordable vs unaffordable items
+- [x] Implement weapon selection from inventory in the shop wheel
+- [x] Create src/ui folder developer-guide.md
 
 ## Enemy AI System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index c994bd8a115b73790c0ff85a15e05f2353a7af2f..d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -17,6 +17,7 @@
 - `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Updating changelog with bullets**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\recent-changes.md
@@ -1,2 +1,21 @@
-# Recent Changes
-
+# Recent Changes
+
+- Implemented a complete shop wheel UI logic module in `src/ui/shop_wheel.py` with:
+  - radial entry layout generation,
+  - default weapon catalog and prices,
+  - ownership/equipped/affordability entry state,
+  - purchase-or-equip flow with money validation,
+  - shop open/close control that pauses `GameClock` and transitions `GameStateManager` between `playing` and `paused`.
+- Added `src/ui/__init__.py` exports and created `src/ui/developer-guide.md`.
+- Extended `src/core/input_handler.py` so `InputFrame` includes `toggle_shop`, triggered on `B` key press edges (not key hold).
+- Added `tests/test_shop_ui.py` to verify:
+  - radial slot layout and price visibility,
+  - `B` toggle behavior,
+  - pause/state synchronization while shop is open,
+  - affordability and equipped-state feedback,
+  - weapon purchasing and inventory selection/equipping.
+- Updated documentation guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `tests/developer-guide.md`
apply_patch(auto_approved=true) exited 0 in 251ms:
Success. Updated the following files:
M recent-changes.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..b8bdb931cd6ba0afe17b7f5bcb6e4d88e75538f9
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,21 @@
-# Recent Changes
-
+# Recent Changes
+
+- Implemented a complete shop wheel UI logic module in `src/ui/shop_wheel.py` with:
+  - radial entry layout generation,
+  - default weapon catalog and prices,
+  - ownership/equipped/affordability entry state,
+  - purchase-or-equip flow with money validation,
+  - shop open/close control that pauses `GameClock` and transitions `GameStateManager` between `playing` and `paused`.
+- Added `src/ui/__init__.py` exports and created `src/ui/developer-guide.md`.
+- Extended `src/core/input_handler.py` so `InputFrame` includes `toggle_shop`, triggered on `B` key press edges (not key hold).
+- Added `tests/test_shop_ui.py` to verify:
+  - radial slot layout and price visibility,
+  - `B` toggle behavior,
+  - pause/state synchronization while shop is open,
+  - affordability and equipped-state feedback,
+  - weapon purchasing and inventory selection/equipping.
+- Updated documentation guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `tests/developer-guide.md`
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tasks.md b/tasks.md
index 8fe22338f9a340171f61ba4279558cc62712a380..fccd3e05976d7ee27869a70f0a10a381f4645ea9
--- a/tasks.md
+++ b/tasks.md
@@ -45,15 +45,15 @@
 
 ## Shop/Inventory UI
 
-- [ ] Design radial/wheel menu layout for inventory and shop
-- [ ] Implement 'B' key to open and close the shop wheel
-- [ ] Create shop UI that pauses game time when open
-- [ ] Display available weapons with prices in the shop wheel
-- [ ] Implement weapon purchase logic with money validation
-- [ ] Show currently equipped weapon in the shop wheel
-- [ ] Add visual feedback for affordable vs unaffordable items
-- [ ] Implement weapon selection from inventory in the shop wheel
-- [ ] Create src/ui folder developer-guide.md
+- [x] Design radial/wheel menu layout for inventory and shop
+- [x] Implement 'B' key to open and close the shop wheel
+- [x] Create shop UI that pauses game time when open
+- [x] Display available weapons with prices in the shop wheel
+- [x] Implement weapon purchase logic with money validation
+- [x] Show currently equipped weapon in the shop wheel
+- [x] Add visual feedback for affordable vs unaffordable items
+- [x] Implement weapon selection from inventory in the shop wheel
+- [x] Create src/ui folder developer-guide.md
 
 ## Enemy AI System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index c994bd8a115b73790c0ff85a15e05f2353a7af2f..d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -17,6 +17,7 @@
 - `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"

file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..b8bdb931cd6ba0afe17b7f5bcb6e4d88e75538f9
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,21 @@
-# Recent Changes
-
+# Recent Changes
+
+- Implemented a complete shop wheel UI logic module in `src/ui/shop_wheel.py` with:
+  - radial entry layout generation,
+  - default weapon catalog and prices,
+  - ownership/equipped/affordability entry state,
+  - purchase-or-equip flow with money validation,
+  - shop open/close control that pauses `GameClock` and transitions `GameStateManager` between `playing` and `paused`.
+- Added `src/ui/__init__.py` exports and created `src/ui/developer-guide.md`.
+- Extended `src/core/input_handler.py` so `InputFrame` includes `toggle_shop`, triggered on `B` key press edges (not key hold).
+- Added `tests/test_shop_ui.py` to verify:
+  - radial slot layout and price visibility,
+  - `B` toggle behavior,
+  - pause/state synchronization while shop is open,
+  - affordability and equipped-state feedback,
+  - weapon purchasing and inventory selection/equipping.
+- Updated documentation guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `tests/developer-guide.md`
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tasks.md b/tasks.md
index 8fe22338f9a340171f61ba4279558cc62712a380..fccd3e05976d7ee27869a70f0a10a381f4645ea9
--- a/tasks.md
+++ b/tasks.md
@@ -45,15 +45,15 @@
 
 ## Shop/Inventory UI
 
-- [ ] Design radial/wheel menu layout for inventory and shop
-- [ ] Implement 'B' key to open and close the shop wheel
-- [ ] Create shop UI that pauses game time when open
-- [ ] Display available weapons with prices in the shop wheel
-- [ ] Implement weapon purchase logic with money validation
-- [ ] Show currently equipped weapon in the shop wheel
-- [ ] Add visual feedback for affordable vs unaffordable items
-- [ ] Implement weapon selection from inventory in the shop wheel
-- [ ] Create src/ui folder developer-guide.md
+- [x] Design radial/wheel menu layout for inventory and shop
+- [x] Implement 'B' key to open and close the shop wheel
+- [x] Create shop UI that pauses game time when open
+- [x] Display available weapons with prices in the shop wheel
+- [x] Implement weapon purchase logic with money validation
+- [x] Show currently equipped weapon in the shop wheel
+- [x] Add visual feedback for affordable vs unaffordable items
+- [x] Implement weapon selection from inventory in the shop wheel
+- [x] Create src/ui folder developer-guide.md
 
 ## Enemy AI System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index c994bd8a115b73790c0ff85a15e05f2353a7af2f..d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -17,6 +17,7 @@
 - `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Validating guide update compliance**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 525ms:
..............................                                           [100%]
30 passed in 0.05s
file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..b8bdb931cd6ba0afe17b7f5bcb6e4d88e75538f9
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,21 @@
-# Recent Changes
-
+# Recent Changes
+
+- Implemented a complete shop wheel UI logic module in `src/ui/shop_wheel.py` with:
+  - radial entry layout generation,
+  - default weapon catalog and prices,
+  - ownership/equipped/affordability entry state,
+  - purchase-or-equip flow with money validation,
+  - shop open/close control that pauses `GameClock` and transitions `GameStateManager` between `playing` and `paused`.
+- Added `src/ui/__init__.py` exports and created `src/ui/developer-guide.md`.
+- Extended `src/core/input_handler.py` so `InputFrame` includes `toggle_shop`, triggered on `B` key press edges (not key hold).
+- Added `tests/test_shop_ui.py` to verify:
+  - radial slot layout and price visibility,
+  - `B` toggle behavior,
+  - pause/state synchronization while shop is open,
+  - affordability and equipped-state feedback,
+  - weapon purchasing and inventory selection/equipping.
+- Updated documentation guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `tests/developer-guide.md`
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tasks.md b/tasks.md
index 8fe22338f9a340171f61ba4279558cc62712a380..fccd3e05976d7ee27869a70f0a10a381f4645ea9
--- a/tasks.md
+++ b/tasks.md
@@ -45,15 +45,15 @@
 
 ## Shop/Inventory UI
 
-- [ ] Design radial/wheel menu layout for inventory and shop
-- [ ] Implement 'B' key to open and close the shop wheel
-- [ ] Create shop UI that pauses game time when open
-- [ ] Display available weapons with prices in the shop wheel
-- [ ] Implement weapon purchase logic with money validation
-- [ ] Show currently equipped weapon in the shop wheel
-- [ ] Add visual feedback for affordable vs unaffordable items
-- [ ] Implement weapon selection from inventory in the shop wheel
-- [ ] Create src/ui folder developer-guide.md
+- [x] Design radial/wheel menu layout for inventory and shop
+- [x] Implement 'B' key to open and close the shop wheel
+- [x] Create shop UI that pauses game time when open
+- [x] Display available weapons with prices in the shop wheel
+- [x] Implement weapon purchase logic with money validation
+- [x] Show currently equipped weapon in the shop wheel
+- [x] Add visual feedback for affordable vs unaffordable items
+- [x] Implement weapon selection from inventory in the shop wheel
+- [x] Create src/ui folder developer-guide.md
 
 ## Enemy AI System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index c994bd8a115b73790c0ff85a15e05f2353a7af2f..d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -17,6 +17,7 @@
 - `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Checking for unexpected changes**
codex
I’ve completed all selected tasks and re-ran tests successfully. I’m doing one final status check to list exactly which files changed before I hand over.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'git status --short' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 195ms:
 M .agentharness/git-commit-message.txt
 D .codex_last_message.txt
 M developer-guide.md
 M recent-changes.md
 M src/core/developer-guide.md
 M src/core/input_handler.py
 M src/developer-guide.md
 M tasks.md
 M tests/developer-guide.md
?? .agentharness/live-llm/llm_20260208_182801_6a153880.log
?? src/ui/
?? tests/test_shop_ui.py
file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..b8bdb931cd6ba0afe17b7f5bcb6e4d88e75538f9
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,21 @@
-# Recent Changes
-
+# Recent Changes
+
+- Implemented a complete shop wheel UI logic module in `src/ui/shop_wheel.py` with:
+  - radial entry layout generation,
+  - default weapon catalog and prices,
+  - ownership/equipped/affordability entry state,
+  - purchase-or-equip flow with money validation,
+  - shop open/close control that pauses `GameClock` and transitions `GameStateManager` between `playing` and `paused`.
+- Added `src/ui/__init__.py` exports and created `src/ui/developer-guide.md`.
+- Extended `src/core/input_handler.py` so `InputFrame` includes `toggle_shop`, triggered on `B` key press edges (not key hold).
+- Added `tests/test_shop_ui.py` to verify:
+  - radial slot layout and price visibility,
+  - `B` toggle behavior,
+  - pause/state synchronization while shop is open,
+  - affordability and equipped-state feedback,
+  - weapon purchasing and inventory selection/equipping.
+- Updated documentation guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `tests/developer-guide.md`
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tasks.md b/tasks.md
index 8fe22338f9a340171f61ba4279558cc62712a380..fccd3e05976d7ee27869a70f0a10a381f4645ea9
--- a/tasks.md
+++ b/tasks.md
@@ -45,15 +45,15 @@
 
 ## Shop/Inventory UI
 
-- [ ] Design radial/wheel menu layout for inventory and shop
-- [ ] Implement 'B' key to open and close the shop wheel
-- [ ] Create shop UI that pauses game time when open
-- [ ] Display available weapons with prices in the shop wheel
-- [ ] Implement weapon purchase logic with money validation
-- [ ] Show currently equipped weapon in the shop wheel
-- [ ] Add visual feedback for affordable vs unaffordable items
-- [ ] Implement weapon selection from inventory in the shop wheel
-- [ ] Create src/ui folder developer-guide.md
+- [x] Design radial/wheel menu layout for inventory and shop
+- [x] Implement 'B' key to open and close the shop wheel
+- [x] Create shop UI that pauses game time when open
+- [x] Display available weapons with prices in the shop wheel
+- [x] Implement weapon purchase logic with money validation
+- [x] Show currently equipped weapon in the shop wheel
+- [x] Add visual feedback for affordable vs unaffordable items
+- [x] Implement weapon selection from inventory in the shop wheel
+- [x] Create src/ui folder developer-guide.md
 
 ## Enemy AI System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index c994bd8a115b73790c0ff85a15e05f2353a7af2f..d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -17,6 +17,7 @@
 - `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"


thinking
**Noticing unrelated workspace changes**
codex
Implemented 9 incomplete tasks from `tasks.md` (all from **Shop/Inventory UI**) and marked them complete.

Completed tasks:
1. Design radial/wheel menu layout for inventory and shop
2. Implement `B` key to open/close shop wheel
3. Create shop UI that pauses game time when open
4. Display available weapons with prices in shop wheel
5. Implement weapon purchase logic with money validation
6. Show currently equipped weapon in shop wheel
7. Add visual feedback for affordable vs unaffordable items
8. Implement weapon selection from inventory in shop wheel
9. Create `src/ui` folder `developer-guide.md`

What was added/updated:
- New shop UI module: `src/ui/shop_wheel.py`
- New UI exports: `src/ui/__init__.py`
- New UI guide: `src/ui/developer-guide.md`
- Input integration (`B` edge-trigger): `src/core/input_handler.py`
- New tests: `tests/test_shop_ui.py`
- Updated guides:
  - `developer-guide.md`
  - `src/developer-guide.md`
  - `src/core/developer-guide.md`
  - `tests/developer-guide.md`
- Updated tracking docs:
  - `tasks.md` (9 tasks checked)
  - `recent-changes.md` (detailed change log added)

Validation:
- Ran test suite: `30 passed in 0.05s`

Notes:
- No additional new tasks were identified that needed to be added to `tasks.md`.
- I left unrelated workspace changes outside this scope untouched (e.g., `.agentharness/*`, `.codex_last_message.txt`).
file update:
diff --git a/developer-guide.md b/developer-guide.md
index bed6307a499756adf4eb394b824402b8ca9fdce8..26b87cae1398535b0cc85be7a198ecc10a4e1431
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -13,6 +13,7 @@
 - Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
+- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -20,6 +21,7 @@
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
+  - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -39,6 +41,7 @@
 - `GameClock` supports time scaling and pause/resume without losing wall-clock tracking.
 - `GameStateManager` enforces valid transitions across `menu`, `playing`, `paused`, and `crashed`.
 - `InputHandler.build_frame(...)` translates keyboard/mouse input into movement/look axes.
+- `InputHandler.build_frame(...)` also emits one-shot `toggle_shop` actions for `B` key presses.
 - `FirstPersonCamera` tracks yaw/pitch and clamps vertical look.
 - `PlayerMovementController` applies yaw-relative movement and resolves AABB wall collisions with slide behavior.
 - `RaycastingSystem` resolves nearest-target line traces for hit-scan shooting paths.
@@ -47,6 +50,7 @@
 - `Pistol`, `Shotgun`, `AssaultRifle`, and `RPG` provide progression-ready weapon behavior; RPG toggles a crash trigger flag when fired.
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
+- `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..b8bdb931cd6ba0afe17b7f5bcb6e4d88e75538f9
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,21 @@
-# Recent Changes
-
+# Recent Changes
+
+- Implemented a complete shop wheel UI logic module in `src/ui/shop_wheel.py` with:
+  - radial entry layout generation,
+  - default weapon catalog and prices,
+  - ownership/equipped/affordability entry state,
+  - purchase-or-equip flow with money validation,
+  - shop open/close control that pauses `GameClock` and transitions `GameStateManager` between `playing` and `paused`.
+- Added `src/ui/__init__.py` exports and created `src/ui/developer-guide.md`.
+- Extended `src/core/input_handler.py` so `InputFrame` includes `toggle_shop`, triggered on `B` key press edges (not key hold).
+- Added `tests/test_shop_ui.py` to verify:
+  - radial slot layout and price visibility,
+  - `B` toggle behavior,
+  - pause/state synchronization while shop is open,
+  - affordability and equipped-state feedback,
+  - weapon purchasing and inventory selection/equipping.
+- Updated documentation guides to reflect current behavior:
+  - `developer-guide.md`
+  - `src/developer-guide.md`
+  - `src/core/developer-guide.md`
+  - `tests/developer-guide.md`
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 102838a669b88c86f57f85187b15f4f90e8ec78c..17eddafeb8adfdad331dcb5c166e8ac39657e199
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -18,6 +18,7 @@
 - `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
 - `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
 - Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
+- Input frames include `toggle_shop`, triggered only on `B` key press edges (held key does not retrigger).
 - Camera pitch is clamped to avoid flipping.
 - Movement uses local input (`WASD`) transformed by yaw into world-space direction.
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
diff --git a/src/core/input_handler.py b/src/core/input_handler.py
index 31a251d67b16c01cbf966b82bc13bbe865032bc0..ee0dd5fd2d28ffa9ca0aab15437ae3e58bb164dc
--- a/src/core/input_handler.py
+++ b/src/core/input_handler.py
@@ -22,6 +22,7 @@
     move_z: float
     look_yaw: float
     look_pitch: float
+    toggle_shop: bool = False
 
 
 class InputHandler:
@@ -29,6 +30,7 @@
 
     def __init__(self, mouse_sensitivity: float) -> None:
         self.mouse_sensitivity = mouse_sensitivity
+        self._previous_pressed_keys: set[str] = set()
 
     def build_frame(self, snapshot: InputSnapshot) -> InputFrame:
         """Compute movement axis values and scaled look deltas."""
@@ -36,12 +38,15 @@
         move_z = self._axis(snapshot.pressed_keys, positive="w", negative="s")
         look_yaw = snapshot.mouse_delta_x * self.mouse_sensitivity
         look_pitch = -snapshot.mouse_delta_y * self.mouse_sensitivity
+        toggle_shop = "b" in snapshot.pressed_keys and "b" not in self._previous_pressed_keys
+        self._previous_pressed_keys = set(snapshot.pressed_keys)
 
         return InputFrame(
             move_x=move_x,
             move_z=move_z,
             look_yaw=look_yaw,
             look_pitch=look_pitch,
+            toggle_shop=toggle_shop,
         )
 
     @staticmethod
@@ -53,4 +58,3 @@
         if negative in keys:
             return -1.0
         return 0.0
-
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c459e0f0f049744750b8da9632016ea262601070..e4a6615b169e125e195549e5ebb46782408ff362
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -8,6 +8,7 @@
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
+- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -17,3 +18,4 @@
 5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
+8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
diff --git a/src/ui/__init__.py b/src/ui/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..73381c2364e70d067d4c623b4ca5509662ce61db
--- /dev/null
+++ b/src/ui/__init__.py
@@ -0,0 +1,19 @@
+"""UI systems for menus, HUD, and the shop wheel."""
+
+from src.ui.shop_wheel import (
+    ShopActionResult,
+    ShopCatalogItem,
+    ShopWheelController,
+    ShopWheelEntry,
+    ShopWheelLayout,
+    default_shop_catalog,
+)
+
+__all__ = [
+    "ShopActionResult",
+    "ShopCatalogItem",
+    "ShopWheelController",
+    "ShopWheelEntry",
+    "ShopWheelLayout",
+    "default_shop_catalog",
+]
diff --git a/src/ui/developer-guide.md b/src/ui/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..f1886b3c4dd4d6960beef0b0773e15d63be841bf
--- /dev/null
+++ b/src/ui/developer-guide.md
@@ -0,0 +1,34 @@
+# UI Developer Guide
+
+## Purpose
+`src/ui/` contains non-rendering UI logic for the in-game shop wheel.
+
+## Files
+- `shop_wheel.py`: radial shop layout, catalog definitions, open/close state control, pause synchronization, and purchase/equip interactions.
+- `__init__.py`: package exports for shop wheel types and helpers.
+
+## Core Concepts
+- `ShopCatalogItem` defines a weapon listing with `weapon_name`, `price`, and a weapon factory.
+- `default_shop_catalog()` provides progression store inventory:
+  - Shotgun (`300`)
+  - AssaultRifle (`900`)
+  - RPG (`2500`)
+- `ShopWheelLayout.build_entries(...)` converts catalog items into render-ready `ShopWheelEntry` objects with:
+  - radial slot position (`angle_degrees`, `anchor_x`, `anchor_y`)
+  - ownership state (`is_owned`)
+  - equipped state (`is_equipped`)
+  - affordability state (`can_afford`, `is_affordable_to_buy`)
+
+## Interaction Flow
+1. Input layer emits a shop toggle request (from `B` key edge detection).
+2. `ShopWheelController.handle_input_frame(...)` toggles `is_open` when requested.
+3. Opening the shop:
+  - pauses `GameClock`
+  - transitions game state from `playing` to `paused`
+4. Closing the shop:
+  - unpauses `GameClock`
+  - transitions game state from `paused` to `playing`
+5. `purchase_or_equip(...)` behavior:
+  - Owned weapon: equip it.
+  - Unowned weapon with enough money: spend price, instantiate weapon, add to inventory, auto-equip.
+  - Unowned weapon without enough money: reject with `insufficient_funds`.
diff --git a/src/ui/shop_wheel.py b/src/ui/shop_wheel.py
new file mode 100644
index 0000000000000000000000000000000000000000..14a8878681f0bb4824ee6caeec863c46659b514d
--- /dev/null
+++ b/src/ui/shop_wheel.py
@@ -0,0 +1,214 @@
+"""Shop wheel layout and interaction logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import cos, radians, sin
+from typing import Callable
+
+from config.config import ECONOMY_CONFIG
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.player.player import Player
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.rpg import RPG
+from src.weapons.shotgun import Shotgun
+from src.weapons.weapon import Weapon
+
+
+WeaponFactory = Callable[[], Weapon]
+
+
+@dataclass(frozen=True)
+class ShopCatalogItem:
+    """Store-facing weapon metadata and constructor."""
+
+    weapon_name: str
+    price: int
+    factory: WeaponFactory
+
+
+@dataclass(frozen=True)
+class ShopWheelEntry:
+    """Derived UI entry consumed by rendering/HUD layer."""
+
+    weapon_name: str
+    price: int
+    slot_index: int
+    angle_degrees: float
+    anchor_x: float
+    anchor_y: float
+    is_owned: bool
+    is_equipped: bool
+    can_afford: bool
+    is_affordable_to_buy: bool
+
+
+@dataclass(frozen=True)
+class ShopActionResult:
+    """Outcome of a shop interaction request."""
+
+    success: bool
+    action: str
+    weapon_name: str | None = None
+    reason: str | None = None
+    amount_spent: int = 0
+
+
+@dataclass
+class ShopWheelLayout:
+    """Generate radial placement for shop entries."""
+
+    radius: float = 0.82
+    center_x: float = 0.0
+    center_y: float = 0.0
+    start_angle_degrees: float = -90.0
+
+    def build_entries(
+        self,
+        *,
+        player: Player,
+        catalog_items: list[ShopCatalogItem],
+    ) -> list[ShopWheelEntry]:
+        if not catalog_items:
+            return []
+        slot_count = len(catalog_items)
+        angle_step = 360.0 / slot_count
+        entries: list[ShopWheelEntry] = []
+        for index, item in enumerate(catalog_items):
+            angle = self.start_angle_degrees + (index * angle_step)
+            theta = radians(angle)
+            anchor_x = self.center_x + (self.radius * cos(theta))
+            anchor_y = self.center_y + (self.radius * sin(theta))
+            is_owned = item.weapon_name in player.inventory
+            is_equipped = player.equipped_weapon_name == item.weapon_name
+            can_afford = player.money >= item.price
+            entries.append(
+                ShopWheelEntry(
+                    weapon_name=item.weapon_name,
+                    price=item.price,
+                    slot_index=index,
+                    angle_degrees=angle,
+                    anchor_x=anchor_x,
+                    anchor_y=anchor_y,
+                    is_owned=is_owned,
+                    is_equipped=is_equipped,
+                    can_afford=can_afford,
+                    is_affordable_to_buy=(not is_owned) and can_afford,
+                )
+            )
+        return entries
+
+
+def default_shop_catalog() -> list[ShopCatalogItem]:
+    """Return progression-aligned store inventory."""
+    return [
+        ShopCatalogItem("Shotgun", ECONOMY_CONFIG.shotgun_price, Shotgun),
+        ShopCatalogItem("AssaultRifle", ECONOMY_CONFIG.assault_rifle_price, AssaultRifle),
+        ShopCatalogItem("RPG", ECONOMY_CONFIG.rpg_price, RPG),
+    ]
+
+
+@dataclass
+class ShopWheelController:
+    """Manage shop open state and purchase/equip interactions."""
+
+    catalog_items: list[ShopCatalogItem] = field(default_factory=default_shop_catalog)
+    layout: ShopWheelLayout = field(default_factory=ShopWheelLayout)
+    is_open: bool = False
+
+    def __post_init__(self) -> None:
+        self._catalog_by_name = {item.weapon_name: item for item in self.catalog_items}
+
+    def handle_shop_toggle(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Toggle wheel visibility and synchronize pause state."""
+        self.is_open = not self.is_open
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+        return self.is_open
+
+    def handle_input_frame(
+        self,
+        *,
+        toggle_shop_requested: bool,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> bool:
+        """Consume normalized input and return whether wheel is open."""
+        if toggle_shop_requested:
+            return self.handle_shop_toggle(
+                game_state_manager=game_state_manager,
+                game_clock=game_clock,
+            )
+        return self.is_open
+
+    def close(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        if not self.is_open:
+            return
+        self.is_open = False
+        self._sync_pause_state(game_state_manager=game_state_manager, game_clock=game_clock)
+
+    def get_entries(self, player: Player) -> list[ShopWheelEntry]:
+        """Return render-ready entries with affordability/ownership status."""
+        return self.layout.build_entries(player=player, catalog_items=self.catalog_items)
+
+    def purchase_or_equip(
+        self,
+        *,
+        player: Player,
+        weapon_name: str,
+    ) -> ShopActionResult:
+        """Buy unavailable weapon or equip owned one."""
+        catalog_item = self._catalog_by_name.get(weapon_name)
+        if catalog_item is None:
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="unknown_weapon",
+            )
+
+        if weapon_name in player.inventory:
+            player.equip_weapon(weapon_name)
+            return ShopActionResult(
+                success=True,
+                action="equipped",
+                weapon_name=weapon_name,
+            )
+
+        if not player.spend_money(catalog_item.price):
+            return ShopActionResult(
+                success=False,
+                action="rejected",
+                weapon_name=weapon_name,
+                reason="insufficient_funds",
+            )
+
+        player.add_weapon(catalog_item.factory(), auto_equip=True)
+        return ShopActionResult(
+            success=True,
+            action="purchased",
+            weapon_name=weapon_name,
+            amount_spent=catalog_item.price,
+        )
+
+    def _sync_pause_state(
+        self,
+        *,
+        game_state_manager: GameStateManager,
+        game_clock: GameClock,
+    ) -> None:
+        game_clock.set_paused(self.is_open)
+        if self.is_open and game_state_manager.current_state == GameState.PLAYING:
+            game_state_manager.transition_to(GameState.PAUSED)
+        elif (not self.is_open) and game_state_manager.current_state == GameState.PAUSED:
+            game_state_manager.transition_to(GameState.PLAYING)
diff --git a/tasks.md b/tasks.md
index 8fe22338f9a340171f61ba4279558cc62712a380..fccd3e05976d7ee27869a70f0a10a381f4645ea9
--- a/tasks.md
+++ b/tasks.md
@@ -45,15 +45,15 @@
 
 ## Shop/Inventory UI
 
-- [ ] Design radial/wheel menu layout for inventory and shop
-- [ ] Implement 'B' key to open and close the shop wheel
-- [ ] Create shop UI that pauses game time when open
-- [ ] Display available weapons with prices in the shop wheel
-- [ ] Implement weapon purchase logic with money validation
-- [ ] Show currently equipped weapon in the shop wheel
-- [ ] Add visual feedback for affordable vs unaffordable items
-- [ ] Implement weapon selection from inventory in the shop wheel
-- [ ] Create src/ui folder developer-guide.md
+- [x] Design radial/wheel menu layout for inventory and shop
+- [x] Implement 'B' key to open and close the shop wheel
+- [x] Create shop UI that pauses game time when open
+- [x] Display available weapons with prices in the shop wheel
+- [x] Implement weapon purchase logic with money validation
+- [x] Show currently equipped weapon in the shop wheel
+- [x] Add visual feedback for affordable vs unaffordable items
+- [x] Implement weapon selection from inventory in the shop wheel
+- [x] Create src/ui folder developer-guide.md
 
 ## Enemy AI System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index c994bd8a115b73790c0ff85a15e05f2353a7af2f..d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -17,6 +17,7 @@
 - `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
+- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_shop_ui.py b/tests/test_shop_ui.py
new file mode 100644
index 0000000000000000000000000000000000000000..eccde8f05fc51b1884a74fd73d874e36e6d835a8
--- /dev/null
+++ b/tests/test_shop_ui.py
@@ -0,0 +1,128 @@
+import pytest
+
+from src.core.game_clock import GameClock
+from src.core.game_state import GameState, GameStateManager
+from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
+from src.ui.shop_wheel import ShopWheelController
+
+
+def test_shop_wheel_layout_distributes_entries_radially_with_prices():
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    controller = ShopWheelController()
+
+    entries = controller.get_entries(player)
+    assert [entry.weapon_name for entry in entries] == ["Shotgun", "AssaultRifle", "RPG"]
+    assert [entry.price for entry in entries] == [300, 900, 2500]
+    assert [entry.slot_index for entry in entries] == [0, 1, 2]
+    assert [entry.angle_degrees for entry in entries] == pytest.approx([-90.0, 30.0, 150.0])
+
+
+def test_b_key_toggle_opens_and_closes_shop_wheel_once_per_press():
+    handler = InputHandler(mouse_sensitivity=1.0)
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(0.0)
+    controller = ShopWheelController()
+
+    first_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert first_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=first_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    held_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert held_press.toggle_shop is False
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=held_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is True
+    )
+
+    handler.build_frame(InputSnapshot(pressed_keys=set()))
+    second_press = handler.build_frame(InputSnapshot(pressed_keys={"b"}))
+    assert second_press.toggle_shop is True
+    assert (
+        controller.handle_input_frame(
+            toggle_shop_requested=second_press.toggle_shop,
+            game_state_manager=manager,
+            game_clock=clock,
+        )
+        is False
+    )
+
+
+def test_open_shop_pauses_time_and_moves_state_to_paused_then_resumes():
+    manager = GameStateManager()
+    manager.transition_to(GameState.PLAYING)
+    clock = GameClock()
+    clock.tick(1.0)
+    controller = ShopWheelController()
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is True
+    assert manager.current_state == GameState.PAUSED
+    assert clock.is_paused is True
+
+    delta = clock.tick(2.0)
+    assert delta == 0.0
+
+    controller.handle_shop_toggle(game_state_manager=manager, game_clock=clock)
+    assert controller.is_open is False
+    assert manager.current_state == GameState.PLAYING
+    assert clock.is_paused is False
+
+
+def test_shop_entries_show_affordability_ownership_and_equipped_flags():
+    player = Player.with_starter_loadout(start_health=100, start_money=850)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+
+    entries = {entry.weapon_name: entry for entry in controller.get_entries(player)}
+    assert entries["Shotgun"].is_owned is True
+    assert entries["Shotgun"].is_equipped is True
+    assert entries["Shotgun"].can_afford is True
+    assert entries["Shotgun"].is_affordable_to_buy is False
+    assert entries["AssaultRifle"].can_afford is False
+    assert entries["AssaultRifle"].is_affordable_to_buy is False
+    assert entries["RPG"].can_afford is False
+
+
+def test_purchase_logic_buys_when_affordable_and_rejects_otherwise():
+    player = Player.with_starter_loadout(start_health=100, start_money=350)
+    controller = ShopWheelController()
+
+    shotgun_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert shotgun_result.success is True
+    assert shotgun_result.action == "purchased"
+    assert shotgun_result.amount_spent == 300
+    assert player.money == 50
+    assert "Shotgun" in player.inventory
+    assert player.equipped_weapon_name == "Shotgun"
+
+    rpg_result = controller.purchase_or_equip(player=player, weapon_name="RPG")
+    assert rpg_result.success is False
+    assert rpg_result.reason == "insufficient_funds"
+    assert "RPG" not in player.inventory
+
+
+def test_shop_selection_equips_owned_weapon_from_inventory():
+    player = Player.with_starter_loadout(start_health=100, start_money=2000)
+    controller = ShopWheelController()
+    controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    controller.purchase_or_equip(player=player, weapon_name="AssaultRifle")
+    assert player.equipped_weapon_name == "AssaultRifle"
+
+    equip_result = controller.purchase_or_equip(player=player, weapon_name="Shotgun")
+    assert equip_result.success is True
+    assert equip_result.action == "equipped"
+    assert player.equipped_weapon_name == "Shotgun"

tokens used
69,669
Implemented 9 incomplete tasks from `tasks.md` (all from **Shop/Inventory UI**) and marked them complete.

Completed tasks:
1. Design radial/wheel menu layout for inventory and shop
2. Implement `B` key to open/close shop wheel
3. Create shop UI that pauses game time when open
4. Display available weapons with prices in shop wheel
5. Implement weapon purchase logic with money validation
6. Show currently equipped weapon in shop wheel
7. Add visual feedback for affordable vs unaffordable items
8. Implement weapon selection from inventory in shop wheel
9. Create `src/ui` folder `developer-guide.md`

What was added/updated:
- New shop UI module: `src/ui/shop_wheel.py`
- New UI exports: `src/ui/__init__.py`
- New UI guide: `src/ui/developer-guide.md`
- Input integration (`B` edge-trigger): `src/core/input_handler.py`
- New tests: `tests/test_shop_ui.py`
- Updated guides:
  - `developer-guide.md`
  - `src/developer-guide.md`
  - `src/core/developer-guide.md`
  - `tests/developer-guide.md`
- Updated tracking docs:
  - `tasks.md` (9 tasks checked)
  - `recent-changes.md` (detailed change log added)

Validation:
- Ran test suite: `30 passed in 0.05s`

Notes:
- No additional new tasks were identified that needed to be added to `tasks.md`.
- I left unrelated workspace changes outside this scope untouched (e.g., `.agentharness/*`, `.codex_last_message.txt`).
Implemented 9 incomplete tasks from `tasks.md` (all from **Shop/Inventory UI**) and marked them complete.

Completed tasks:
1. Design radial/wheel menu layout for inventory and shop
2. Implement `B` key to open/close shop wheel
3. Create shop UI that pauses game time when open
4. Display available weapons with prices in shop wheel
5. Implement weapon purchase logic with money validation
6. Show currently equipped weapon in shop wheel
7. Add visual feedback for affordable vs unaffordable items
8. Implement weapon selection from inventory in shop wheel
9. Create `src/ui` folder `developer-guide.md`

What was added/updated:
- New shop UI module: `src/ui/shop_wheel.py`
- New UI exports: `src/ui/__init__.py`
- New UI guide: `src/ui/developer-guide.md`
- Input integration (`B` edge-trigger): `src/core/input_handler.py`
- New tests: `tests/test_shop_ui.py`
- Updated guides:
  - `developer-guide.md`
  - `src/developer-guide.md`
  - `src/core/developer-guide.md`
  - `tests/developer-guide.md`
- Updated tracking docs:
  - `tasks.md` (9 tasks checked)
  - `recent-changes.md` (detailed change log added)

Validation:
- Ran test suite: `30 passed in 0.05s`

Notes:
- No additional new tasks were identified that needed to be added to `tasks.md`.
- I left unrelated workspace changes outside this scope untouched (e.g., `.agentharness/*`, `.codex_last_message.txt`).
Process exited with code 0. Output length: 568892 chars.
End: 2026-02-08T18:31:50
__AGENTHARNESS_LIVE_DONE__
