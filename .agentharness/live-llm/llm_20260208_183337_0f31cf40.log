AgentHarness LLM Live Output
Start: 2026-02-08T18:33:37
CWD: C:/Users/shlob/Pycharm Projects/harness-test/harness-test-4
Command: codex exec --skip-git-repo-check --full-auto --output-last-message "C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.codex_last_message.txt" --model gpt-5.3-codex -

Provider: Codex, Model: gpt-5.3-codex | Timeout: 600s
Prompt transport: stdin (678 chars)
LLM prompt begin (stdin)

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md
LLM prompt end (stdin)
Process PID: 30888
OpenAI Codex v0.98.0 (research preview)
--------
workdir: C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019c3e1a-0146-7932-a5c7-3cbf7b391cdb
--------
user

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md

deprecated: `enable_experimental_windows_sandbox` is deprecated. Use `[features].experimental_windows_sandbox` instead.
  Enable it with `--enable experimental_windows_sandbox` or `[features].experimental_windows_sandbox` in config.toml. See https://github.com/openai/codex/blob/main/docs/config.md#feature-flags for details.
mcp startup: no servers
codex
I’m going to follow your workflow exactly: first I’ll read `product-description.md`, then `recent-changes.md` and `tasks.md`, pick up to 10 unchecked tasks, implement them, and finally update both tracking files. I’ll inspect the repo structure now.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path recent-changes.md) { Get-Content -Raw recent-changes.md } else { Write-Output 'MISSING: recent-changes.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path tasks.md) { Get-Content -Raw tasks.md } else { Write-Output 'MISSING: tasks.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path product-description.md) { Get-Content -Raw product-description.md } else { Write-Output 'MISSING: product-description.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Force' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 225ms:
# Recent Changes


 succeeded in 225ms:
# FPS Bot Arena Implementation Tasks

## Project Setup & Architecture

- [x] Choose and document the technology stack (Python + Ursina or Web + Three.js)
- [x] Set up project structure with main folders (src, assets, config, tests)
- [x] Create root developer-guide.md documenting overall project architecture
- [x] Initialize package.json or requirements.txt with core dependencies
- [x] Set up basic project configuration files (config.py or config.js)

## Core Game Engine

- [x] Implement main game loop with frame updates and delta time handling
- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
- [x] Implement camera system with first-person perspective and mouse look controls
- [x] Create input handler for WASD movement and mouse controls
- [x] Implement player movement with collision detection
- [x] Create physics system for projectile movement and collision
- [x] Implement raycasting system for shooting mechanics
- [x] Create game clock and time management system
 succeeded in 216ms:
# Product Description: FPS Bot Arena with "The Glitch"

## Overview
A First-Person Shooter (FPS) game where the player fights against waves of tactical AI bots in a multi-room indoor facility. The core loop involves combat, earning money from kills, and upgrading weapons. The game features a meta-twist ending where the final weapon, an RPG, triggers a simulated game crash (Fake BSOD/Error) upon use.

## Gameplay Mechanics
*   **Perspective:** First-Person.
*   **Controls:** Standard FPS controls (WASD + Mouse).
*   **Interaction:** Pressing 'B' opens a real-time inventory/shop wheel to buy and switch weapons.
*   **Win/Loss:**
    *   **Loss:** Player health reaches zero.
    *   **"Win":** Acquiring and firing the final RPG, triggering the "crash" ending.

## Economy & Progression
*   **Income:** Bots drop money as physical items upon death, which the player must collect.
*   **Weapon Progression:**
    1.  **Pistol:** Starting weapon.
    2.  **Shotgun:** High close-range damage.
    3.  **Assault Rifle:** Rapid fire, medium range.
    4.  **RPG (Final Weapon):** Expensive endgame item. Firing it causes a fake "Blue Screen of Death" or critical error message, effectively ending the session.
 succeeded in 244ms:


    Directory: C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4


Mode                 LastWriteTime         Length Name                                                                                                                                                        
----                 -------------         ------ ----                                                                                                                                                        
d-----          2/8/2026   5:53 PM                .agentharness                                                                                                                                               
d--h--          2/8/2026   6:33 PM                .git                                                                                                                                                        
d-----          2/8/2026   5:56 PM                .pytest_cache                                                                                                                                               
d-----          2/8/2026   5:54 PM                assets                                                                                                                                                      
d-----          2/8/2026   5:56 PM                config                                                                                                                                                      
d-----          2/8/2026   6:33 PM                review                                                                                                                                                      
d-----          2/8/2026   6:29 PM                src                                                                                                                                                         
d-----          2/8/2026   6:30 PM                tests                                                                                                                                                       
-a----          2/8/2026   6:26 PM            613 .gitignore                                                                                                                                                  
-a----          2/8/2026   5:39 PM           1086 AGENTS.md                                                                                                                                                   
-a----          2/8/2026   5:39 PM           1086 CLAUDE.md                                                                                                                                                   
-a----          2/8/2026   6:30 PM           3935 developer-guide.md                                                                                                                                          
-a----          2/8/2026   6:23 PM           1003 GAMEPLAY.md                                                                                                                                                 

thinking
**Selecting feasible incomplete tasks**
codex
I’ve identified the unchecked task pool. Next I’m scanning the current `src` code and per-folder `developer-guide.md` files so I can choose tasks that can be fully completed and correctly documented.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File src | Select-Object FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'rg --files src' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File -Filter developer-guide.md | Select-Object FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 214ms:
src\weapons\__init__.py
src\weapons\weapon.py
src\weapons\visuals.py
src\weapons\switching.py
src\weapons\shotgun.py
src\weapons\rpg.py
src\weapons\pistol.py
src\weapons\developer-guide.md
src\weapons\assault_rifle.py
src\ui\__init__.py
src\ui\shop_wheel.py
src\ui\developer-guide.md
src\player\__init__.py
src\player\player.py
src\player\developer-guide.md
src\developer-guide.md
src\projectiles\__init__.py
src\projectiles\projectile.py
src\projectiles\physics.py
src\projectiles\developer-guide.md
 succeeded in 271ms:

FullName                                                                                                          
--------                                                                                                          
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\.gitkeep                                          
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\developer-guide.md                                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\camera.py                                    
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\collision.py                                 
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\developer-guide.md                           
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\game_clock.py                                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\game_loop.py                                 
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\game_state.py                                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\input_handler.py                             
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\movement.py                                  
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\raycasting.py                                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\__init__.py                                  
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\__pycache__\camera.cpython-311.pyc           
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\__pycache__\collision.cpython-311.pyc        
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\__pycache__\game_clock.cpython-311.pyc       
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\__pycache__\game_loop.cpython-311.pyc        
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\__pycache__\game_state.cpython-311.pyc       
 succeeded in 257ms:
# Developer Guide

## Project Architecture
This project uses **Python + Ursina** for a lightweight FPS prototype.

The current codebase implements engine-agnostic gameplay foundations in pure Python:
- Core runtime loop and timing
- State machine for high-level game flow
- Clock pause/resume and time scaling controls
- Input normalization for WASD + mouse look
- First-person camera and movement/collision simulation
- Raycasting-based hit-scan traces
- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
- Projectile entities and physics for bullets, pellets, and rockets
- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow

## Directory Map
- `src/`: runtime game systems.
  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
 succeeded in 262ms:

FullName                                                                                      
--------                                                                                      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\config\developer-guide.md         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\review\developer-guide.md         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\developer-guide.md            
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\developer-guide.md       
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\player\developer-guide.md     
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\projectiles\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ui\developer-guide.md         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\weapons\developer-guide.md    
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\developer-guide.md          



thinking
**Preparing architecture inspection**
codex
I confirmed the current implementation scope. I’m now reading the relevant `src` modules and tests to design AI/economy additions that fit existing patterns and can be validated with tests.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/player/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/player/player.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File tests | Select-Object FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 211ms:
# Src Developer Guide

## Purpose
`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.

## Folder Overview
- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
- `projectiles/`: projectile entities plus physics stepping and world collision checks.
- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.

## Integration Flow
1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 succeeded in 211ms:
# Player Developer Guide

## Purpose
`src/player/` owns all player-centric gameplay state and actions.

## Files
- `player.py`: `Player` dataclass with health, money, transform state, inventory, and firing API.

## Key Behaviors
- `Player.with_starter_loadout(...)` spawns a player with a default `Pistol`.
- Health logic:
  - `apply_damage` clamps health at `0`.
  - `heal` clamps health at `max_health`.
  - `is_alive` becomes `False` at `0` health.
- Economy logic:
  - `add_money` and `spend_money` reject negative inputs.
  - `spend_money` returns `False` when balance is insufficient.
- Inventory logic:
  - Weapons are stored by name.
  - `equip_weapon` requires ownership.
 succeeded in 211ms:
"""Player model with health, currency, inventory, and shooting."""

from __future__ import annotations

from dataclasses import dataclass, field

from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
from src.projectiles.projectile import Projectile
from src.weapons.pistol import Pistol
from src.weapons.switching import WeaponSwitchState
from src.weapons.weapon import Weapon


@dataclass
class Player:
    """Encapsulates runtime player state and core gameplay actions."""

    max_health: int
    health: int
    money: int
 succeeded in 241ms:

FullName                                                                                                                                    
--------                                                                                                                                    
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\conftest.py                                                               
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\developer-guide.md                                                        
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_advanced_combat_and_movement.py                                      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_config.py                                                            
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_core_systems.py                                                      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_player_and_weapons.py                                                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_shop_ui.py                                                           
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\conftest.cpython-311-pytest-9.0.2.pyc                         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_advanced_combat_and_movement.cpython-311-pytest-9.0.2.pyc
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_config.cpython-311-pytest-9.0.2.pyc                      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_core_systems.cpython-311-pytest-9.0.2.pyc                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_player_and_weapons.cpython-311-pytest-9.0.2.pyc          
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_shop_ui.cpython-311-pytest-9.0.2.pyc                     



thinking
**Planning core pattern inspection**
codex
I’m now checking config and existing combat systems to wire AI and money pickup behavior consistently with current abstractions, then I’ll implement and test.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/core/collision.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/core/raycasting.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw config/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw config/config.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/weapons/weapon.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 213ms:
"""Project-wide configuration for the FPS Bot Arena prototype.

This module centralizes tunable values so gameplay systems can import
one source of truth instead of hardcoding constants.
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class GameConfig:
    """Core configuration values for the current prototype."""

    game_title: str = "FPS Bot Arena: The Glitch"
    start_health: int = 100
    start_money: int = 0
    mouse_sensitivity: float = 40.0
    walk_speed: float = 5.0


 succeeded in 227ms:
"""AABB collision primitives used by movement and projectiles."""

from __future__ import annotations

from dataclasses import dataclass


Vector3 = tuple[float, float, float]


@dataclass(frozen=True)
class AABB:
    """Axis-aligned bounding box."""

    min_corner: Vector3
    max_corner: Vector3

    def intersects(self, other: "AABB") -> bool:
        return (
            self.min_corner[0] <= other.max_corner[0]
 succeeded in 228ms:
# Developer Guide

## Purpose
`config/` contains centralized, importable configuration for gameplay and economy values.

## Files
- `config.py`: frozen dataclass-based configuration models and exported singleton config objects.

## How To Use
- Import `GAME_CONFIG` for core player/runtime constants.
- Import `ECONOMY_CONFIG` for weapon price progression values.
- Prefer updating values here rather than scattering literals across systems.

 succeeded in 233ms:
"""Raycasting primitives used for hit-scan shooting mechanics."""

from __future__ import annotations

from dataclasses import dataclass
from math import sqrt


Vector3 = tuple[float, float, float]


def _normalize(direction: Vector3) -> Vector3:
    length = sqrt(
        (direction[0] * direction[0])
        + (direction[1] * direction[1])
        + (direction[2] * direction[2])
    )
    if length <= 0.0:
        raise ValueError("Ray direction must be non-zero.")
    return (
 succeeded in 219ms:
"""Base weapon model used by all weapon types."""

from __future__ import annotations

from dataclasses import dataclass
from math import sqrt


Vector3 = tuple[float, float, float]


def _normalize(direction: Vector3) -> Vector3:
    length = sqrt(
        (direction[0] * direction[0])
        + (direction[1] * direction[1])
        + (direction[2] * direction[2])
    )
    if length <= 0.0:
        raise ValueError("Direction vector must be non-zero.")
    return (

thinking
**Planning test style review**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/test_advanced_combat_and_movement.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/test_player_and_weapons.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/test_core_systems.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 214ms:
import pytest

from src.player.player import Player
from src.weapons.pistol import Pistol
from src.weapons.weapon import Weapon


def test_player_starter_loadout_and_properties():
    player = Player.with_starter_loadout(start_health=100, start_money=0)

    assert player.health == 100
    assert player.money == 0
    assert player.position == (0.0, 1.8, 0.0)
    assert player.rotation == (0.0, 0.0)
    assert player.equipped_weapon_name == "Pistol"
    assert isinstance(player.equipped_weapon, Pistol)


def test_player_health_system_damage_heal_and_death():
    player = Player.with_starter_loadout(start_health=100, start_money=0)
 succeeded in 214ms:
from src.core.camera import FirstPersonCamera
from src.core.collision import AABB, CollisionWorld
from src.core.input_handler import InputHandler, InputSnapshot
from src.core.movement import PlayerMovementController
from src.core.raycasting import RaycastingSystem, RaycastTarget
from src.player.player import Player
from src.projectiles.physics import ProjectilePhysicsSystem
from src.weapons.assault_rifle import AssaultRifle
from src.weapons.rpg import RPG
from src.weapons.shotgun import Shotgun
from src.weapons.visuals import get_weapon_visual


def test_camera_mouse_look_uses_input_handler_and_clamps_pitch():
    handler = InputHandler(mouse_sensitivity=1.0)
    camera = FirstPersonCamera()
    frame = handler.build_frame(
        InputSnapshot(pressed_keys=set(), mouse_delta_x=12.0, mouse_delta_y=-200.0)
    )
    yaw, pitch = camera.apply_look_delta(frame.look_yaw, frame.look_pitch)
 succeeded in 214ms:
# Tests Developer Guide

## Overview
This directory contains the automated test suite for the FPS Bot Arena project.

## Testing Framework
- **Framework:** `pytest`
- **Rationale:** Standard, powerful, and easy-to-use testing framework for Python.

## Structure
- Test files should be named `test_<module_name>.py`.
- Tests should mirror the structure of the `src/` and `config/` directories where applicable.
- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.

## Current Test Modules
- `test_config.py`: validates immutable config defaults.
- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 succeeded in 202ms:
import pytest

from src.core.game_clock import GameClock
from src.core.game_loop import GameLoop
from src.core.raycasting import RaycastingSystem, RaycastTarget
from src.core.game_state import GameState, GameStateManager
from src.core.input_handler import InputHandler, InputSnapshot


def test_game_clock_tracks_delta_and_elapsed_time():
    clock = GameClock()

    assert clock.tick(10.0) == 0.0
    assert clock.elapsed_time == 0.0
    assert clock.frame_count == 0

    assert clock.tick(10.25) == 0.25
    assert clock.tick(10.75) == 0.5
    assert clock.elapsed_time == 0.75
    assert clock.frame_count == 2

thinking
**Selecting and organizing implementation tasks**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/weapons/__init__.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw src/projectiles/__init__.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw tests/conftest.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 213ms:
"""Weapon definitions and shared weapon behavior."""

from src.weapons.assault_rifle import AssaultRifle
from src.weapons.pistol import Pistol
from src.weapons.rpg import RPG
from src.weapons.shotgun import Shotgun
from src.weapons.switching import WeaponSwitchState
from src.weapons.visuals import PrimitiveVisual, WeaponVisual, get_weapon_visual
from src.weapons.weapon import Weapon

__all__ = [
    "Weapon",
    "Pistol",
    "Shotgun",
    "AssaultRifle",
    "RPG",
    "WeaponSwitchState",
    "PrimitiveVisual",
    "WeaponVisual",
    "get_weapon_visual",
 succeeded in 216ms:
"""Projectile entities and physics simulation."""

 succeeded in 220ms:
"""Pytest configuration for import resolution."""

from __future__ import annotations

import sys
from pathlib import Path


ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))



thinking
**Designing economy and AI test plan**
codex
I’ve selected 10 tasks to complete: 5 AI tasks, 4 money/economy tasks, and both new folder developer guides for `src/ai` and `src/economy`. I’m now creating the new modules and tests, then I’ll update `tasks.md`, `recent-changes.md`, and ancestor guides.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/bot.py
"""Bot runtime model with combat hooks and money-drop behavior."""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from math import sqrt
from random import Random

from src.ai.combat import vary_direction_with_accuracy
from src.economy.money import MoneyPickup, MoneyPickupSystem
from src.weapons.assault_rifle import AssaultRifle
from src.weapons.weapon import Weapon


Vector3 = tuple[float, float, float]


class BotAIState(str, Enum):
    """High-level tactical state labels for bots."""

    IDLE = "idle"
    CHASING = "chasing"
    ATTACKING = "attacking"
    SEEKING_COVER = "seeking_cover"
    FLANKING = "flanking"
    DEAD = "dead"


def _normalize(direction: Vector3) -> Vector3:
    length = sqrt(
        (direction[0] * direction[0])
        + (direction[1] * direction[1])
        + (direction[2] * direction[2])
    )
    if length <= 0.0:
        raise ValueError("Direction vector must be non-zero.")
    return (
        direction[0] / length,
        direction[1] / length,
        direction[2] / length,
    )


@dataclass
class Bot:
    """Basic tactical bot state with shooting and money-drop support."""

    bot_id: str
    max_health: int
    health: int
    position: Vector3
    ai_state: BotAIState = BotAIState.IDLE
    weapon: Weapon = field(default_factory=AssaultRifle)

    @classmethod
    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
        return cls(bot_id=bot_id, max_health=100, health=100, position=position)

    @property
    def is_alive(self) -> bool:
        return self.health > 0

    def set_state(self, state: BotAIState) -> None:
        if self.is_alive:
            self.ai_state = state

    def apply_damage(self, amount: int) -> bool:
        """Apply damage. Returns True when this call kills the bot."""
        if amount < 0:
            raise ValueError("Damage must be non-negative.")
        if not self.is_alive:
            return False
        self.health = max(0, self.health - amount)
        if self.health == 0:
            self.ai_state = BotAIState.DEAD
            return True
        return False

    def shoot_at(
        self,
        *,
        now: float,
        target_position: Vector3,
        rng: Random,
        accuracy_degrees: float = 3.0,
    ) -> tuple[bool, Vector3]:
        """Attempt to fire at target with configurable inaccuracy."""
        if not self.is_alive:
            return (False, (0.0, 0.0, 0.0))
        if accuracy_degrees < 0.0:
            raise ValueError("accuracy_degrees must be non-negative.")

        base_direction = _normalize(
            (
                target_position[0] - self.position[0],
                target_position[1] - self.position[1],
                target_position[2] - self.position[2],
            )
        )
        shot_direction = vary_direction_with_accuracy(
            direction=base_direction,
            accuracy_degrees=accuracy_degrees,
            rng=rng,
        )
        if not self.weapon.fire(now):
            return (False, shot_direction)
        return (True, shot_direction)

    def spawn_money_drop(
        self,
        *,
        pickup_system: MoneyPickupSystem,
        amount: int,
        pickup_radius: float = 0.55,
    ) -> MoneyPickup:
        """Spawn a collectible drop at this bot's position."""
        return pickup_system.spawn_pickup(
            amount=amount,
            position=self.position,
            radius=pickup_radius,
        )
apply_patch(auto_approved=true) exited 0 in 54ms:
Success. Updated the following files:
A src/ai/bot.py
file update:
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )

file update:
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )


thinking
**Adding remaining files**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/combat.py
"""Combat helpers for bot aiming and shot variance."""

from __future__ import annotations

from math import radians, sqrt, tan
from random import Random


Vector3 = tuple[float, float, float]


def _normalize(direction: Vector3) -> Vector3:
    length = sqrt(
        (direction[0] * direction[0])
        + (direction[1] * direction[1])
        + (direction[2] * direction[2])
    )
    if length <= 0.0:
        raise ValueError("Direction vector must be non-zero.")
    return (
        direction[0] / length,
        direction[1] / length,
        direction[2] / length,
    )


def _cross(a: Vector3, b: Vector3) -> Vector3:
    return (
        (a[1] * b[2]) - (a[2] * b[1]),
        (a[2] * b[0]) - (a[0] * b[2]),
        (a[0] * b[1]) - (a[1] * b[0]),
    )


def vary_direction_with_accuracy(
    *,
    direction: Vector3,
    accuracy_degrees: float,
    rng: Random,
) -> Vector3:
    """Return a normalized direction perturbed by an accuracy cone."""
    if accuracy_degrees < 0.0:
        raise ValueError("accuracy_degrees must be non-negative.")

    forward = _normalize(direction)
    max_offset = tan(radians(accuracy_degrees))
    if max_offset == 0.0:
        return forward

    up_axis = (0.0, 1.0, 0.0)
    right = _cross(forward, up_axis)
    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
    if right_length_sq < 1e-9:
        up_axis = (1.0, 0.0, 0.0)
        right = _cross(forward, up_axis)
    right = _normalize(right)
    up = _normalize(_cross(right, forward))

    offset_x = rng.uniform(-max_offset, max_offset)
    offset_y = rng.uniform(-max_offset, max_offset)
    varied = (
        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
    )
    return _normalize(varied)
apply_patch(auto_approved=true) exited 0 in 64ms:
Success. Updated the following files:
A src/ai/combat.py
file update:
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)

file update:
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)

codex
I’ve added the bot model and combat variance helpers. Next I’m adding waypoint pathfinding plus the economy pickup system, then I’ll wire exports and tests.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/navigation.py
"""Waypoint-based pathfinding helpers for bots."""

from __future__ import annotations

from collections import deque
from dataclasses import dataclass
from math import sqrt


Vector3 = tuple[float, float, float]


def _distance(a: Vector3, b: Vector3) -> float:
    dx = a[0] - b[0]
    dy = a[1] - b[1]
    dz = a[2] - b[2]
    return sqrt((dx * dx) + (dy * dy) + (dz * dz))


@dataclass
class WaypointPathfinder:
    """Graph pathfinding over named waypoints using shortest hop count."""

    waypoints: dict[str, Vector3]
    links: dict[str, list[str]]

    def nearest_waypoint(self, position: Vector3) -> str:
        if not self.waypoints:
            raise ValueError("No waypoints configured.")
        return min(
            self.waypoints.keys(),
            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
        )

    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
        """Find a path between nearest start/goal waypoints via BFS."""
        start_id = self.nearest_waypoint(start_position)
        goal_id = self.nearest_waypoint(goal_position)
        if start_id == goal_id:
            return [self.waypoints[start_id]]

        frontier: deque[str] = deque([start_id])
        came_from: dict[str, str | None] = {start_id: None}

        while frontier:
            current = frontier.popleft()
            if current == goal_id:
                break
            for neighbor in self.links.get(current, []):
                if neighbor in came_from:
                    continue
                came_from[neighbor] = current
                frontier.append(neighbor)

        if goal_id not in came_from:
            return []

        waypoint_ids: list[str] = []
        crawl: str | None = goal_id
        while crawl is not None:
            waypoint_ids.append(crawl)
            crawl = came_from[crawl]
        waypoint_ids.reverse()
        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
apply_patch(auto_approved=true) exited 0 in 82ms:
Success. Updated the following files:
A src/ai/navigation.py
file update:
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]

file update:
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/__init__.py
"""Bot AI domain models, combat helpers, and pathfinding."""

from src.ai.bot import Bot, BotAIState
from src.ai.combat import vary_direction_with_accuracy
from src.ai.navigation import WaypointPathfinder

__all__ = [
    "Bot",
    "BotAIState",
    "WaypointPathfinder",
    "vary_direction_with_accuracy",
]
apply_patch(auto_approved=true) exited 0 in 111ms:
Success. Updated the following files:
A src/ai/__init__.py
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/economy/money.py
"""Money pickup entities and collection logic."""

from __future__ import annotations

from dataclasses import dataclass, field
from math import sqrt
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from src.player.player import Player


Vector3 = tuple[float, float, float]


def _distance(a: Vector3, b: Vector3) -> float:
    dx = a[0] - b[0]
    dy = a[1] - b[1]
    dz = a[2] - b[2]
    return sqrt((dx * dx) + (dy * dy) + (dz * dz))


@dataclass(frozen=True)
class MoneyPickupVisual:
    """Simple visual definition for primitive-based money pickups."""

    primitive: str
    base_color: str
    emissive_color: str
    pulse_hz: float
    scale: tuple[float, float, float]


@dataclass
class MoneyPickup:
    """Collectible currency item dropped into the world."""

    pickup_id: str
    amount: int
    position: Vector3
    radius: float = 0.55
    ttl_seconds: float = 30.0
    age_seconds: float = 0.0
    is_active: bool = True
    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))

    def __post_init__(self) -> None:
        if self.amount <= 0:
            raise ValueError("amount must be positive.")
        if self.radius <= 0.0:
            raise ValueError("radius must be positive.")
        if self.ttl_seconds <= 0.0:
            raise ValueError("ttl_seconds must be positive.")
        if self.visual.primitive == "":
            self.visual = get_money_pickup_visual(self.amount)

    def step(self, delta_time: float) -> None:
        if delta_time < 0.0:
            raise ValueError("delta_time must be non-negative.")
        if not self.is_active:
            return
        self.age_seconds += delta_time
        if self.age_seconds >= self.ttl_seconds:
            self.is_active = False

    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
        if radius <= 0.0:
            raise ValueError("radius must be positive.")
        return _distance(self.position, center) <= (self.radius + radius)


def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
    """Return primitive visual config for a money pickup amount."""
    if amount >= 200:
        return MoneyPickupVisual(
            primitive="sphere",
            base_color="gold",
            emissive_color="yellow",
            pulse_hz=3.0,
            scale=(0.45, 0.45, 0.45),
        )
    return MoneyPickupVisual(
        primitive="cube",
        base_color="green",
        emissive_color="lime",
        pulse_hz=2.0,
        scale=(0.35, 0.35, 0.35),
    )


@dataclass
class MoneyPickupSystem:
    """Tracks spawned pickups and resolves player collection."""

    pickups: list[MoneyPickup] = field(default_factory=list)
    _next_id: int = 1

    def spawn_pickup(
        self,
        *,
        amount: int,
        position: Vector3,
        radius: float = 0.55,
        ttl_seconds: float = 30.0,
    ) -> MoneyPickup:
        pickup = MoneyPickup(
            pickup_id=f"money-{self._next_id}",
            amount=amount,
            position=position,
            radius=radius,
            ttl_seconds=ttl_seconds,
            visual=get_money_pickup_visual(amount),
        )
        self._next_id += 1
        self.pickups.append(pickup)
        return pickup

    def step(self, delta_time: float) -> None:
        for pickup in self.pickups:
            pickup.step(delta_time)
        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]

    def collect_for_player(
        self,
        *,
        player: "Player",
        player_position: Vector3,
        player_radius: float = 0.7,
    ) -> int:
        """Collect active pickups that intersect the player's pickup sphere."""
        if player_radius <= 0.0:
            raise ValueError("player_radius must be positive.")
        collected_amount = 0
        for pickup in self.pickups:
            if not pickup.is_active:
                continue
            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
                continue
            player.add_money(pickup.amount)
            collected_amount += pickup.amount
            pickup.is_active = False
        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
        return collected_amount
apply_patch(auto_approved=true) exited 0 in 128ms:
Success. Updated the following files:
A src/economy/money.py
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount


thinking
**Noting deferred visual function and missing __init__ files**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/economy/__init__.py
"""Economy models for money drops, visuals, and player pickup collection."""

from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual

__all__ = [
    "MoneyPickup",
    "MoneyPickupVisual",
    "MoneyPickupSystem",
    "get_money_pickup_visual",
]
apply_patch(auto_approved=true) exited 0 in 146ms:
Success. Updated the following files:
A src/economy/__init__.py
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount


thinking
**Planning developer and test guides**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_ai_and_economy.py
from random import Random

import pytest

from src.ai.bot import Bot, BotAIState
from src.ai.navigation import WaypointPathfinder
from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
from src.player.player import Player


def test_bot_default_state_health_and_damage_flow():
    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
    assert bot.bot_id == "bot-1"
    assert bot.health == 100
    assert bot.ai_state == BotAIState.IDLE
    assert bot.is_alive is True

    killed = bot.apply_damage(40)
    assert killed is False
    assert bot.health == 60

    killed = bot.apply_damage(60)
    assert killed is True
    assert bot.health == 0
    assert bot.ai_state == BotAIState.DEAD
    assert bot.is_alive is False

    with pytest.raises(ValueError):
        bot.apply_damage(-1)


def test_waypoint_pathfinding_uses_nearest_start_goal():
    pathfinder = WaypointPathfinder(
        waypoints={
            "a": (0.0, 0.0, 0.0),
            "b": (5.0, 0.0, 0.0),
            "c": (10.0, 0.0, 0.0),
            "d": (10.0, 0.0, 5.0),
        },
        links={
            "a": ["b"],
            "b": ["a", "c"],
            "c": ["b", "d"],
            "d": ["c"],
        },
    )
    path = pathfinder.find_path(
        start_position=(1.0, 0.0, 0.2),
        goal_position=(9.9, 0.0, 4.7),
    )
    assert path == [
        (0.0, 0.0, 0.0),
        (5.0, 0.0, 0.0),
        (10.0, 0.0, 0.0),
        (10.0, 0.0, 5.0),
    ]


def test_bot_shooting_accuracy_variance_and_cooldown():
    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
    rng = Random(1234)
    fired, direction = bot.shoot_at(
        now=1.0,
        target_position=(0.0, 0.0, 10.0),
        rng=rng,
        accuracy_degrees=5.0,
    )
    assert fired is True
    assert direction != (0.0, 0.0, 1.0)

    fired_again, _ = bot.shoot_at(
        now=1.01,
        target_position=(0.0, 0.0, 10.0),
        rng=rng,
        accuracy_degrees=5.0,
    )
    assert fired_again is False


def test_bot_death_money_drop_and_player_collection():
    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
    money_system = MoneyPickupSystem()
    player = Player.with_starter_loadout(start_health=100, start_money=0)

    bot.apply_damage(100)
    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
    assert pickup.amount == 125
    assert pickup.position == (2.0, 0.0, 2.0)
    assert len(money_system.pickups) == 1

    collected = money_system.collect_for_player(
        player=player,
        player_position=(2.1, 0.0, 2.1),
    )
    assert collected == 125
    assert player.money == 125
    assert len(money_system.pickups) == 0


def test_money_pickup_collision_and_visual_definition():
    system = MoneyPickupSystem()
    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
    assert get_money_pickup_visual(300).primitive == "sphere"
    assert get_money_pickup_visual(50).primitive == "cube"

apply_patch(auto_approved=true) exited 0 in 179ms:
Success. Updated the following files:
A tests/test_ai_and_economy.py
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+


thinking
**Planning developer guides update**
codex
I’ve finished the core implementation and tests for AI and money systems. I’m now updating the new folder guides plus ancestor guides (`src`, root, and `tests`) to reflect the new runtime behavior.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/developer-guide.md
# AI Developer Guide

## Purpose
`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.

## Files
- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
- `__init__.py`: package exports for AI modules.

## Key Behaviors
- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
apply_patch(auto_approved=true) exited 0 in 192ms:
Success. Updated the following files:
A src/ai/developer-guide.md
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/economy/developer-guide.md
# Economy Developer Guide

## Purpose
`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.

## Files
- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
- `__init__.py`: package exports for economy modules.

## Key Behaviors
- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
apply_patch(auto_approved=true) exited 0 in 208ms:
Success. Updated the following files:
A src/economy/developer-guide.md
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+


thinking
**Updating developer guide and tests**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/developer-guide.md
@@ -11,2 +11,4 @@
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
@@ -21 +23,3 @@
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
apply_patch(auto_approved=true) exited 0 in 236ms:
Success. Updated the following files:
M src/developer-guide.md
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+


thinking
**Planning file reread**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content -Raw developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 175ms:
# Developer Guide

## Project Architecture
This project uses **Python + Ursina** for a lightweight FPS prototype.

The current codebase implements engine-agnostic gameplay foundations in pure Python:
- Core runtime loop and timing
- State machine for high-level game flow
- Clock pause/resume and time scaling controls
- Input normalization for WASD + mouse look
- First-person camera and movement/collision simulation
- Raycasting-based hit-scan traces
- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
- Projectile entities and physics for bullets, pellets, and rockets
- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow

## Directory Map
- `src/`: runtime game systems.
  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+


thinking
**Applying precise patch lines**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md
@@ -16,2 +16,4 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
@@ -24,2 +26,4 @@
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
@@ -53,2 +57,5 @@
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
apply_patch(auto_approved=true) exited 0 in 258ms:
Success. Updated the following files:
M developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+


thinking
**Updating tests guide**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/developer-guide.md
@@ -20,2 +20,3 @@
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
apply_patch(auto_approved=true) exited 0 in 269ms:
Success. Updated the following files:
M tests/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+


thinking
**Planning test runs**
codex
I’m running the full test suite now to verify the new AI/economy behavior is complete before I mark tasks done.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 565ms:
...................................                                      [100%]
35 passed in 0.07s
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+


thinking
**Updating task markings**
codex
Implementation is validated (`35 passed`). I’m now updating `tasks.md` checkboxes for exactly the 10 completed items and then writing a concise `recent-changes.md` entry.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tasks.md
@@ -59,4 +59,4 @@
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
@@ -64,7 +64,7 @@
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
@@ -72,8 +72,8 @@
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
apply_patch(auto_approved=true) exited 0 in 300ms:
Success. Updated the following files:
M tasks.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+


thinking
**Updating recent-changes content**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
apply_patch(auto_approved=true) exited 0 in 315ms:
Success. Updated the following files:
M recent-changes.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..a203b2f4edde2a089b17bd1123625d61c7c5c0da
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,122 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+


thinking
**Enforcing bot death check on money spawn**
codex
I’m making one small hardening edit before finalizing: money drops will now only spawn after bot death, which aligns the implementation directly with the task wording. Then I’ll rerun tests.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/bot.py
@@ -117,2 +117,4 @@
         """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
         return pickup_system.spawn_pickup(
apply_patch(auto_approved=true) exited 0 in 316ms:
Success. Updated the following files:
M src/ai/bot.py
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..f235a07a54ef9adbe262fddbc6fd798ed025006d
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,124 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..f235a07a54ef9adbe262fddbc6fd798ed025006d
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,124 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+

exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 549ms:
...................................                                      [100%]
35 passed in 0.06s
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..f235a07a54ef9adbe262fddbc6fd798ed025006d
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,124 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..cd07d3c21a0bdfca2feddce71ca5fb881cc9be43
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,107 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"
+


thinking
**Considering test coverage for raise**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_ai_and_economy.py
@@ -84,2 +84,5 @@
 
+    with pytest.raises(ValueError):
+        bot.spawn_money_drop(pickup_system=money_system, amount=125)
+
     bot.apply_damage(100)
@@ -106,2 +109 @@
     assert get_money_pickup_visual(50).primitive == "cube"
-
apply_patch(auto_approved=true) exited 0 in 316ms:
Success. Updated the following files:
M tests/test_ai_and_economy.py
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..f235a07a54ef9adbe262fddbc6fd798ed025006d
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,124 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..bb34f0c1cd475ee007494b7d9787a2a4046156dc
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,109 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    with pytest.raises(ValueError):
+        bot.spawn_money_drop(pickup_system=money_system, amount=125)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..f235a07a54ef9adbe262fddbc6fd798ed025006d
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,124 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..bb34f0c1cd475ee007494b7d9787a2a4046156dc
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,109 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    with pytest.raises(ValueError):
+        bot.spawn_money_drop(pickup_system=money_system, amount=125)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"

exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 546ms:
...................................                                      [100%]
35 passed in 0.07s
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..f235a07a54ef9adbe262fddbc6fd798ed025006d
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,124 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..7d7bbf7e4b58466583afdfe230d49ff2abf11a2f
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..bb34f0c1cd475ee007494b7d9787a2a4046156dc
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,109 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    with pytest.raises(ValueError):
+        bot.spawn_money_drop(pickup_system=money_system, amount=125)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"


thinking
**Updating developer guide mention**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/developer-guide.md
@@ -15,3 +15,3 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
-- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem`.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
apply_patch(auto_approved=true) exited 0 in 318ms:
Success. Updated the following files:
M src/ai/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..f235a07a54ef9adbe262fddbc6fd798ed025006d
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,124 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..bb34f0c1cd475ee007494b7d9787a2a4046156dc
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,109 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    with pytest.raises(ValueError):
+        bot.spawn_money_drop(pickup_system=money_system, amount=125)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..f235a07a54ef9adbe262fddbc6fd798ed025006d
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,124 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..bb34f0c1cd475ee007494b7d9787a2a4046156dc
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,109 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    with pytest.raises(ValueError):
+        bot.spawn_money_drop(pickup_system=money_system, amount=125)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"


thinking
**Verifying task selection count**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "rg \"\\[x\\].*(Bot class|basic bot pathfinding|bot shooting mechanics|bot death handling|src/ai folder developer-guide|collectible money item|money pickup collision detection|money collection logic|visual representation for money pickups|src/economy folder developer-guide)\" tasks.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 199ms:
- [x] Create Bot class with health, position, and AI state
- [x] Implement basic bot pathfinding using navigation mesh or waypoints
- [x] Implement bot shooting mechanics with accuracy variance
- [x] Add bot death handling with money drop spawning
- [x] Create src/ai folder developer-guide.md
- [x] Create collectible money item that spawns on bot death
- [x] Implement money pickup collision detection
- [x] Add money collection logic that updates player balance
- [x] Create visual representation for money pickups (glowing cubes/spheres)
- [x] Create src/economy folder developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..f235a07a54ef9adbe262fddbc6fd798ed025006d
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,124 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..bb34f0c1cd475ee007494b7d9787a2a4046156dc
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,109 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    with pytest.raises(ValueError):
+        bot.spawn_money_drop(pickup_system=money_system, amount=125)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"


thinking
**Checking for undiscovered tasks**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'git status --short' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 193ms:
 M .agentharness/git-commit-message.txt
 D .codex_last_message.txt
 M developer-guide.md
 M recent-changes.md
 M src/developer-guide.md
 M tasks.md
 M tests/developer-guide.md
?? .agentharness/live-llm/llm_20260208_183337_0f31cf40.log
?? src/ai/
?? src/economy/
?? tests/test_ai_and_economy.py
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..f235a07a54ef9adbe262fddbc6fd798ed025006d
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,124 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..bb34f0c1cd475ee007494b7d9787a2a4046156dc
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,109 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    with pytest.raises(ValueError):
+        bot.spawn_money_drop(pickup_system=money_system, amount=125)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"


thinking
**Summarizing completed tasks**
codex
Implemented 10 incomplete tasks end-to-end, updated tracking files, and validated with tests.

**Completed work**
- Added AI bot system in `src/ai/bot.py`:
  - `Bot` model with health, position, AI state, damage/death flow.
  - Bot shooting with accuracy variance and cooldown/ammo enforcement.
  - Death-gated money drop spawning.
- Added combat variance helper in `src/ai/combat.py`.
- Added waypoint pathfinding in `src/ai/navigation.py`.
- Added economy pickup system in `src/economy/money.py`:
  - Collectible money entities.
  - Pickup collision detection.
  - Money collection into player balance.
  - Glowing primitive visual definitions (cube/sphere by amount).
- Added package exports in `src/ai/__init__.py` and `src/economy/__init__.py`.
- Added tests in `tests/test_ai_and_economy.py` covering all implemented AI/economy behaviors.
- Added/updated guides:
  - `src/ai/developer-guide.md`
  - `src/economy/developer-guide.md`
  - `src/developer-guide.md`
  - `developer-guide.md`
  - `tests/developer-guide.md`
- Updated progress tracking:
  - Marked 10 tasks as complete in `tasks.md`.
  - Logged changes in `recent-changes.md`.

**Validation**
- Ran `pytest -q`: `35 passed` (all tests green).

No additional unplanned tasks were discovered that needed adding to `tasks.md`.
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 26b87cae1398535b0cc85be7a198ecc10a4e1431..8b48de6d5a6d0d208407498a9f7d49de16abccea
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,6 +14,8 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
+- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
@@ -22,6 +24,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
 - `tests/`: automated test suite.
@@ -51,6 +55,9 @@
 - `get_weapon_visual(...)` returns geometric primitive recipes for all progression weapons.
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
+- `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..3da2a68df80ef3e7da65762904dd80e3d65e1c19
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,9 @@
-# Recent Changes
+# Recent Changes
+
+## 2026-02-08
+- Added `src/ai/` with a `Bot` runtime model, AI state enum, accuracy-variance shooting helpers, and waypoint-based pathfinding.
+- Added bot death money-drop spawning integration through a new economy pickup system.
+- Added `src/economy/` with `MoneyPickup`, pickup visuals (glowing cube/sphere), collision checks, TTL handling, spawn tracking, and player collection/balance updates.
+- Added `tests/test_ai_and_economy.py` to validate bot health/state, pathfinding, shooting variance, money drops, pickup collision, visual mapping, and collection flow.
+- Updated developer guides in `src/ai/`, `src/economy/`, `src/`, root, and `tests/` to document the new systems.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..52e964abdc34773f86ca451f900c8b5d4507cb5f
--- /dev/null
+++ b/src/ai/__init__.py
@@ -0,0 +1,12 @@
+"""Bot AI domain models, combat helpers, and pathfinding."""
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.combat import vary_direction_with_accuracy
+from src.ai.navigation import WaypointPathfinder
+
+__all__ = [
+    "Bot",
+    "BotAIState",
+    "WaypointPathfinder",
+    "vary_direction_with_accuracy",
+]
diff --git a/src/ai/bot.py b/src/ai/bot.py
new file mode 100644
index 0000000000000000000000000000000000000000..f235a07a54ef9adbe262fddbc6fd798ed025006d
--- /dev/null
+++ b/src/ai/bot.py
@@ -0,0 +1,124 @@
+"""Bot runtime model with combat hooks and money-drop behavior."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from enum import Enum
+from math import sqrt
+from random import Random
+
+from src.ai.combat import vary_direction_with_accuracy
+from src.economy.money import MoneyPickup, MoneyPickupSystem
+from src.weapons.assault_rifle import AssaultRifle
+from src.weapons.weapon import Weapon
+
+
+Vector3 = tuple[float, float, float]
+
+
+class BotAIState(str, Enum):
+    """High-level tactical state labels for bots."""
+
+    IDLE = "idle"
+    CHASING = "chasing"
+    ATTACKING = "attacking"
+    SEEKING_COVER = "seeking_cover"
+    FLANKING = "flanking"
+    DEAD = "dead"
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+@dataclass
+class Bot:
+    """Basic tactical bot state with shooting and money-drop support."""
+
+    bot_id: str
+    max_health: int
+    health: int
+    position: Vector3
+    ai_state: BotAIState = BotAIState.IDLE
+    weapon: Weapon = field(default_factory=AssaultRifle)
+
+    @classmethod
+    def create_default(cls, bot_id: str, position: Vector3) -> "Bot":
+        return cls(bot_id=bot_id, max_health=100, health=100, position=position)
+
+    @property
+    def is_alive(self) -> bool:
+        return self.health > 0
+
+    def set_state(self, state: BotAIState) -> None:
+        if self.is_alive:
+            self.ai_state = state
+
+    def apply_damage(self, amount: int) -> bool:
+        """Apply damage. Returns True when this call kills the bot."""
+        if amount < 0:
+            raise ValueError("Damage must be non-negative.")
+        if not self.is_alive:
+            return False
+        self.health = max(0, self.health - amount)
+        if self.health == 0:
+            self.ai_state = BotAIState.DEAD
+            return True
+        return False
+
+    def shoot_at(
+        self,
+        *,
+        now: float,
+        target_position: Vector3,
+        rng: Random,
+        accuracy_degrees: float = 3.0,
+    ) -> tuple[bool, Vector3]:
+        """Attempt to fire at target with configurable inaccuracy."""
+        if not self.is_alive:
+            return (False, (0.0, 0.0, 0.0))
+        if accuracy_degrees < 0.0:
+            raise ValueError("accuracy_degrees must be non-negative.")
+
+        base_direction = _normalize(
+            (
+                target_position[0] - self.position[0],
+                target_position[1] - self.position[1],
+                target_position[2] - self.position[2],
+            )
+        )
+        shot_direction = vary_direction_with_accuracy(
+            direction=base_direction,
+            accuracy_degrees=accuracy_degrees,
+            rng=rng,
+        )
+        if not self.weapon.fire(now):
+            return (False, shot_direction)
+        return (True, shot_direction)
+
+    def spawn_money_drop(
+        self,
+        *,
+        pickup_system: MoneyPickupSystem,
+        amount: int,
+        pickup_radius: float = 0.55,
+    ) -> MoneyPickup:
+        """Spawn a collectible drop at this bot's position."""
+        if self.is_alive:
+            raise ValueError("Money drops can only be spawned after bot death.")
+        return pickup_system.spawn_pickup(
+            amount=amount,
+            position=self.position,
+            radius=pickup_radius,
+        )
diff --git a/src/ai/combat.py b/src/ai/combat.py
new file mode 100644
index 0000000000000000000000000000000000000000..281783fff169903bf7438bd7b1bf73139f9f9b5d
--- /dev/null
+++ b/src/ai/combat.py
@@ -0,0 +1,66 @@
+"""Combat helpers for bot aiming and shot variance."""
+
+from __future__ import annotations
+
+from math import radians, sqrt, tan
+from random import Random
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _normalize(direction: Vector3) -> Vector3:
+    length = sqrt(
+        (direction[0] * direction[0])
+        + (direction[1] * direction[1])
+        + (direction[2] * direction[2])
+    )
+    if length <= 0.0:
+        raise ValueError("Direction vector must be non-zero.")
+    return (
+        direction[0] / length,
+        direction[1] / length,
+        direction[2] / length,
+    )
+
+
+def _cross(a: Vector3, b: Vector3) -> Vector3:
+    return (
+        (a[1] * b[2]) - (a[2] * b[1]),
+        (a[2] * b[0]) - (a[0] * b[2]),
+        (a[0] * b[1]) - (a[1] * b[0]),
+    )
+
+
+def vary_direction_with_accuracy(
+    *,
+    direction: Vector3,
+    accuracy_degrees: float,
+    rng: Random,
+) -> Vector3:
+    """Return a normalized direction perturbed by an accuracy cone."""
+    if accuracy_degrees < 0.0:
+        raise ValueError("accuracy_degrees must be non-negative.")
+
+    forward = _normalize(direction)
+    max_offset = tan(radians(accuracy_degrees))
+    if max_offset == 0.0:
+        return forward
+
+    up_axis = (0.0, 1.0, 0.0)
+    right = _cross(forward, up_axis)
+    right_length_sq = (right[0] * right[0]) + (right[1] * right[1]) + (right[2] * right[2])
+    if right_length_sq < 1e-9:
+        up_axis = (1.0, 0.0, 0.0)
+        right = _cross(forward, up_axis)
+    right = _normalize(right)
+    up = _normalize(_cross(right, forward))
+
+    offset_x = rng.uniform(-max_offset, max_offset)
+    offset_y = rng.uniform(-max_offset, max_offset)
+    varied = (
+        forward[0] + (right[0] * offset_x) + (up[0] * offset_y),
+        forward[1] + (right[1] * offset_x) + (up[1] * offset_y),
+        forward[2] + (right[2] * offset_x) + (up[2] * offset_y),
+    )
+    return _normalize(varied)
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6
--- /dev/null
+++ b/src/ai/developer-guide.md
@@ -0,0 +1,17 @@
+# AI Developer Guide
+
+## Purpose
+`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+
+## Files
+- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
+- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
+- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `__init__.py`: package exports for AI modules.
+
+## Key Behaviors
+- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
+- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
+- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
+- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
+- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
diff --git a/src/ai/navigation.py b/src/ai/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..85f29ba765e1c89c4dce19245cdd4571a048575f
--- /dev/null
+++ b/src/ai/navigation.py
@@ -0,0 +1,64 @@
+"""Waypoint-based pathfinding helpers for bots."""
+
+from __future__ import annotations
+
+from collections import deque
+from dataclasses import dataclass
+from math import sqrt
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass
+class WaypointPathfinder:
+    """Graph pathfinding over named waypoints using shortest hop count."""
+
+    waypoints: dict[str, Vector3]
+    links: dict[str, list[str]]
+
+    def nearest_waypoint(self, position: Vector3) -> str:
+        if not self.waypoints:
+            raise ValueError("No waypoints configured.")
+        return min(
+            self.waypoints.keys(),
+            key=lambda waypoint_id: _distance(position, self.waypoints[waypoint_id]),
+        )
+
+    def find_path(self, start_position: Vector3, goal_position: Vector3) -> list[Vector3]:
+        """Find a path between nearest start/goal waypoints via BFS."""
+        start_id = self.nearest_waypoint(start_position)
+        goal_id = self.nearest_waypoint(goal_position)
+        if start_id == goal_id:
+            return [self.waypoints[start_id]]
+
+        frontier: deque[str] = deque([start_id])
+        came_from: dict[str, str | None] = {start_id: None}
+
+        while frontier:
+            current = frontier.popleft()
+            if current == goal_id:
+                break
+            for neighbor in self.links.get(current, []):
+                if neighbor in came_from:
+                    continue
+                came_from[neighbor] = current
+                frontier.append(neighbor)
+
+        if goal_id not in came_from:
+            return []
+
+        waypoint_ids: list[str] = []
+        crawl: str | None = goal_id
+        while crawl is not None:
+            waypoint_ids.append(crawl)
+            crawl = came_from[crawl]
+        waypoint_ids.reverse()
+        return [self.waypoints[waypoint_id] for waypoint_id in waypoint_ids]
diff --git a/src/developer-guide.md b/src/developer-guide.md
index e4a6615b169e125e195549e5ebb46782408ff362..77e62df05372fa290a2afc515b54f59d61013a14
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,6 +9,8 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
+- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -19,3 +21,5 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
+9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/economy/__init__.py b/src/economy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a57ce4fc433638e6e2844741383bea86567d663
--- /dev/null
+++ b/src/economy/__init__.py
@@ -0,0 +1,10 @@
+"""Economy models for money drops, visuals, and player pickup collection."""
+
+from src.economy.money import MoneyPickup, MoneyPickupSystem, MoneyPickupVisual, get_money_pickup_visual
+
+__all__ = [
+    "MoneyPickup",
+    "MoneyPickupVisual",
+    "MoneyPickupSystem",
+    "get_money_pickup_visual",
+]
diff --git a/src/economy/developer-guide.md b/src/economy/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..2ff04638cf8ae33dcb739b94f7aa73409f7f2fec
--- /dev/null
+++ b/src/economy/developer-guide.md
@@ -0,0 +1,15 @@
+# Economy Developer Guide
+
+## Purpose
+`src/economy/` models world money drops, pickup visuals, collision checks, and player collection.
+
+## Files
+- `money.py`: money pickup entity, visual definitions, spawn/update lifecycle, and collection system.
+- `__init__.py`: package exports for economy modules.
+
+## Key Behaviors
+- `MoneyPickupSystem.spawn_pickup(...)` creates uniquely identified pickups with primitive visual definitions.
+- `MoneyPickup.intersects_sphere(...)` handles pickup collision checks against player pickup radius.
+- `MoneyPickupSystem.collect_for_player(...)` transfers money to the player when collisions occur and removes collected pickups.
+- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
+- `get_money_pickup_visual(amount)` returns a glowing cube for smaller amounts and glowing sphere for larger drops.
diff --git a/src/economy/money.py b/src/economy/money.py
new file mode 100644
index 0000000000000000000000000000000000000000..c43afb91a17797e1cbb535c27cbc50408b52531e
--- /dev/null
+++ b/src/economy/money.py
@@ -0,0 +1,143 @@
+"""Money pickup entities and collection logic."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from math import sqrt
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from src.player.player import Player
+
+
+Vector3 = tuple[float, float, float]
+
+
+def _distance(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dy = a[1] - b[1]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dy * dy) + (dz * dz))
+
+
+@dataclass(frozen=True)
+class MoneyPickupVisual:
+    """Simple visual definition for primitive-based money pickups."""
+
+    primitive: str
+    base_color: str
+    emissive_color: str
+    pulse_hz: float
+    scale: tuple[float, float, float]
+
+
+@dataclass
+class MoneyPickup:
+    """Collectible currency item dropped into the world."""
+
+    pickup_id: str
+    amount: int
+    position: Vector3
+    radius: float = 0.55
+    ttl_seconds: float = 30.0
+    age_seconds: float = 0.0
+    is_active: bool = True
+    visual: MoneyPickupVisual = field(default_factory=lambda: get_money_pickup_visual(0))
+
+    def __post_init__(self) -> None:
+        if self.amount <= 0:
+            raise ValueError("amount must be positive.")
+        if self.radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        if self.ttl_seconds <= 0.0:
+            raise ValueError("ttl_seconds must be positive.")
+        if self.visual.primitive == "":
+            self.visual = get_money_pickup_visual(self.amount)
+
+    def step(self, delta_time: float) -> None:
+        if delta_time < 0.0:
+            raise ValueError("delta_time must be non-negative.")
+        if not self.is_active:
+            return
+        self.age_seconds += delta_time
+        if self.age_seconds >= self.ttl_seconds:
+            self.is_active = False
+
+    def intersects_sphere(self, center: Vector3, radius: float) -> bool:
+        if radius <= 0.0:
+            raise ValueError("radius must be positive.")
+        return _distance(self.position, center) <= (self.radius + radius)
+
+
+def get_money_pickup_visual(amount: int) -> MoneyPickupVisual:
+    """Return primitive visual config for a money pickup amount."""
+    if amount >= 200:
+        return MoneyPickupVisual(
+            primitive="sphere",
+            base_color="gold",
+            emissive_color="yellow",
+            pulse_hz=3.0,
+            scale=(0.45, 0.45, 0.45),
+        )
+    return MoneyPickupVisual(
+        primitive="cube",
+        base_color="green",
+        emissive_color="lime",
+        pulse_hz=2.0,
+        scale=(0.35, 0.35, 0.35),
+    )
+
+
+@dataclass
+class MoneyPickupSystem:
+    """Tracks spawned pickups and resolves player collection."""
+
+    pickups: list[MoneyPickup] = field(default_factory=list)
+    _next_id: int = 1
+
+    def spawn_pickup(
+        self,
+        *,
+        amount: int,
+        position: Vector3,
+        radius: float = 0.55,
+        ttl_seconds: float = 30.0,
+    ) -> MoneyPickup:
+        pickup = MoneyPickup(
+            pickup_id=f"money-{self._next_id}",
+            amount=amount,
+            position=position,
+            radius=radius,
+            ttl_seconds=ttl_seconds,
+            visual=get_money_pickup_visual(amount),
+        )
+        self._next_id += 1
+        self.pickups.append(pickup)
+        return pickup
+
+    def step(self, delta_time: float) -> None:
+        for pickup in self.pickups:
+            pickup.step(delta_time)
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+
+    def collect_for_player(
+        self,
+        *,
+        player: "Player",
+        player_position: Vector3,
+        player_radius: float = 0.7,
+    ) -> int:
+        """Collect active pickups that intersect the player's pickup sphere."""
+        if player_radius <= 0.0:
+            raise ValueError("player_radius must be positive.")
+        collected_amount = 0
+        for pickup in self.pickups:
+            if not pickup.is_active:
+                continue
+            if not pickup.intersects_sphere(center=player_position, radius=player_radius):
+                continue
+            player.add_money(pickup.amount)
+            collected_amount += pickup.amount
+            pickup.is_active = False
+        self.pickups = [pickup for pickup in self.pickups if pickup.is_active]
+        return collected_amount
diff --git a/tasks.md b/tasks.md
index fccd3e05976d7ee27869a70f0a10a381f4645ea9..1aeae7b6a658dad9a82bf833415163e319055239
--- a/tasks.md
+++ b/tasks.md
@@ -57,25 +57,25 @@
 
 ## Enemy AI System
 
-- [ ] Create Bot class with health, position, and AI state
-- [ ] Implement basic bot pathfinding using navigation mesh or waypoints
+- [x] Create Bot class with health, position, and AI state
+- [x] Implement basic bot pathfinding using navigation mesh or waypoints
 - [ ] Create tactical AI decision-making system (attack, take cover, flank)
 - [ ] Implement cover detection and usage logic
 - [ ] Create flanking behavior to approach player from multiple angles
-- [ ] Implement bot shooting mechanics with accuracy variance
-- [ ] Add bot death handling with money drop spawning
+- [x] Implement bot shooting mechanics with accuracy variance
+- [x] Add bot death handling with money drop spawning
 - [ ] Create wave spawning system for multiple bots
 - [ ] Implement bot difficulty scaling across waves
-- [ ] Create src/ai folder developer-guide.md
+- [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
 
-- [ ] Create collectible money item that spawns on bot death
-- [ ] Implement money pickup collision detection
-- [ ] Add money collection logic that updates player balance
-- [ ] Create visual representation for money pickups (glowing cubes/spheres)
+- [x] Create collectible money item that spawns on bot death
+- [x] Implement money pickup collision detection
+- [x] Add money collection logic that updates player balance
+- [x] Create visual representation for money pickups (glowing cubes/spheres)
 - [ ] Balance weapon prices according to progression curve
-- [ ] Create src/economy folder developer-guide.md
+- [x] Create src/economy folder developer-guide.md
 
 ## Environment & Level Design
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index d32a8ef3aa7ddd574e1eaf0d640dadf1d34e688f..93d224b73c2fb83729e82caba23c274c6f89db2b
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -18,6 +18,7 @@
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
+- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_ai_and_economy.py b/tests/test_ai_and_economy.py
new file mode 100644
index 0000000000000000000000000000000000000000..bb34f0c1cd475ee007494b7d9787a2a4046156dc
--- /dev/null
+++ b/tests/test_ai_and_economy.py
@@ -0,0 +1,109 @@
+from random import Random
+
+import pytest
+
+from src.ai.bot import Bot, BotAIState
+from src.ai.navigation import WaypointPathfinder
+from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
+from src.player.player import Player
+
+
+def test_bot_default_state_health_and_damage_flow():
+    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
+    assert bot.bot_id == "bot-1"
+    assert bot.health == 100
+    assert bot.ai_state == BotAIState.IDLE
+    assert bot.is_alive is True
+
+    killed = bot.apply_damage(40)
+    assert killed is False
+    assert bot.health == 60
+
+    killed = bot.apply_damage(60)
+    assert killed is True
+    assert bot.health == 0
+    assert bot.ai_state == BotAIState.DEAD
+    assert bot.is_alive is False
+
+    with pytest.raises(ValueError):
+        bot.apply_damage(-1)
+
+
+def test_waypoint_pathfinding_uses_nearest_start_goal():
+    pathfinder = WaypointPathfinder(
+        waypoints={
+            "a": (0.0, 0.0, 0.0),
+            "b": (5.0, 0.0, 0.0),
+            "c": (10.0, 0.0, 0.0),
+            "d": (10.0, 0.0, 5.0),
+        },
+        links={
+            "a": ["b"],
+            "b": ["a", "c"],
+            "c": ["b", "d"],
+            "d": ["c"],
+        },
+    )
+    path = pathfinder.find_path(
+        start_position=(1.0, 0.0, 0.2),
+        goal_position=(9.9, 0.0, 4.7),
+    )
+    assert path == [
+        (0.0, 0.0, 0.0),
+        (5.0, 0.0, 0.0),
+        (10.0, 0.0, 0.0),
+        (10.0, 0.0, 5.0),
+    ]
+
+
+def test_bot_shooting_accuracy_variance_and_cooldown():
+    bot = Bot.create_default(bot_id="bot-accuracy", position=(0.0, 0.0, 0.0))
+    rng = Random(1234)
+    fired, direction = bot.shoot_at(
+        now=1.0,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired is True
+    assert direction != (0.0, 0.0, 1.0)
+
+    fired_again, _ = bot.shoot_at(
+        now=1.01,
+        target_position=(0.0, 0.0, 10.0),
+        rng=rng,
+        accuracy_degrees=5.0,
+    )
+    assert fired_again is False
+
+
+def test_bot_death_money_drop_and_player_collection():
+    bot = Bot.create_default(bot_id="bot-drop", position=(2.0, 0.0, 2.0))
+    money_system = MoneyPickupSystem()
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+
+    with pytest.raises(ValueError):
+        bot.spawn_money_drop(pickup_system=money_system, amount=125)
+
+    bot.apply_damage(100)
+    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
+    assert pickup.amount == 125
+    assert pickup.position == (2.0, 0.0, 2.0)
+    assert len(money_system.pickups) == 1
+
+    collected = money_system.collect_for_player(
+        player=player,
+        player_position=(2.1, 0.0, 2.1),
+    )
+    assert collected == 125
+    assert player.money == 125
+    assert len(money_system.pickups) == 0
+
+
+def test_money_pickup_collision_and_visual_definition():
+    system = MoneyPickupSystem()
+    pickup = system.spawn_pickup(amount=300, position=(0.0, 0.0, 0.0), radius=0.5)
+    assert pickup.intersects_sphere(center=(0.5, 0.0, 0.0), radius=0.2) is True
+    assert pickup.intersects_sphere(center=(5.0, 0.0, 0.0), radius=0.2) is False
+    assert get_money_pickup_visual(300).primitive == "sphere"
+    assert get_money_pickup_visual(50).primitive == "cube"

tokens used
70,646
Implemented 10 incomplete tasks end-to-end, updated tracking files, and validated with tests.

**Completed work**
- Added AI bot system in `src/ai/bot.py`:
  - `Bot` model with health, position, AI state, damage/death flow.
  - Bot shooting with accuracy variance and cooldown/ammo enforcement.
  - Death-gated money drop spawning.
- Added combat variance helper in `src/ai/combat.py`.
- Added waypoint pathfinding in `src/ai/navigation.py`.
- Added economy pickup system in `src/economy/money.py`:
  - Collectible money entities.
  - Pickup collision detection.
  - Money collection into player balance.
  - Glowing primitive visual definitions (cube/sphere by amount).
- Added package exports in `src/ai/__init__.py` and `src/economy/__init__.py`.
- Added tests in `tests/test_ai_and_economy.py` covering all implemented AI/economy behaviors.
- Added/updated guides:
  - `src/ai/developer-guide.md`
  - `src/economy/developer-guide.md`
  - `src/developer-guide.md`
  - `developer-guide.md`
  - `tests/developer-guide.md`
- Updated progress tracking:
  - Marked 10 tasks as complete in `tasks.md`.
  - Logged changes in `recent-changes.md`.

**Validation**
- Ran `pytest -q`: `35 passed` (all tests green).

No additional unplanned tasks were discovered that needed adding to `tasks.md`.
Implemented 10 incomplete tasks end-to-end, updated tracking files, and validated with tests.

**Completed work**
- Added AI bot system in `src/ai/bot.py`:
  - `Bot` model with health, position, AI state, damage/death flow.
  - Bot shooting with accuracy variance and cooldown/ammo enforcement.
  - Death-gated money drop spawning.
- Added combat variance helper in `src/ai/combat.py`.
- Added waypoint pathfinding in `src/ai/navigation.py`.
- Added economy pickup system in `src/economy/money.py`:
  - Collectible money entities.
  - Pickup collision detection.
  - Money collection into player balance.
  - Glowing primitive visual definitions (cube/sphere by amount).
- Added package exports in `src/ai/__init__.py` and `src/economy/__init__.py`.
- Added tests in `tests/test_ai_and_economy.py` covering all implemented AI/economy behaviors.
- Added/updated guides:
  - `src/ai/developer-guide.md`
  - `src/economy/developer-guide.md`
  - `src/developer-guide.md`
  - `developer-guide.md`
  - `tests/developer-guide.md`
- Updated progress tracking:
  - Marked 10 tasks as complete in `tasks.md`.
  - Logged changes in `recent-changes.md`.

**Validation**
- Ran `pytest -q`: `35 passed` (all tests green).

No additional unplanned tasks were discovered that needed adding to `tasks.md`.
Process exited with code 0. Output length: 911422 chars.
End: 2026-02-08T18:38:01
__AGENTHARNESS_LIVE_DONE__
