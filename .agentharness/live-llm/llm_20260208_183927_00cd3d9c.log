AgentHarness LLM Live Output
Start: 2026-02-08T18:39:27
CWD: C:/Users/shlob/Pycharm Projects/harness-test/harness-test-4
Command: codex exec --skip-git-repo-check --full-auto --output-last-message "C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.codex_last_message.txt" --model gpt-5.3-codex -

Provider: Codex, Model: gpt-5.3-codex | Timeout: 600s
Prompt transport: stdin (678 chars)
LLM prompt begin (stdin)

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md
LLM prompt end (stdin)
Process PID: 4964
OpenAI Codex v0.98.0 (research preview)
--------
workdir: C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019c3e1f-59ad-77e1-b6a3-4147f94dc429
--------
user

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md

deprecated: `enable_experimental_windows_sandbox` is deprecated. Use `[features].experimental_windows_sandbox` instead.
  Enable it with `--enable experimental_windows_sandbox` or `[features].experimental_windows_sandbox` in config.toml. See https://github.com/openai/codex/blob/main/docs/config.md#feature-flags for details.
mcp startup: no servers

thinking
**Acknowledging next step**
codex
I’m going to follow your workflow end-to-end: first I’ll read `product-description.md`, `recent-changes.md`, and `tasks.md`, then I’ll pick up to 10 unchecked tasks and implement them completely with guide updates before marking them done. I’ll start by gathering the current project context.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path recent-changes.md) { Get-Content recent-changes.md } else { Write-Output 'MISSING: recent-changes.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path product-description.md) { Get-Content product-description.md } else { Write-Output 'MISSING: product-description.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "if (Test-Path tasks.md) { Get-Content tasks.md } else { Write-Output 'MISSING: tasks.md' }" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Force | Select-Object Name,Mode,Length' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 208ms:
# Product Description: FPS Bot Arena with "The Glitch"

## Overview
A First-Person Shooter (FPS) game where the player fights against waves of tactical AI bots in a multi-room indoor facility. The core loop involves combat, earning money from kills, and upgrading weapons. The game features a meta-twist ending where the final weapon, an RPG, triggers a simulated game crash (Fake BSOD/Error) upon use.

## Gameplay Mechanics
*   **Perspective:** First-Person.
*   **Controls:** Standard FPS controls (WASD + Mouse).
*   **Interaction:** Pressing 'B' opens a real-time inventory/shop wheel to buy and switch weapons.
*   **Win/Loss:**
    *   **Loss:** Player health reaches zero.
    *   **"Win":** Acquiring and firing the final RPG, triggering the "crash" ending.

## Economy & Progression
*   **Income:** Bots drop money as physical items upon death, which the player must collect.
*   **Weapon Progression:**
    1.  **Pistol:** Starting weapon.
    2.  **Shotgun:** High close-range damage.
    3.  **Assault Rifle:** Rapid fire, medium range.
    4.  **RPG (Final Weapon):** Expensive endgame item. Firing it causes a fake "Blue Screen of Death" or critical error message, effectively ending the session.
 succeeded in 214ms:
# Recent Changes

 succeeded in 213ms:
# FPS Bot Arena Implementation Tasks

## Project Setup & Architecture

- [x] Choose and document the technology stack (Python + Ursina or Web + Three.js)
- [x] Set up project structure with main folders (src, assets, config, tests)
- [x] Create root developer-guide.md documenting overall project architecture
- [x] Initialize package.json or requirements.txt with core dependencies
- [x] Set up basic project configuration files (config.py or config.js)

## Core Game Engine

- [x] Implement main game loop with frame updates and delta time handling
- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
- [x] Implement camera system with first-person perspective and mouse look controls
- [x] Create input handler for WASD movement and mouse controls
- [x] Implement player movement with collision detection
- [x] Create physics system for projectile movement and collision
- [x] Implement raycasting system for shooting mechanics
- [x] Create game clock and time management system
 succeeded in 239ms:

Name                   Mode   Length
----                   ----   ------
.agentharness          d-----       
.git                   d--h--       
.pytest_cache          d-----       
assets                 d-----       
config                 d-----       
review                 d-----       
src                    d-----       
tests                  d-----       
.gitignore             -a---- 613   
AGENTS.md              -a---- 1086  
CLAUDE.md              -a---- 1086  
developer-guide.md     -a---- 4668  
GAMEPLAY.md            -a---- 1003  
GEMINI.md              -a---- 1086  
product-description.md -a---- 2003  
questions.json         -a---- 3236  
README.md              -a---- 1272  

thinking
**Planning task selection strategy**
codex
I’ve loaded the task list and there are many open items; next I’m scanning the codebase and folder-level developer guides so I can pick a coherent batch of up to 10 tasks that can be fully completed together.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File src | Select-Object FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -Filter developer-guide.md | Select-Object FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 278ms:

FullName                                                                                      
--------                                                                                      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\config\developer-guide.md         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\review\developer-guide.md         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\developer-guide.md            
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\developer-guide.md         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\developer-guide.md       
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\economy\developer-guide.md    
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\player\developer-guide.md     
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\projectiles\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ui\developer-guide.md         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\weapons\developer-guide.md    
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\developer-guide.md          


 succeeded in 272ms:
# Developer Guide

## Project Architecture
This project uses **Python + Ursina** for a lightweight FPS prototype.

The current codebase implements engine-agnostic gameplay foundations in pure Python:
- Core runtime loop and timing
- State machine for high-level game flow
- Clock pause/resume and time scaling controls
- Input normalization for WASD + mouse look
- First-person camera and movement/collision simulation
- Raycasting-based hit-scan traces
- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
- Projectile entities and physics for bullets, pellets, and rockets
- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions

## Directory Map
 succeeded in 277ms:

FullName                                                                                                          
--------                                                                                                          
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\.gitkeep                                          
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\developer-guide.md                                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\bot.py                                         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\combat.py                                      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\developer-guide.md                             
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\navigation.py                                  
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__init__.py                                    
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__pycache__\bot.cpython-311.pyc                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__pycache__\combat.cpython-311.pyc             
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__pycache__\navigation.cpython-311.pyc         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__pycache__\__init__.cpython-311.pyc           
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\camera.py                                    
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\collision.py                                 
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\developer-guide.md                           
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\game_clock.py                                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\game_loop.py                                 
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\game_state.py                                

thinking
**Scoping tasks from developer guides**
codex
I found this is a pure-Python gameplay foundation, so I can complete a cohesive set of 10 tasks in `environment` + `ai` without needing full rendering. I’m now reading the existing `src` and `src/ai` guides/code to implement compatible systems and tests.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/ai/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/ai/bot.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/ai/combat.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/ai/navigation.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 214ms:
# Src Developer Guide

## Purpose
`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.

## Folder Overview
- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
- `projectiles/`: projectile entities plus physics stepping and world collision checks.
- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.

## Integration Flow
1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 succeeded in 233ms:
"""Combat helpers for bot aiming and shot variance."""

from __future__ import annotations

from math import radians, sqrt, tan
from random import Random


Vector3 = tuple[float, float, float]


def _normalize(direction: Vector3) -> Vector3:
    length = sqrt(
        (direction[0] * direction[0])
        + (direction[1] * direction[1])
        + (direction[2] * direction[2])
    )
    if length <= 0.0:
        raise ValueError("Direction vector must be non-zero.")
    return (
 succeeded in 233ms:
"""Waypoint-based pathfinding helpers for bots."""

from __future__ import annotations

from collections import deque
from dataclasses import dataclass
from math import sqrt


Vector3 = tuple[float, float, float]


def _distance(a: Vector3, b: Vector3) -> float:
    dx = a[0] - b[0]
    dy = a[1] - b[1]
    dz = a[2] - b[2]
    return sqrt((dx * dx) + (dy * dy) + (dz * dz))


@dataclass
 succeeded in 233ms:
# AI Developer Guide

## Purpose
`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.

## Files
- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
- `__init__.py`: package exports for AI modules.

## Key Behaviors
- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 succeeded in 236ms:
"""Bot runtime model with combat hooks and money-drop behavior."""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from math import sqrt
from random import Random

from src.ai.combat import vary_direction_with_accuracy
from src.economy.money import MoneyPickup, MoneyPickupSystem
from src.weapons.assault_rifle import AssaultRifle
from src.weapons.weapon import Weapon


Vector3 = tuple[float, float, float]


class BotAIState(str, Enum):
    """High-level tactical state labels for bots."""

thinking
**Reviewing existing tests**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'rg -n "ai|environment|hud|wave|cover|flank|spawn|waypoint|room|collision" tests' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File tests | Select-Object FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tests/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 248ms:
# Tests Developer Guide

## Overview
This directory contains the automated test suite for the FPS Bot Arena project.

## Testing Framework
- **Framework:** `pytest`
- **Rationale:** Standard, powerful, and easy-to-use testing framework for Python.

## Structure
- Test files should be named `test_<module_name>.py`.
- Tests should mirror the structure of the `src/` and `config/` directories where applicable.
- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.

## Current Test Modules
- `test_config.py`: validates immutable config defaults.
- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 succeeded in 248ms:
tests\test_player_and_weapons.py:32:    with pytest.raises(ValueError):
tests\test_player_and_weapons.py:34:    with pytest.raises(ValueError):
tests\test_player_and_weapons.py:49:    with pytest.raises(ValueError):
tests\test_player_and_weapons.py:51:    with pytest.raises(ValueError):
tests\test_player_and_weapons.py:69:    with pytest.raises(ValueError):
tests\developer-guide.md:4:This directory contains the automated test suite for the FPS Bot Arena project.
tests\developer-guide.md:19:- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
tests\developer-guide.md:21:- `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
tests\test_ai_and_economy.py:5:from src.ai.bot import Bot, BotAIState
tests\test_ai_and_economy.py:6:from src.ai.navigation import WaypointPathfinder
tests\test_ai_and_economy.py:15:    assert bot.ai_state == BotAIState.IDLE
tests\test_ai_and_economy.py:25:    assert bot.ai_state == BotAIState.DEAD
tests\test_ai_and_economy.py:28:    with pytest.raises(ValueError):
tests\test_ai_and_economy.py:32:def test_waypoint_pathfinding_uses_nearest_start_goal():
tests\test_ai_and_economy.py:34:        waypoints={
tests\test_ai_and_economy.py:71:    fired_again, _ = bot.shoot_at(
tests\test_ai_and_economy.py:77:    assert fired_again is False
tests\test_ai_and_economy.py:85:    with pytest.raises(ValueError):
tests\test_ai_and_economy.py:86:        bot.spawn_money_drop(pickup_system=money_system, amount=125)
tests\test_ai_and_economy.py:89:    pickup = bot.spawn_money_drop(pickup_system=money_system, amount=125)
 succeeded in 253ms:

FullName                                                                                                                                    
--------                                                                                                                                    
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\conftest.py                                                               
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\developer-guide.md                                                        
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_advanced_combat_and_movement.py                                      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_ai_and_economy.py                                                    
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_config.py                                                            
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_core_systems.py                                                      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_player_and_weapons.py                                                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\test_shop_ui.py                                                           
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\conftest.cpython-311-pytest-9.0.2.pyc                         
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_advanced_combat_and_movement.cpython-311-pytest-9.0.2.pyc
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_ai_and_economy.cpython-311-pytest-9.0.2.pyc              
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_config.cpython-311-pytest-9.0.2.pyc                      
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_core_systems.cpython-311-pytest-9.0.2.pyc                
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_player_and_weapons.cpython-311-pytest-9.0.2.pyc          
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\__pycache__\test_shop_ui.cpython-311-pytest-9.0.2.pyc                     



thinking
**Reviewing tests and exports**
codex
I’ve confirmed there’s existing AI/economy test coverage, so I’ll extend that style with new environment and tactical AI tests while keeping the implementation engine-agnostic. Next I’m reading core collision and config to wire environment data cleanly.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/ai/__init__.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tests/test_ai_and_economy.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content config/config.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/collision.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 206ms:
"""AABB collision primitives used by movement and projectiles."""

from __future__ import annotations

from dataclasses import dataclass


Vector3 = tuple[float, float, float]


@dataclass(frozen=True)
class AABB:
    """Axis-aligned bounding box."""

    min_corner: Vector3
    max_corner: Vector3

    def intersects(self, other: "AABB") -> bool:
        return (
            self.min_corner[0] <= other.max_corner[0]
 succeeded in 218ms:
"""Project-wide configuration for the FPS Bot Arena prototype.

This module centralizes tunable values so gameplay systems can import
one source of truth instead of hardcoding constants.
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class GameConfig:
    """Core configuration values for the current prototype."""

    game_title: str = "FPS Bot Arena: The Glitch"
    start_health: int = 100
    start_money: int = 0
    mouse_sensitivity: float = 40.0
    walk_speed: float = 5.0


 succeeded in 218ms:
"""Bot AI domain models, combat helpers, and pathfinding."""

from src.ai.bot import Bot, BotAIState
from src.ai.combat import vary_direction_with_accuracy
from src.ai.navigation import WaypointPathfinder

__all__ = [
    "Bot",
    "BotAIState",
    "WaypointPathfinder",
    "vary_direction_with_accuracy",
]
 succeeded in 222ms:
from random import Random

import pytest

from src.ai.bot import Bot, BotAIState
from src.ai.navigation import WaypointPathfinder
from src.economy.money import MoneyPickupSystem, get_money_pickup_visual
from src.player.player import Player


def test_bot_default_state_health_and_damage_flow():
    bot = Bot.create_default(bot_id="bot-1", position=(1.0, 0.0, 2.0))
    assert bot.bot_id == "bot-1"
    assert bot.health == 100
    assert bot.ai_state == BotAIState.IDLE
    assert bot.is_alive is True

    killed = bot.apply_damage(40)
    assert killed is False
    assert bot.health == 60

thinking
**Inspecting core movement for collision usage**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/core/movement.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 196ms:
"""Player movement with collision detection against world geometry."""

from __future__ import annotations

import math
from dataclasses import dataclass

from src.core.collision import AABB, CollisionWorld


@dataclass
class PlayerMovementController:
    """Moves a player in local-space input while resolving collisions."""

    walk_speed: float
    collider_half_size: tuple[float, float, float] = (0.35, 0.9, 0.35)

    def move(
        self,
        *,

thinking
**Exploring physics dependencies**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/projectiles/physics.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 191ms:
"""Projectile simulation with world collision detection."""

from __future__ import annotations

from dataclasses import dataclass

from src.core.collision import AABB, CollisionWorld
from src.projectiles.projectile import Projectile


@dataclass
class ProjectilePhysicsSystem:
    """Advances projectiles and deactivates on world collision."""

    def step(self, projectiles: list[Projectile], delta_time: float, world: CollisionWorld) -> int:
        collision_count = 0
        for projectile in projectiles:
            if not projectile.is_active:
                continue
            projectile.advance(delta_time)

thinking
**Reviewing test configuration**
codex
I’ve confirmed movement/projectiles already consume `CollisionWorld`, so I can implement environment generation as reusable collision/nav data and keep integration clean. I’m now drafting the exact 10 tasks to complete and then I’ll code and test them in one pass.
codex
Plan for this batch (10 tasks, all from currently unchecked items):

1. `Environment`: implement a multi-room indoor facility model with 5 distinct rooms, doorway connectivity, cover objects, spawn points, and AI nav waypoints.
2. `Environment`: generate collision walls from room geometry, including doorway openings, and expose a `CollisionWorld` builder.
3. `Environment`: add environmental lighting configuration data (engine-agnostic values for ambient + directional).
4. `AI`: add cover detection and usage logic against environment cover objects.
5. `AI`: add tactical decision-making state selection (`attack`, `take cover`, `flank`) based on health/range/cover.
6. `AI`: add flanking behavior planner returning alternate approach routes.
7. `AI`: add wave spawning system for multiple bots with per-wave counts and spawn selection.
8. `AI`: add bot difficulty scaling across waves (health, accuracy, aggression profile).
9. Tests: add comprehensive tests for environment layout/collision/nav/spawns and tactical AI + wave scaling.
10. Docs/tasks/changelog: update `developer-guide.md` files (new and ancestor guides), mark completed tasks in `tasks.md`, and record work in `recent-changes.md`.

I’ll now implement the new `src/environment` and `src/ai` modules, then run `pytest` before I update task tracking files.

thinking
**Scoping and prioritizing ten core tasks**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/weapon.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 199ms:
"""Base weapon model used by all weapon types."""

from __future__ import annotations

from dataclasses import dataclass
from math import sqrt


Vector3 = tuple[float, float, float]


def _normalize(direction: Vector3) -> Vector3:
    length = sqrt(
        (direction[0] * direction[0])
        + (direction[1] * direction[1])
        + (direction[2] * direction[2])
    )
    if length <= 0.0:
        raise ValueError("Direction vector must be non-zero.")
    return (

thinking
**Reviewing subclass customization**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/weapons/assault_rifle.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 190ms:
"""Assault rifle weapon implementation."""

from __future__ import annotations

from src.weapons.weapon import Weapon


class AssaultRifle(Weapon):
    """Rapid-fire automatic weapon for mid-range combat."""

    def __init__(self) -> None:
        super().__init__(
            name="AssaultRifle",
            damage=16.0,
            fire_rate=9.0,
            magazine_size=30,
            reserve_ammo=120,
            projectile_speed=95.0,
            projectile_radius=0.07,
            projectile_kind="bullet",

thinking
**Planning modular edits**
codex
I’m starting file edits now: adding a new `src/environment` package plus new `src/ai` tactical and wave modules, then I’ll wire exports and add focused tests that prove each selected task is complete.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "@'
*** Begin Patch
*** Add File: src/environment/facility.py
+\"\"\"Indoor facility layout primitives used by environment and AI systems.\"\"\"
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    \"\"\"Axis-aligned rectangular room footprint.\"\"\"
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    \"\"\"Opening between two rooms along a shared wall.\"\"\"
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal[\"x\", \"z\"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    \"\"\"Simple geometric cover object represented as an AABB prism.\"\"\"
+
+    cover_id: str
+    kind: Literal[\"crate\", \"pillar\", \"barrier\"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    \"\"\"Named spawn point for player or bots.\"\"\"
+
+    spawn_id: str
+    position: Vector3
+    team: Literal[\"player\", \"bot\"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    \"\"\"Engine-agnostic lighting profile for the facility.\"\"\"
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    \"\"\"Complete facility definition used by environment and AI systems.\"\"\"
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == \"bot\"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == \"player\":
+                return spawn.position
+        raise ValueError(\"Facility layout must define one player spawn point.\")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    \"\"\"Return a 5-room tactical facility with doorways, cover, and nav data.\"\"\"
+    rooms = {
+        \"lobby\": Room(\"lobby\", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        \"central_hall\": Room(\"central_hall\", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        \"storage\": Room(\"storage\", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        \"lab\": Room(\"lab\", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        \"security\": Room(\"security\", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id=\"lobby_to_central\",
+            room_a=\"lobby\",
+            room_b=\"central_hall\",
+            wall_axis=\"x\",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id=\"central_to_storage\",
+            room_a=\"central_hall\",
+            room_b=\"storage\",
+            wall_axis=\"x\",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id=\"central_to_lab\",
+            room_a=\"central_hall\",
+            room_b=\"lab\",
+            wall_axis=\"x\",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id=\"lobby_to_security\",
+            room_a=\"lobby\",
+            room_b=\"security\",
+            wall_axis=\"z\",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id=\"lobby_crates\",
+            kind=\"crate\",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id=\"hall_pillar\",
+            kind=\"pillar\",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id=\"storage_barrier\",
+            kind=\"barrier\",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id=\"lab_crates\",
+            kind=\"crate\",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id=\"security_barrier\",
+            kind=\"barrier\",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        \"wp_lobby\": (-8.0, 0.0, 0.0),
+        \"wp_lobby_door\": (-4.2, 0.0, 0.0),
+        \"wp_central\": (0.0, 0.0, 0.0),
+        \"wp_storage_door\": (4.2, 0.0, -6.0),
+        \"wp_storage\": (8.0, 0.0, -6.0),
+        \"wp_lab_door\": (4.2, 0.0, 6.0),
+        \"wp_lab\": (8.0, 0.0, 6.0),
+        \"wp_security_door\": (-8.0, 0.0, -8.2),
+        \"wp_security\": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        \"wp_lobby\": [\"wp_lobby_door\", \"wp_security_door\"],
+        \"wp_lobby_door\": [\"wp_lobby\", \"wp_central\"],
+        \"wp_central\": [\"wp_lobby_door\", \"wp_storage_door\", \"wp_lab_door\"],
+        \"wp_storage_door\": [\"wp_central\", \"wp_storage\"],
+        \"wp_storage\": [\"wp_storage_door\"],
+        \"wp_lab_door\": [\"wp_central\", \"wp_lab\"],
+        \"wp_lab\": [\"wp_lab_door\"],
+        \"wp_security_door\": [\"wp_lobby\", \"wp_security\"],
+        \"wp_security\": [\"wp_security_door\"],
+    }
+
+    spawn_points = [
+        SpawnPoint(\"spawn_player\", position=(-9.0, 0.0, 3.0), team=\"player\"),
+        SpawnPoint(\"spawn_bot_lobby\", position=(-9.5, 0.0, -3.0), team=\"bot\"),
+        SpawnPoint(\"spawn_bot_storage\", position=(9.0, 0.0, -7.8), team=\"bot\"),
+        SpawnPoint(\"spawn_bot_lab\", position=(8.7, 0.0, 7.8), team=\"bot\"),
+        SpawnPoint(\"spawn_bot_security\", position=(-8.0, 0.0, -12.0), team=\"bot\"),
+        SpawnPoint(\"spawn_bot_central\", position=(0.0, 0.0, 8.0), team=\"bot\"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
*** End Patch
'@ | apply_patch" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "@'
*** Begin Patch
*** Add File: src/environment/navigation.py
+\"\"\"Environment navigation helpers.\"\"\"
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    \"\"\"Create a validated waypoint pathfinder from facility data.\"\"\"
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f\"Waypoint link source '{node_id}' is undefined.\")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f\"Waypoint link target '{neighbor}' is undefined.\")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
*** End Patch
'@ | apply_patch" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "@'
*** Begin Patch
*** Add File: src/environment/collision.py
+\"\"\"Build collision volumes from a facility layout.\"\"\"
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import Doorway, FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    \"\"\"Subtract opening ranges from a wall segment range.\"\"\"
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis "'!= axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def _cover_to_box(min_corner: tuple[float, float, float], max_corner: tuple[float, float, float]) -> AABB:
+    return AABB(min_corner=min_corner, max_corner=max_corner)
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(_cover_to_box(cover.min_corner, cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
*** End Patch
'"'@ | apply_patch" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "@'
*** Begin Patch
*** Add File: src/environment/__init__.py
+\"\"\"Environment layout and collision exports.\"\"\"
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    \"Room\",
+    \"Doorway\",
+    \"CoverObject\",
+    \"SpawnPoint\",
+    \"LightingSetup\",
+    \"FacilityLayout\",
+    \"create_default_facility_layout\",
+    \"build_collision_world\",
+    \"build_waypoint_pathfinder\",
+]
*** End Patch
'@ | apply_patch" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 exited 1 in 258ms:
Error: --codex-run-as-apply-patch requires a UTF-8 PATCH argument.
 exited 1 in 294ms:
Error: --codex-run-as-apply-patch requires a UTF-8 PATCH argument.
 exited 1 in 252ms:
Error: --codex-run-as-apply-patch requires a UTF-8 PATCH argument.
 exited 1 in 257ms:
Error: --codex-run-as-apply-patch requires a UTF-8 PATCH argument.

thinking
**Clarifying apply_patch usage**
codex
The batch patch command failed because this environment expects direct `apply_patch` calls, so I’m switching to sequential patches and continuing with the same implementation plan.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/environment/facility.py
"""Indoor facility layout primitives used by environment and AI systems."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Literal


Vector3 = tuple[float, float, float]


@dataclass(frozen=True)
class Room:
    """Axis-aligned rectangular room footprint."""

    room_id: str
    min_x: float
    max_x: float
    min_z: float
    max_z: float
    floor_y: float = 0.0

    @property
    def center(self) -> Vector3:
        return (
            (self.min_x + self.max_x) * 0.5,
            self.floor_y,
            (self.min_z + self.max_z) * 0.5,
        )


@dataclass(frozen=True)
class Doorway:
    """Opening between two rooms along a shared wall."""

    doorway_id: str
    room_a: str
    room_b: str
    wall_axis: Literal["x", "z"]
    wall_value: float
    center: float
    width: float

    @property
    def span_min(self) -> float:
        return self.center - (self.width * 0.5)

    @property
    def span_max(self) -> float:
        return self.center + (self.width * 0.5)


@dataclass(frozen=True)
class CoverObject:
    """Simple geometric cover object represented as an AABB prism."""

    cover_id: str
    kind: Literal["crate", "pillar", "barrier"]
    min_corner: Vector3
    max_corner: Vector3
    blocks_movement: bool = True

    @property
    def center(self) -> Vector3:
        return (
            (self.min_corner[0] + self.max_corner[0]) * 0.5,
            (self.min_corner[1] + self.max_corner[1]) * 0.5,
            (self.min_corner[2] + self.max_corner[2]) * 0.5,
        )


@dataclass(frozen=True)
class SpawnPoint:
    """Named spawn point for player or bots."""

    spawn_id: str
    position: Vector3
    team: Literal["player", "bot"]


@dataclass(frozen=True)
class LightingSetup:
    """Engine-agnostic lighting profile for the facility."""

    ambient_color: tuple[float, float, float]
    ambient_intensity: float
    directional_color: tuple[float, float, float]
    directional_intensity: float
    directional_direction: Vector3


@dataclass(frozen=True)
class FacilityLayout:
    """Complete facility definition used by environment and AI systems."""

    rooms: dict[str, Room]
    doorways: list[Doorway]
    cover_objects: list[CoverObject]
    waypoints: dict[str, Vector3]
    waypoint_links: dict[str, list[str]]
    spawn_points: list[SpawnPoint]
    lighting: LightingSetup
    wall_height: float = 3.0

    def room_ids(self) -> set[str]:
        return set(self.rooms.keys())

    def bot_spawn_positions(self) -> list[Vector3]:
        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]

    def player_spawn_position(self) -> Vector3:
        for spawn in self.spawn_points:
            if spawn.team == "player":
                return spawn.position
        raise ValueError("Facility layout must define one player spawn point.")


def create_default_facility_layout() -> FacilityLayout:
    """Return a 5-room tactical facility with doorways, cover, and nav data."""
    rooms = {
        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
    }

    doorways = [
        Doorway(
            doorway_id="lobby_to_central",
            room_a="lobby",
            room_b="central_hall",
            wall_axis="x",
            wall_value=-4.0,
            center=0.0,
            width=3.0,
        ),
        Doorway(
            doorway_id="central_to_storage",
            room_a="central_hall",
            room_b="storage",
            wall_axis="x",
            wall_value=4.0,
            center=-6.0,
            width=3.0,
        ),
        Doorway(
            doorway_id="central_to_lab",
            room_a="central_hall",
            room_b="lab",
            wall_axis="x",
            wall_value=4.0,
            center=6.0,
            width=3.0,
        ),
        Doorway(
            doorway_id="lobby_to_security",
            room_a="lobby",
            room_b="security",
            wall_axis="z",
            wall_value=-8.0,
            center=-8.0,
            width=3.0,
        ),
    ]

    cover_objects = [
        CoverObject(
            cover_id="lobby_crates",
            kind="crate",
            min_corner=(-10.5, 0.0, -1.8),
            max_corner=(-8.8, 1.5, -0.1),
        ),
        CoverObject(
            cover_id="hall_pillar",
            kind="pillar",
            min_corner=(-0.9, 0.0, -0.9),
            max_corner=(0.9, 2.8, 0.9),
        ),
        CoverObject(
            cover_id="storage_barrier",
            kind="barrier",
            min_corner=(6.0, 0.0, -6.9),
            max_corner=(9.8, 1.3, -5.8),
        ),
        CoverObject(
            cover_id="lab_crates",
            kind="crate",
            min_corner=(7.2, 0.0, 5.0),
            max_corner=(9.0, 1.6, 6.8),
        ),
        CoverObject(
            cover_id="security_barrier",
            kind="barrier",
            min_corner=(-9.6, 0.0, -11.2),
            max_corner=(-6.4, 1.4, -10.1),
        ),
    ]

    waypoints = {
        "wp_lobby": (-8.0, 0.0, 0.0),
        "wp_lobby_door": (-4.2, 0.0, 0.0),
        "wp_central": (0.0, 0.0, 0.0),
        "wp_storage_door": (4.2, 0.0, -6.0),
        "wp_storage": (8.0, 0.0, -6.0),
        "wp_lab_door": (4.2, 0.0, 6.0),
        "wp_lab": (8.0, 0.0, 6.0),
        "wp_security_door": (-8.0, 0.0, -8.2),
        "wp_security": (-8.0, 0.0, -11.0),
    }
    waypoint_links = {
        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
        "wp_lobby_door": ["wp_lobby", "wp_central"],
        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
        "wp_storage_door": ["wp_central", "wp_storage"],
        "wp_storage": ["wp_storage_door"],
        "wp_lab_door": ["wp_central", "wp_lab"],
        "wp_lab": ["wp_lab_door"],
        "wp_security_door": ["wp_lobby", "wp_security"],
        "wp_security": ["wp_security_door"],
    }

    spawn_points = [
        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
    ]

    lighting = LightingSetup(
        ambient_color=(0.68, 0.72, 0.78),
        ambient_intensity=0.42,
        directional_color=(1.0, 0.96, 0.9),
        directional_intensity=0.82,
        directional_direction=(-0.6, -1.0, -0.3),
    )

    return FacilityLayout(
        rooms=rooms,
        doorways=doorways,
        cover_objects=cover_objects,
        waypoints=waypoints,
        waypoint_links=waypoint_links,
        spawn_points=spawn_points,
        lighting=lighting,
    )
apply_patch(auto_approved=true) exited 0 in 57ms:
Success. Updated the following files:
A src/environment/facility.py
file update:
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )

file update:
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/environment/collision.py
"""Build collision volumes from a facility layout."""

from __future__ import annotations

from src.core.collision import AABB, CollisionWorld
from src.environment.facility import FacilityLayout, Room


EPSILON = 1e-5


def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
    """Subtract opening ranges from a wall segment range."""
    segments = [(start, end)]
    for cut_min, cut_max in cuts:
        if cut_max <= cut_min:
            continue
        next_segments: list[tuple[float, float]] = []
        for seg_min, seg_max in segments:
            if cut_max <= seg_min or cut_min >= seg_max:
                next_segments.append((seg_min, seg_max))
                continue
            if cut_min > seg_min:
                next_segments.append((seg_min, cut_min))
            if cut_max < seg_max:
                next_segments.append((cut_max, seg_max))
        segments = next_segments
    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]


def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
    openings: list[tuple[float, float]] = []
    for doorway in layout.doorways:
        if doorway.wall_axis != axis:
            continue
        if abs(doorway.wall_value - wall_value) > EPSILON:
            continue
        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
            continue
        openings.append((doorway.span_min, doorway.span_max))
    return openings


def _build_room_wall_boxes(
    *,
    layout: FacilityLayout,
    room: Room,
    wall_thickness: float,
) -> list[AABB]:
    half_thickness = wall_thickness * 0.5
    floor_y = room.floor_y
    ceiling_y = room.floor_y + layout.wall_height
    boxes: list[AABB] = []

    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
        openings = _wall_openings_for_room(layout, room, "x", x_value)
        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
            boxes.append(
                AABB(
                    min_corner=(x_value - half_thickness, floor_y, cut_min),
                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
                )
            )

    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
        openings = _wall_openings_for_room(layout, room, "z", z_value)
        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
            boxes.append(
                AABB(
                    min_corner=(cut_min, floor_y, z_value - half_thickness),
                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
                )
            )

    add_x_wall(room.min_x, room.min_z, room.max_z)
    add_x_wall(room.max_x, room.min_z, room.max_z)
    add_z_wall(room.min_z, room.min_x, room.max_x)
    add_z_wall(room.max_z, room.min_x, room.max_x)
    return boxes


def build_collision_world(
    layout: FacilityLayout,
    *,
    world_margin: float = 2.0,
    wall_thickness: float = 0.4,
) -> CollisionWorld:
    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
    if wall_thickness <= 0.0:
        raise ValueError("wall_thickness must be positive.")

    static_walls: list[AABB] = []
    min_x = float("inf")
    min_y = float("inf")
    min_z = float("inf")
    max_x = float("-inf")
    max_y = float("-inf")
    max_z = float("-inf")

    for room in layout.rooms.values():
        min_x = min(min_x, room.min_x)
        min_y = min(min_y, room.floor_y)
        min_z = min(min_z, room.min_z)
        max_x = max(max_x, room.max_x)
        max_y = max(max_y, room.floor_y + layout.wall_height)
        max_z = max(max_z, room.max_z)
        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))

    for cover in layout.cover_objects:
        if cover.blocks_movement:
            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))

    bounds = AABB(
        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
    )
    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
apply_patch(auto_approved=true) exited 0 in 70ms:
Success. Updated the following files:
A src/environment/collision.py
file update:
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )

file update:
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/environment/navigation.py
"""Environment navigation helpers."""

from __future__ import annotations

from src.ai.navigation import WaypointPathfinder
from src.environment.facility import FacilityLayout


def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
    """Create a validated waypoint pathfinder from facility data."""
    for node_id, neighbors in layout.waypoint_links.items():
        if node_id not in layout.waypoints:
            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
        for neighbor in neighbors:
            if neighbor not in layout.waypoints:
                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
    return WaypointPathfinder(
        waypoints=dict(layout.waypoints),
        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
    )
apply_patch(auto_approved=true) exited 0 in 82ms:
Success. Updated the following files:
A src/environment/navigation.py
file update:
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )

file update:
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/environment/__init__.py
"""Environment layout and collision exports."""

from src.environment.collision import build_collision_world
from src.environment.facility import (
    CoverObject,
    Doorway,
    FacilityLayout,
    LightingSetup,
    Room,
    SpawnPoint,
    create_default_facility_layout,
)
from src.environment.navigation import build_waypoint_pathfinder

__all__ = [
    "Room",
    "Doorway",
    "CoverObject",
    "SpawnPoint",
    "LightingSetup",
    "FacilityLayout",
    "create_default_facility_layout",
    "build_collision_world",
    "build_waypoint_pathfinder",
]
apply_patch(auto_approved=true) exited 0 in 109ms:
Success. Updated the following files:
A src/environment/__init__.py
file update:
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )

file update:
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )


thinking
**Adding AI modules**
codex
Environment modules are in place. I’m now adding tactical AI and wave director modules, then I’ll extend tests to validate all new behavior before updating docs/tasks.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/tactics.py
"""Tactical decision-making, cover usage, and flanking helpers."""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from math import sqrt

from src.ai.bot import Bot
from src.environment.facility import CoverObject


Vector3 = tuple[float, float, float]


class TacticalAction(str, Enum):
    """Primary tactical actions a bot can select."""

    ATTACK = "attack"
    TAKE_COVER = "take_cover"
    FLANK = "flank"


@dataclass(frozen=True)
class CoverPlan:
    """Selected cover target and movement anchor for a bot."""

    cover_id: str
    anchor_position: Vector3
    distance_from_bot: float


def _distance_2d(a: Vector3, b: Vector3) -> float:
    dx = a[0] - b[0]
    dz = a[2] - b[2]
    return sqrt((dx * dx) + (dz * dz))


def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
    ab_x = b[0] - a[0]
    ab_z = b[2] - a[2]
    ap_x = p[0] - a[0]
    ap_z = p[2] - a[2]
    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
    if ab_len_sq <= 1e-9:
        return _distance_2d(a, p)
    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
    t = max(0.0, min(1.0, t))
    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
    return _distance_2d(closest, p)


def _cover_blocks_line_of_fire(
    *,
    cover: CoverObject,
    from_position: Vector3,
    to_position: Vector3,
) -> bool:
    center = cover.center
    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)


def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
    center = cover.center
    dir_x = center[0] - player_position[0]
    dir_z = center[2] - player_position[2]
    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
    if length <= 1e-9:
        return center
    nx = dir_x / length
    nz = dir_z / length
    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))


def find_cover_plan(
    *,
    bot_position: Vector3,
    player_position: Vector3,
    cover_objects: list[CoverObject],
    max_cover_distance: float = 12.0,
) -> CoverPlan | None:
    """Pick the nearest useful cover that can break line-of-fire to player."""
    chosen: CoverPlan | None = None
    for cover in cover_objects:
        anchor = _cover_anchor(cover, player_position)
        distance = _distance_2d(bot_position, anchor)
        if distance > max_cover_distance:
            continue
        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
            continue
        if chosen is None or distance < chosen.distance_from_bot:
            chosen = CoverPlan(
                cover_id=cover.cover_id,
                anchor_position=anchor,
                distance_from_bot=distance,
            )
    return chosen


def choose_tactical_action(
    *,
    bot: Bot,
    player_position: Vector3,
    cover_objects: list[CoverObject],
    ally_count: int,
    low_health_threshold: int = 35,
    attack_range: float = 14.0,
) -> TacticalAction:
    """Choose attack/cover/flank based on bot state, health, and surroundings."""
    if not bot.is_alive:
        return TacticalAction.TAKE_COVER

    distance_to_player = _distance_2d(bot.position, player_position)
    cover = find_cover_plan(
        bot_position=bot.position,
        player_position=player_position,
        cover_objects=cover_objects,
    )
    if bot.health <= low_health_threshold and cover is not None:
        return TacticalAction.TAKE_COVER
    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
        return TacticalAction.FLANK
    if distance_to_player <= attack_range:
        return TacticalAction.ATTACK
    if cover is not None:
        return TacticalAction.TAKE_COVER
    return TacticalAction.ATTACK


def build_flank_route(
    *,
    bot_position: Vector3,
    player_position: Vector3,
    flank_radius: float = 5.0,
) -> list[Vector3]:
    """Create a two-point flank path that approaches the player from a side angle."""
    dir_x = player_position[0] - bot_position[0]
    dir_z = player_position[2] - bot_position[2]
    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
    if length <= 1e-9:
        return [bot_position, player_position]

    nx = dir_x / length
    nz = dir_z / length
    left = (-nz, nx)
    right = (nz, -nx)
    left_candidate = (
        player_position[0] + (left[0] * flank_radius),
        player_position[1],
        player_position[2] + (left[1] * flank_radius),
    )
    right_candidate = (
        player_position[0] + (right[0] * flank_radius),
        player_position[1],
        player_position[2] + (right[1] * flank_radius),
    )
    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
        return [left_candidate, player_position]
    return [right_candidate, player_position]
apply_patch(auto_approved=true) exited 0 in 135ms:
Success. Updated the following files:
A src/ai/tactics.py
file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )

file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )

file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/waves.py
"""Wave spawning and difficulty scaling for bot encounters."""

from __future__ import annotations

from dataclasses import dataclass
from random import Random

from src.ai.bot import Bot
from src.weapons.assault_rifle import AssaultRifle


Vector3 = tuple[float, float, float]


@dataclass(frozen=True)
class WaveDifficulty:
    """Difficulty profile for a single wave."""

    wave_number: int
    bot_health: int
    accuracy_degrees: float
    fire_rate_multiplier: float


class WaveDirector:
    """Provides deterministic wave sizes and bot stat scaling."""

    def __init__(
        self,
        *,
        base_bot_count: int = 3,
        max_extra_bots: int = 10,
    ) -> None:
        self.base_bot_count = base_bot_count
        self.max_extra_bots = max_extra_bots

    def bot_count_for_wave(self, wave_number: int) -> int:
        if wave_number <= 0:
            raise ValueError("wave_number must be positive.")
        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
        return self.base_bot_count + extra

    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
        if wave_number <= 0:
            raise ValueError("wave_number must be positive.")
        health = 100 + ((wave_number - 1) * 12)
        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
        return WaveDifficulty(
            wave_number=wave_number,
            bot_health=health,
            accuracy_degrees=accuracy,
            fire_rate_multiplier=fire_rate_multiplier,
        )

    def spawn_wave(
        self,
        *,
        wave_number: int,
        spawn_positions: list[Vector3],
        rng: Random,
    ) -> list[Bot]:
        """Spawn a wave of bots with scaled health and weapon fire rates."""
        if not spawn_positions:
            raise ValueError("spawn_positions must not be empty.")
        difficulty = self.difficulty_for_wave(wave_number)
        count = self.bot_count_for_wave(wave_number)
        bots: list[Bot] = []
        for index in range(count):
            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
            weapon = AssaultRifle()
            weapon.fire_rate *= difficulty.fire_rate_multiplier
            bot = Bot(
                bot_id=f"wave-{wave_number}-bot-{index + 1}",
                max_health=difficulty.bot_health,
                health=difficulty.bot_health,
                position=position,
                weapon=weapon,
            )
            bots.append(bot)
        return bots
apply_patch(auto_approved=true) exited 0 in 156ms:
Success. Updated the following files:
A src/ai/waves.py
file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )

file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )


thinking
**Planning AI module update**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/__init__.py
@@ -5,2 +5,4 @@
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
@@ -11,2 +13,9 @@
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
apply_patch(auto_approved=true) exited 0 in 171ms:
Success. Updated the following files:
M src/ai/__init__.py
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )


thinking
**Adding tests and patching files**
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_environment_and_tactics.py
from random import Random

from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
from src.ai.waves import WaveDirector
from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
from src.player.player import Player


def test_default_facility_has_five_rooms_and_doorway_connectivity():
    layout = create_default_facility_layout()
    assert len(layout.rooms) == 5
    room_ids = layout.room_ids()
    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
    for doorway in layout.doorways:
        assert doorway.room_a in room_ids
        assert doorway.room_b in room_ids


def test_collision_world_from_layout_respects_doorway_openings_and_cover():
    layout = create_default_facility_layout()
    world = build_collision_world(layout)
    player = Player.with_starter_loadout(start_health=100, start_money=0)
    player.position = (-4.0, 0.0, 0.0)

    doorway_box = player.collider_aabb(position=(-4.0, 0.0, 0.0))
    blocked_wall_box = player.collider_aabb(position=(-4.0, 0.0, 6.0))
    cover_box = player.collider_aabb(position=(0.0, 0.0, 0.0))

    assert world.collides_with_wall(doorway_box) is False
    assert world.collides_with_wall(blocked_wall_box) is True
    assert world.collides_with_wall(cover_box) is True


def test_layout_navigation_data_builds_pathfinder_with_connected_path():
    layout = create_default_facility_layout()
    pathfinder = build_waypoint_pathfinder(layout)
    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
    assert len(path) >= 3
    assert path[0] == layout.waypoints["wp_lobby"]
    assert path[-1] == layout.waypoints["wp_lab"]


def test_cover_selection_and_tactical_action_choice():
    layout = create_default_facility_layout()
    bot = Player.with_starter_loadout(start_health=100, start_money=0)
    del bot  # Guard against accidental Player usage in this test.

    from src.ai.bot import Bot

    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
    ai_bot.health = 25
    player_position = (-2.0, 0.0, -1.0)
    plan = find_cover_plan(
        bot_position=ai_bot.position,
        player_position=player_position,
        cover_objects=layout.cover_objects,
    )
    assert plan is not None
    action = choose_tactical_action(
        bot=ai_bot,
        player_position=player_position,
        cover_objects=layout.cover_objects,
        ally_count=0,
    )
    assert action == TacticalAction.TAKE_COVER


def test_flank_route_and_wave_scaling_behavior():
    flank_route = build_flank_route(
        bot_position=(-10.0, 0.0, 0.0),
        player_position=(0.0, 0.0, 0.0),
        flank_radius=4.0,
    )
    assert len(flank_route) == 2
    assert flank_route[-1] == (0.0, 0.0, 0.0)
    assert flank_route[0][2] != 0.0

    layout = create_default_facility_layout()
    director = WaveDirector()
    wave1 = director.spawn_wave(
        wave_number=1,
        spawn_positions=layout.bot_spawn_positions(),
        rng=Random(42),
    )
    wave4 = director.spawn_wave(
        wave_number=4,
        spawn_positions=layout.bot_spawn_positions(),
        rng=Random(42),
    )
    assert len(wave4) > len(wave1)
    assert wave4[0].max_health > wave1[0].max_health
    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate
apply_patch(auto_approved=true) exited 0 in 205ms:
Success. Updated the following files:
A tests/test_environment_and_tactics.py
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..b0ee955805093f4a74110c75cfda795c4bc2d14d
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,92 @@
+from random import Random
+
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+from src.player.player import Player
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.position = (-4.0, 0.0, 0.0)
+
+    doorway_box = player.collider_aabb(position=(-4.0, 0.0, 0.0))
+    blocked_wall_box = player.collider_aabb(position=(-4.0, 0.0, 6.0))
+    cover_box = player.collider_aabb(position=(0.0, 0.0, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    bot = Player.with_starter_loadout(start_health=100, start_money=0)
+    del bot  # Guard against accidental Player usage in this test.
+
+    from src.ai.bot import Bot
+
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..b0ee955805093f4a74110c75cfda795c4bc2d14d
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,92 @@
+from random import Random
+
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+from src.player.player import Player
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.position = (-4.0, 0.0, 0.0)
+
+    doorway_box = player.collider_aabb(position=(-4.0, 0.0, 0.0))
+    blocked_wall_box = player.collider_aabb(position=(-4.0, 0.0, 6.0))
+    cover_box = player.collider_aabb(position=(0.0, 0.0, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    bot = Player.with_starter_loadout(start_health=100, start_money=0)
+    del bot  # Guard against accidental Player usage in this test.
+
+    from src.ai.bot import Bot
+
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Refactoring player temp and imports**
codex
I’ve added the first test pass; I’m doing a quick cleanup on that new test file for clarity, then running `pytest` to confirm everything passes before documentation/task updates.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_environment_and_tactics.py
@@ -2,2 +2,3 @@
 
+from src.ai.bot import Bot
 from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
@@ -44,7 +45,2 @@
     layout = create_default_facility_layout()
-    bot = Player.with_starter_loadout(start_health=100, start_money=0)
-    del bot  # Guard against accidental Player usage in this test.
-
-    from src.ai.bot import Bot
-
     ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
apply_patch(auto_approved=true) exited 0 in 213ms:
Success. Updated the following files:
M tests/test_environment_and_tactics.py
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..37d44a2b13b466695946dd637422014cf83f6ded
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,88 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+from src.player.player import Player
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.position = (-4.0, 0.0, 0.0)
+
+    doorway_box = player.collider_aabb(position=(-4.0, 0.0, 0.0))
+    blocked_wall_box = player.collider_aabb(position=(-4.0, 0.0, 6.0))
+    cover_box = player.collider_aabb(position=(0.0, 0.0, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..37d44a2b13b466695946dd637422014cf83f6ded
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,88 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+from src.player.player import Player
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.position = (-4.0, 0.0, 0.0)
+
+    doorway_box = player.collider_aabb(position=(-4.0, 0.0, 0.0))
+    blocked_wall_box = player.collider_aabb(position=(-4.0, 0.0, 6.0))
+    cover_box = player.collider_aabb(position=(0.0, 0.0, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 exited 1 in 651ms:
.......................F................                                 [100%]
================================== FAILURES ===================================
____ test_collision_world_from_layout_respects_doorway_openings_and_cover _____

    def test_collision_world_from_layout_respects_doorway_openings_and_cover():
        layout = create_default_facility_layout()
        world = build_collision_world(layout)
        player = Player.with_starter_loadout(start_health=100, start_money=0)
        player.position = (-4.0, 0.0, 0.0)
    
>       doorway_box = player.collider_aabb(position=(-4.0, 0.0, 0.0))
                      ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'Player' object has no attribute 'collider_aabb'

tests\test_environment_and_tactics.py:26: AttributeError
=========================== short test summary info ===========================
FAILED tests/test_environment_and_tactics.py::test_collision_world_from_layout_respects_doorway_openings_and_cover
1 failed, 39 passed in 0.13s
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..37d44a2b13b466695946dd637422014cf83f6ded
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,88 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+from src.player.player import Player
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.position = (-4.0, 0.0, 0.0)
+
+    doorway_box = player.collider_aabb(position=(-4.0, 0.0, 0.0))
+    blocked_wall_box = player.collider_aabb(position=(-4.0, 0.0, 6.0))
+    cover_box = player.collider_aabb(position=(0.0, 0.0, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Inspecting player methods**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/player/player.py' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 197ms:
"""Player model with health, currency, inventory, and shooting."""

from __future__ import annotations

from dataclasses import dataclass, field

from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
from src.projectiles.projectile import Projectile
from src.weapons.pistol import Pistol
from src.weapons.switching import WeaponSwitchState
from src.weapons.weapon import Weapon


@dataclass
class Player:
    """Encapsulates runtime player state and core gameplay actions."""

    max_health: int
    health: int
    money: int
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..37d44a2b13b466695946dd637422014cf83f6ded
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,88 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+from src.player.player import Player
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    player.position = (-4.0, 0.0, 0.0)
+
+    doorway_box = player.collider_aabb(position=(-4.0, 0.0, 0.0))
+    blocked_wall_box = player.collider_aabb(position=(-4.0, 0.0, 6.0))
+    cover_box = player.collider_aabb(position=(0.0, 0.0, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Planning direct AABB construction**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_environment_and_tactics.py
@@ -5,4 +5,4 @@
 from src.ai.waves import WaveDirector
+from src.core.collision import AABB
 from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
-from src.player.player import Player
 
@@ -22,8 +22,21 @@
     world = build_collision_world(layout)
-    player = Player.with_starter_loadout(start_health=100, start_money=0)
-    player.position = (-4.0, 0.0, 0.0)
+    collider_half_size = (0.35, 0.9, 0.35)
 
-    doorway_box = player.collider_aabb(position=(-4.0, 0.0, 0.0))
-    blocked_wall_box = player.collider_aabb(position=(-4.0, 0.0, 6.0))
-    cover_box = player.collider_aabb(position=(0.0, 0.0, 0.0))
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
 
apply_patch(auto_approved=true) exited 0 in 191ms:
Success. Updated the following files:
M tests/test_environment_and_tactics.py
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 576ms:
........................................                                 [100%]
40 passed in 0.08s
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Planning developer guide updates**
codex
Implementation and tests are passing (`40 passed`). I’m now updating developer guides (`src/environment`, `src/ai`, `src`, root, and `tests`) plus `tasks.md` and `recent-changes.md` to reflect exactly the completed task set.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/ai/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content src/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content tests/developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 211ms:
# Src Developer Guide

## Purpose
`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.

## Folder Overview
- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
- `projectiles/`: projectile entities plus physics stepping and world collision checks.
- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.

## Integration Flow
1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
4. The game loop (`core.game_loop.GameLoop`) advances time using `core.game_clock.GameClock`.
5. Player actions call weapon models for cooldown/ammo/reload behavior, smooth switch timing, and projectile payload generation.
 succeeded in 212ms:
# AI Developer Guide

## Purpose
`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.

## Files
- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
- `__init__.py`: package exports for AI modules.

## Key Behaviors
- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 succeeded in 205ms:
# Tests Developer Guide

## Overview
This directory contains the automated test suite for the FPS Bot Arena project.

## Testing Framework
- **Framework:** `pytest`
- **Rationale:** Standard, powerful, and easy-to-use testing framework for Python.

## Structure
- Test files should be named `test_<module_name>.py`.
- Tests should mirror the structure of the `src/` and `config/` directories where applicable.
- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.

## Current Test Modules
- `test_config.py`: validates immutable config defaults.
- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 succeeded in 215ms:
# Developer Guide

## Project Architecture
This project uses **Python + Ursina** for a lightweight FPS prototype.

The current codebase implements engine-agnostic gameplay foundations in pure Python:
- Core runtime loop and timing
- State machine for high-level game flow
- Clock pause/resume and time scaling controls
- Input normalization for WASD + mouse look
- First-person camera and movement/collision simulation
- Raycasting-based hit-scan traces
- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
- Projectile entities and physics for bullets, pellets, and rockets
- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
- Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions

## Directory Map
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Planning documentation and task updates**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content recent-changes.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "rg -n \"Create tactical AI decision-making system|Implement cover detection and usage logic|Create flanking behavior to approach player from multiple angles|Create wave spawning system for multiple bots|Implement bot difficulty scaling across waves|Create multi-room indoor facility layout using geometric primitives|Implement wall collision detection for player and projectiles|Add cover objects \\(crates, walls\\) throughout the facility|Create navigation data for AI pathfinding|Create src/environment folder developer-guide.md\" tasks.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 205ms:
# Recent Changes

 succeeded in 210ms:
62:- [ ] Create tactical AI decision-making system (attack, take cover, flank)
63:- [ ] Implement cover detection and usage logic
64:- [ ] Create flanking behavior to approach player from multiple angles
67:- [ ] Create wave spawning system for multiple bots
68:- [ ] Implement bot difficulty scaling across waves
82:- [ ] Create multi-room indoor facility layout using geometric primitives
83:- [ ] Implement wall collision detection for player and projectiles
84:- [ ] Add cover objects (crates, walls) throughout the facility
85:- [ ] Create navigation data for AI pathfinding
90:- [ ] Create src/environment folder developer-guide.md
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Planning multi-file docs patch**
codex
I identified exactly 10 unchecked tasks matching what was implemented, and I’m now updating all required guides plus `tasks.md`/`recent-changes.md` so tracking is consistent with the code and tests.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/environment/developer-guide.md
# Environment Developer Guide

## Purpose
`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.

## Files
- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
- `__init__.py`: package exports for facility, collision, and navigation helpers.

## Layout Contents
- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
- Doorway connectivity between rooms via explicit `Doorway` records.
- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
- Waypoint graph and links for AI route planning.
- Spawn point records for player and bots.
- Engine-agnostic ambient + directional lighting profile.

## Integration Notes
- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
apply_patch(auto_approved=true) exited 0 in 209ms:
Success. Updated the following files:
A src/environment/developer-guide.md
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/developer-guide.md
@@ -3,3 +3,3 @@
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
@@ -9,2 +9,4 @@
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
@@ -17 +19,5 @@
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
apply_patch(auto_approved=true) exited 0 in 254ms:
Success. Updated the following files:
M src/ai/developer-guide.md
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Updating source guide with environment and AI additions**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/developer-guide.md
@@ -11,4 +11,5 @@
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
@@ -23,3 +24,8 @@
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
apply_patch(auto_approved=true) exited 0 in 262ms:
Success. Updated the following files:
M src/developer-guide.md
file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

file update:
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Updating developer guide**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md
@@ -16,3 +16,5 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
@@ -26,3 +28,4 @@
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
@@ -58,3 +61,8 @@
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
apply_patch(auto_approved=true) exited 0 in 288ms:
Success. Updated the following files:
M developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 8b48de6d5a6d0d208407498a9f7d49de16abccea..8e54792e2e79ff0dda1fae96143c404833100c9f
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,7 +14,9 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
@@ -24,7 +26,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -56,7 +59,12 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 8b48de6d5a6d0d208407498a9f7d49de16abccea..8e54792e2e79ff0dda1fae96143c404833100c9f
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,7 +14,9 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
@@ -24,7 +26,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -56,7 +59,12 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Updating tests guide**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/developer-guide.md
@@ -21,2 +21,3 @@
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 
apply_patch(auto_approved=true) exited 0 in 299ms:
Success. Updated the following files:
M tests/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 8b48de6d5a6d0d208407498a9f7d49de16abccea..8e54792e2e79ff0dda1fae96143c404833100c9f
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,7 +14,9 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
@@ -24,7 +26,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -56,7 +59,12 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 93d224b73c2fb83729e82caba23c274c6f89db2b..39bb37eac4077f0078b7f7f77330bd80f27ace40
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -19,6 +19,7 @@
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 8b48de6d5a6d0d208407498a9f7d49de16abccea..8e54792e2e79ff0dda1fae96143c404833100c9f
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,7 +14,9 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
@@ -24,7 +26,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -56,7 +59,12 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 93d224b73c2fb83729e82caba23c274c6f89db2b..39bb37eac4077f0078b7f7f77330bd80f27ace40
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -19,6 +19,7 @@
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Applying documentation updates**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tasks.md
@@ -61,9 +61,9 @@
 - [x] Implement basic bot pathfinding using navigation mesh or waypoints
-- [ ] Create tactical AI decision-making system (attack, take cover, flank)
-- [ ] Implement cover detection and usage logic
-- [ ] Create flanking behavior to approach player from multiple angles
+- [x] Create tactical AI decision-making system (attack, take cover, flank)
+- [x] Implement cover detection and usage logic
+- [x] Create flanking behavior to approach player from multiple angles
 - [x] Implement bot shooting mechanics with accuracy variance
 - [x] Add bot death handling with money drop spawning
-- [ ] Create wave spawning system for multiple bots
-- [ ] Implement bot difficulty scaling across waves
+- [x] Create wave spawning system for multiple bots
+- [x] Implement bot difficulty scaling across waves
 - [x] Create src/ai folder developer-guide.md
@@ -81,6 +81,6 @@
 
-- [ ] Create multi-room indoor facility layout using geometric primitives
-- [ ] Implement wall collision detection for player and projectiles
-- [ ] Add cover objects (crates, walls) throughout the facility
-- [ ] Create navigation data for AI pathfinding
+- [x] Create multi-room indoor facility layout using geometric primitives
+- [x] Implement wall collision detection for player and projectiles
+- [x] Add cover objects (crates, walls) throughout the facility
+- [x] Create navigation data for AI pathfinding
 - [ ] Implement room connectivity and doorways
@@ -89,3 +89,3 @@
 - [ ] Design at least 3-5 distinct rooms with tactical variety
-- [ ] Create src/environment folder developer-guide.md
+- [x] Create src/environment folder developer-guide.md
 
apply_patch(auto_approved=true) exited 0 in 319ms:
Success. Updated the following files:
M tasks.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 8b48de6d5a6d0d208407498a9f7d49de16abccea..8e54792e2e79ff0dda1fae96143c404833100c9f
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,7 +14,9 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
@@ -24,7 +26,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -56,7 +59,12 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tasks.md b/tasks.md
index 1aeae7b6a658dad9a82bf833415163e319055239..d794e1c5a8e944f779d28fdc9deedfa5b0370d84
--- a/tasks.md
+++ b/tasks.md
@@ -59,13 +59,13 @@
 
 - [x] Create Bot class with health, position, and AI state
 - [x] Implement basic bot pathfinding using navigation mesh or waypoints
-- [ ] Create tactical AI decision-making system (attack, take cover, flank)
-- [ ] Implement cover detection and usage logic
-- [ ] Create flanking behavior to approach player from multiple angles
+- [x] Create tactical AI decision-making system (attack, take cover, flank)
+- [x] Implement cover detection and usage logic
+- [x] Create flanking behavior to approach player from multiple angles
 - [x] Implement bot shooting mechanics with accuracy variance
 - [x] Add bot death handling with money drop spawning
-- [ ] Create wave spawning system for multiple bots
-- [ ] Implement bot difficulty scaling across waves
+- [x] Create wave spawning system for multiple bots
+- [x] Implement bot difficulty scaling across waves
 - [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
@@ -79,15 +79,15 @@
 
 ## Environment & Level Design
 
-- [ ] Create multi-room indoor facility layout using geometric primitives
-- [ ] Implement wall collision detection for player and projectiles
-- [ ] Add cover objects (crates, walls) throughout the facility
-- [ ] Create navigation data for AI pathfinding
+- [x] Create multi-room indoor facility layout using geometric primitives
+- [x] Implement wall collision detection for player and projectiles
+- [x] Add cover objects (crates, walls) throughout the facility
+- [x] Create navigation data for AI pathfinding
 - [ ] Implement room connectivity and doorways
 - [ ] Add environmental lighting setup
 - [ ] Create spawn points for player and bots
 - [ ] Design at least 3-5 distinct rooms with tactical variety
-- [ ] Create src/environment folder developer-guide.md
+- [x] Create src/environment folder developer-guide.md
 
 ## HUD System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 93d224b73c2fb83729e82caba23c274c6f89db2b..39bb37eac4077f0078b7f7f77330bd80f27ace40
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -19,6 +19,7 @@
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 8b48de6d5a6d0d208407498a9f7d49de16abccea..8e54792e2e79ff0dda1fae96143c404833100c9f
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,7 +14,9 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
@@ -24,7 +26,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -56,7 +59,12 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tasks.md b/tasks.md
index 1aeae7b6a658dad9a82bf833415163e319055239..d794e1c5a8e944f779d28fdc9deedfa5b0370d84
--- a/tasks.md
+++ b/tasks.md
@@ -59,13 +59,13 @@
 
 - [x] Create Bot class with health, position, and AI state
 - [x] Implement basic bot pathfinding using navigation mesh or waypoints
-- [ ] Create tactical AI decision-making system (attack, take cover, flank)
-- [ ] Implement cover detection and usage logic
-- [ ] Create flanking behavior to approach player from multiple angles
+- [x] Create tactical AI decision-making system (attack, take cover, flank)
+- [x] Implement cover detection and usage logic
+- [x] Create flanking behavior to approach player from multiple angles
 - [x] Implement bot shooting mechanics with accuracy variance
 - [x] Add bot death handling with money drop spawning
-- [ ] Create wave spawning system for multiple bots
-- [ ] Implement bot difficulty scaling across waves
+- [x] Create wave spawning system for multiple bots
+- [x] Implement bot difficulty scaling across waves
 - [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
@@ -79,15 +79,15 @@
 
 ## Environment & Level Design
 
-- [ ] Create multi-room indoor facility layout using geometric primitives
-- [ ] Implement wall collision detection for player and projectiles
-- [ ] Add cover objects (crates, walls) throughout the facility
-- [ ] Create navigation data for AI pathfinding
+- [x] Create multi-room indoor facility layout using geometric primitives
+- [x] Implement wall collision detection for player and projectiles
+- [x] Add cover objects (crates, walls) throughout the facility
+- [x] Create navigation data for AI pathfinding
 - [ ] Implement room connectivity and doorways
 - [ ] Add environmental lighting setup
 - [ ] Create spawn points for player and bots
 - [ ] Design at least 3-5 distinct rooms with tactical variety
-- [ ] Create src/environment folder developer-guide.md
+- [x] Create src/environment folder developer-guide.md
 
 ## HUD System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 93d224b73c2fb83729e82caba23c274c6f89db2b..39bb37eac4077f0078b7f7f77330bd80f27ace40
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -19,6 +19,7 @@
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Planning recent changes summary**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\recent-changes.md
@@ -1,2 +1,12 @@
-# Recent Changes
+# Recent Changes
+
+- Added `src/environment/` with a 5-room indoor facility model (`lobby`, `central_hall`, `storage`, `lab`, `security`), doorway definitions, cover placements, waypoint graph, spawn points, and engine-agnostic lighting data.
+- Implemented environment-to-collision conversion in `src/environment/collision.py`, generating doorway-aware wall AABBs plus cover collision volumes for player/projectile systems.
+- Implemented environment navigation integration in `src/environment/navigation.py` with validation and `WaypointPathfinder` construction.
+- Added tactical AI behavior in `src/ai/tactics.py`: cover detection/selection, tactical decision logic (`attack`, `take_cover`, `flank`), and flank route planning.
+- Added wave orchestration in `src/ai/waves.py`: per-wave bot count scaling, difficulty scaling, and deterministic multi-bot spawning.
+- Updated package exports in `src/ai/__init__.py` and `src/environment/__init__.py`.
+- Added `tests/test_environment_and_tactics.py` covering facility layout, doorway/collision behavior, nav pathfinding usage, tactical AI decisions, and wave scaling.
+- Updated developer guides in `src/environment/developer-guide.md`, `src/ai/developer-guide.md`, `src/developer-guide.md`, `developer-guide.md`, and `tests/developer-guide.md`.
+- Marked 10 completed tasks in `tasks.md` for environment layout/collision/nav, tactical AI, wave systems, and environment documentation.
 
apply_patch(auto_approved=true) exited 0 in 338ms:
Success. Updated the following files:
M recent-changes.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 8b48de6d5a6d0d208407498a9f7d49de16abccea..8e54792e2e79ff0dda1fae96143c404833100c9f
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,7 +14,9 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
@@ -24,7 +26,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -56,7 +59,12 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..b6f59957cb367825d4a6e589e621603f685a281a
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,12 @@
-# Recent Changes
+# Recent Changes
+
+- Added `src/environment/` with a 5-room indoor facility model (`lobby`, `central_hall`, `storage`, `lab`, `security`), doorway definitions, cover placements, waypoint graph, spawn points, and engine-agnostic lighting data.
+- Implemented environment-to-collision conversion in `src/environment/collision.py`, generating doorway-aware wall AABBs plus cover collision volumes for player/projectile systems.
+- Implemented environment navigation integration in `src/environment/navigation.py` with validation and `WaypointPathfinder` construction.
+- Added tactical AI behavior in `src/ai/tactics.py`: cover detection/selection, tactical decision logic (`attack`, `take_cover`, `flank`), and flank route planning.
+- Added wave orchestration in `src/ai/waves.py`: per-wave bot count scaling, difficulty scaling, and deterministic multi-bot spawning.
+- Updated package exports in `src/ai/__init__.py` and `src/environment/__init__.py`.
+- Added `tests/test_environment_and_tactics.py` covering facility layout, doorway/collision behavior, nav pathfinding usage, tactical AI decisions, and wave scaling.
+- Updated developer guides in `src/environment/developer-guide.md`, `src/ai/developer-guide.md`, `src/developer-guide.md`, `developer-guide.md`, and `tests/developer-guide.md`.
+- Marked 10 completed tasks in `tasks.md` for environment layout/collision/nav, tactical AI, wave systems, and environment documentation.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tasks.md b/tasks.md
index 1aeae7b6a658dad9a82bf833415163e319055239..d794e1c5a8e944f779d28fdc9deedfa5b0370d84
--- a/tasks.md
+++ b/tasks.md
@@ -59,13 +59,13 @@
 
 - [x] Create Bot class with health, position, and AI state
 - [x] Implement basic bot pathfinding using navigation mesh or waypoints
-- [ ] Create tactical AI decision-making system (attack, take cover, flank)
-- [ ] Implement cover detection and usage logic
-- [ ] Create flanking behavior to approach player from multiple angles
+- [x] Create tactical AI decision-making system (attack, take cover, flank)
+- [x] Implement cover detection and usage logic
+- [x] Create flanking behavior to approach player from multiple angles
 - [x] Implement bot shooting mechanics with accuracy variance
 - [x] Add bot death handling with money drop spawning
-- [ ] Create wave spawning system for multiple bots
-- [ ] Implement bot difficulty scaling across waves
+- [x] Create wave spawning system for multiple bots
+- [x] Implement bot difficulty scaling across waves
 - [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
@@ -79,15 +79,15 @@
 
 ## Environment & Level Design
 
-- [ ] Create multi-room indoor facility layout using geometric primitives
-- [ ] Implement wall collision detection for player and projectiles
-- [ ] Add cover objects (crates, walls) throughout the facility
-- [ ] Create navigation data for AI pathfinding
+- [x] Create multi-room indoor facility layout using geometric primitives
+- [x] Implement wall collision detection for player and projectiles
+- [x] Add cover objects (crates, walls) throughout the facility
+- [x] Create navigation data for AI pathfinding
 - [ ] Implement room connectivity and doorways
 - [ ] Add environmental lighting setup
 - [ ] Create spawn points for player and bots
 - [ ] Design at least 3-5 distinct rooms with tactical variety
-- [ ] Create src/environment folder developer-guide.md
+- [x] Create src/environment folder developer-guide.md
 
 ## HUD System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 93d224b73c2fb83729e82caba23c274c6f89db2b..39bb37eac4077f0078b7f7f77330bd80f27ace40
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -19,6 +19,7 @@
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 8b48de6d5a6d0d208407498a9f7d49de16abccea..8e54792e2e79ff0dda1fae96143c404833100c9f
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,7 +14,9 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
@@ -24,7 +26,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -56,7 +59,12 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..b6f59957cb367825d4a6e589e621603f685a281a
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,12 @@
-# Recent Changes
+# Recent Changes
+
+- Added `src/environment/` with a 5-room indoor facility model (`lobby`, `central_hall`, `storage`, `lab`, `security`), doorway definitions, cover placements, waypoint graph, spawn points, and engine-agnostic lighting data.
+- Implemented environment-to-collision conversion in `src/environment/collision.py`, generating doorway-aware wall AABBs plus cover collision volumes for player/projectile systems.
+- Implemented environment navigation integration in `src/environment/navigation.py` with validation and `WaypointPathfinder` construction.
+- Added tactical AI behavior in `src/ai/tactics.py`: cover detection/selection, tactical decision logic (`attack`, `take_cover`, `flank`), and flank route planning.
+- Added wave orchestration in `src/ai/waves.py`: per-wave bot count scaling, difficulty scaling, and deterministic multi-bot spawning.
+- Updated package exports in `src/ai/__init__.py` and `src/environment/__init__.py`.
+- Added `tests/test_environment_and_tactics.py` covering facility layout, doorway/collision behavior, nav pathfinding usage, tactical AI decisions, and wave scaling.
+- Updated developer guides in `src/environment/developer-guide.md`, `src/ai/developer-guide.md`, `src/developer-guide.md`, `developer-guide.md`, and `tests/developer-guide.md`.
+- Marked 10 completed tasks in `tasks.md` for environment layout/collision/nav, tactical AI, wave systems, and environment documentation.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tasks.md b/tasks.md
index 1aeae7b6a658dad9a82bf833415163e319055239..d794e1c5a8e944f779d28fdc9deedfa5b0370d84
--- a/tasks.md
+++ b/tasks.md
@@ -59,13 +59,13 @@
 
 - [x] Create Bot class with health, position, and AI state
 - [x] Implement basic bot pathfinding using navigation mesh or waypoints
-- [ ] Create tactical AI decision-making system (attack, take cover, flank)
-- [ ] Implement cover detection and usage logic
-- [ ] Create flanking behavior to approach player from multiple angles
+- [x] Create tactical AI decision-making system (attack, take cover, flank)
+- [x] Implement cover detection and usage logic
+- [x] Create flanking behavior to approach player from multiple angles
 - [x] Implement bot shooting mechanics with accuracy variance
 - [x] Add bot death handling with money drop spawning
-- [ ] Create wave spawning system for multiple bots
-- [ ] Implement bot difficulty scaling across waves
+- [x] Create wave spawning system for multiple bots
+- [x] Implement bot difficulty scaling across waves
 - [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
@@ -79,15 +79,15 @@
 
 ## Environment & Level Design
 
-- [ ] Create multi-room indoor facility layout using geometric primitives
-- [ ] Implement wall collision detection for player and projectiles
-- [ ] Add cover objects (crates, walls) throughout the facility
-- [ ] Create navigation data for AI pathfinding
+- [x] Create multi-room indoor facility layout using geometric primitives
+- [x] Implement wall collision detection for player and projectiles
+- [x] Add cover objects (crates, walls) throughout the facility
+- [x] Create navigation data for AI pathfinding
 - [ ] Implement room connectivity and doorways
 - [ ] Add environmental lighting setup
 - [ ] Create spawn points for player and bots
 - [ ] Design at least 3-5 distinct rooms with tactical variety
-- [ ] Create src/environment folder developer-guide.md
+- [x] Create src/environment folder developer-guide.md
 
 ## HUD System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 93d224b73c2fb83729e82caba23c274c6f89db2b..39bb37eac4077f0078b7f7f77330bd80f27ace40
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -19,6 +19,7 @@
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Validating test pass**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 553ms:
........................................                                 [100%]
40 passed in 0.07s
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 8b48de6d5a6d0d208407498a9f7d49de16abccea..8e54792e2e79ff0dda1fae96143c404833100c9f
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,7 +14,9 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
@@ -24,7 +26,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -56,7 +59,12 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..b6f59957cb367825d4a6e589e621603f685a281a
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,12 @@
-# Recent Changes
+# Recent Changes
+
+- Added `src/environment/` with a 5-room indoor facility model (`lobby`, `central_hall`, `storage`, `lab`, `security`), doorway definitions, cover placements, waypoint graph, spawn points, and engine-agnostic lighting data.
+- Implemented environment-to-collision conversion in `src/environment/collision.py`, generating doorway-aware wall AABBs plus cover collision volumes for player/projectile systems.
+- Implemented environment navigation integration in `src/environment/navigation.py` with validation and `WaypointPathfinder` construction.
+- Added tactical AI behavior in `src/ai/tactics.py`: cover detection/selection, tactical decision logic (`attack`, `take_cover`, `flank`), and flank route planning.
+- Added wave orchestration in `src/ai/waves.py`: per-wave bot count scaling, difficulty scaling, and deterministic multi-bot spawning.
+- Updated package exports in `src/ai/__init__.py` and `src/environment/__init__.py`.
+- Added `tests/test_environment_and_tactics.py` covering facility layout, doorway/collision behavior, nav pathfinding usage, tactical AI decisions, and wave scaling.
+- Updated developer guides in `src/environment/developer-guide.md`, `src/ai/developer-guide.md`, `src/developer-guide.md`, `developer-guide.md`, and `tests/developer-guide.md`.
+- Marked 10 completed tasks in `tasks.md` for environment layout/collision/nav, tactical AI, wave systems, and environment documentation.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tasks.md b/tasks.md
index 1aeae7b6a658dad9a82bf833415163e319055239..d794e1c5a8e944f779d28fdc9deedfa5b0370d84
--- a/tasks.md
+++ b/tasks.md
@@ -59,13 +59,13 @@
 
 - [x] Create Bot class with health, position, and AI state
 - [x] Implement basic bot pathfinding using navigation mesh or waypoints
-- [ ] Create tactical AI decision-making system (attack, take cover, flank)
-- [ ] Implement cover detection and usage logic
-- [ ] Create flanking behavior to approach player from multiple angles
+- [x] Create tactical AI decision-making system (attack, take cover, flank)
+- [x] Implement cover detection and usage logic
+- [x] Create flanking behavior to approach player from multiple angles
 - [x] Implement bot shooting mechanics with accuracy variance
 - [x] Add bot death handling with money drop spawning
-- [ ] Create wave spawning system for multiple bots
-- [ ] Implement bot difficulty scaling across waves
+- [x] Create wave spawning system for multiple bots
+- [x] Implement bot difficulty scaling across waves
 - [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
@@ -79,15 +79,15 @@
 
 ## Environment & Level Design
 
-- [ ] Create multi-room indoor facility layout using geometric primitives
-- [ ] Implement wall collision detection for player and projectiles
-- [ ] Add cover objects (crates, walls) throughout the facility
-- [ ] Create navigation data for AI pathfinding
+- [x] Create multi-room indoor facility layout using geometric primitives
+- [x] Implement wall collision detection for player and projectiles
+- [x] Add cover objects (crates, walls) throughout the facility
+- [x] Create navigation data for AI pathfinding
 - [ ] Implement room connectivity and doorways
 - [ ] Add environmental lighting setup
 - [ ] Create spawn points for player and bots
 - [ ] Design at least 3-5 distinct rooms with tactical variety
-- [ ] Create src/environment folder developer-guide.md
+- [x] Create src/environment folder developer-guide.md
 
 ## HUD System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 93d224b73c2fb83729e82caba23c274c6f89db2b..39bb37eac4077f0078b7f7f77330bd80f27ace40
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -19,6 +19,7 @@
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Reviewing changed files**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'git status --short' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 194ms:
 M .agentharness/git-commit-message.txt
 D .codex_last_message.txt
 M developer-guide.md
 M recent-changes.md
 M src/ai/__init__.py
 M src/ai/developer-guide.md
 M src/developer-guide.md
 M tasks.md
 M tests/developer-guide.md
?? .agentharness/live-llm/llm_20260208_183927_00cd3d9c.log
?? src/ai/tactics.py
?? src/ai/waves.py
?? src/environment/
?? tests/test_environment_and_tactics.py
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 8b48de6d5a6d0d208407498a9f7d49de16abccea..8e54792e2e79ff0dda1fae96143c404833100c9f
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,7 +14,9 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
@@ -24,7 +26,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -56,7 +59,12 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..b6f59957cb367825d4a6e589e621603f685a281a
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,12 @@
-# Recent Changes
+# Recent Changes
+
+- Added `src/environment/` with a 5-room indoor facility model (`lobby`, `central_hall`, `storage`, `lab`, `security`), doorway definitions, cover placements, waypoint graph, spawn points, and engine-agnostic lighting data.
+- Implemented environment-to-collision conversion in `src/environment/collision.py`, generating doorway-aware wall AABBs plus cover collision volumes for player/projectile systems.
+- Implemented environment navigation integration in `src/environment/navigation.py` with validation and `WaypointPathfinder` construction.
+- Added tactical AI behavior in `src/ai/tactics.py`: cover detection/selection, tactical decision logic (`attack`, `take_cover`, `flank`), and flank route planning.
+- Added wave orchestration in `src/ai/waves.py`: per-wave bot count scaling, difficulty scaling, and deterministic multi-bot spawning.
+- Updated package exports in `src/ai/__init__.py` and `src/environment/__init__.py`.
+- Added `tests/test_environment_and_tactics.py` covering facility layout, doorway/collision behavior, nav pathfinding usage, tactical AI decisions, and wave scaling.
+- Updated developer guides in `src/environment/developer-guide.md`, `src/ai/developer-guide.md`, `src/developer-guide.md`, `developer-guide.md`, and `tests/developer-guide.md`.
+- Marked 10 completed tasks in `tasks.md` for environment layout/collision/nav, tactical AI, wave systems, and environment documentation.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tasks.md b/tasks.md
index 1aeae7b6a658dad9a82bf833415163e319055239..d794e1c5a8e944f779d28fdc9deedfa5b0370d84
--- a/tasks.md
+++ b/tasks.md
@@ -59,13 +59,13 @@
 
 - [x] Create Bot class with health, position, and AI state
 - [x] Implement basic bot pathfinding using navigation mesh or waypoints
-- [ ] Create tactical AI decision-making system (attack, take cover, flank)
-- [ ] Implement cover detection and usage logic
-- [ ] Create flanking behavior to approach player from multiple angles
+- [x] Create tactical AI decision-making system (attack, take cover, flank)
+- [x] Implement cover detection and usage logic
+- [x] Create flanking behavior to approach player from multiple angles
 - [x] Implement bot shooting mechanics with accuracy variance
 - [x] Add bot death handling with money drop spawning
-- [ ] Create wave spawning system for multiple bots
-- [ ] Implement bot difficulty scaling across waves
+- [x] Create wave spawning system for multiple bots
+- [x] Implement bot difficulty scaling across waves
 - [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
@@ -79,15 +79,15 @@
 
 ## Environment & Level Design
 
-- [ ] Create multi-room indoor facility layout using geometric primitives
-- [ ] Implement wall collision detection for player and projectiles
-- [ ] Add cover objects (crates, walls) throughout the facility
-- [ ] Create navigation data for AI pathfinding
+- [x] Create multi-room indoor facility layout using geometric primitives
+- [x] Implement wall collision detection for player and projectiles
+- [x] Add cover objects (crates, walls) throughout the facility
+- [x] Create navigation data for AI pathfinding
 - [ ] Implement room connectivity and doorways
 - [ ] Add environmental lighting setup
 - [ ] Create spawn points for player and bots
 - [ ] Design at least 3-5 distinct rooms with tactical variety
-- [ ] Create src/environment folder developer-guide.md
+- [x] Create src/environment folder developer-guide.md
 
 ## HUD System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 93d224b73c2fb83729e82caba23c274c6f89db2b..39bb37eac4077f0078b7f7f77330bd80f27ace40
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -19,6 +19,7 @@
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate


thinking
**Noticing unexpected environment changes**
codex
Implemented a batch of 10 previously incomplete tasks and updated tracking/docs as requested.

Completed and marked in `tasks.md`:
1. Tactical AI decision-making (`attack`, `take_cover`, `flank`)
2. Cover detection and usage logic
3. Flanking behavior
4. Wave spawning system for multiple bots
5. Bot difficulty scaling across waves
6. Multi-room indoor facility layout
7. Wall collision detection for player/projectiles (via generated collision world)
8. Cover objects throughout facility
9. Navigation data for AI pathfinding
10. `src/environment` developer guide creation

Code added/updated:
- `src/environment/facility.py`
- `src/environment/collision.py`
- `src/environment/navigation.py`
- `src/environment/__init__.py`
- `src/environment/developer-guide.md`
- `src/ai/tactics.py`
- `src/ai/waves.py`
- `src/ai/__init__.py`
- `tests/test_environment_and_tactics.py`
- `src/ai/developer-guide.md`
- `src/developer-guide.md`
- `developer-guide.md`
- `tests/developer-guide.md`
- `tasks.md`
- `recent-changes.md`

Validation:
- Ran `pytest -q`
- Result: `40 passed`

Also noticed unrelated workspace changes not authored by me in `.agentharness/*` and `.codex_last_message.txt`. I left them untouched.
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 8b48de6d5a6d0d208407498a9f7d49de16abccea..8e54792e2e79ff0dda1fae96143c404833100c9f
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -14,7 +14,9 @@
 - Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
 - Projectile entities and physics for bullets, pellets, and rockets
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
-- Bot runtime model with stateful health/death handling, shot variance, and waypoint pathfinding
+- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
+- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
@@ -24,7 +26,8 @@
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
   - `src/ui/`: shop wheel layout + controller logic for open/close, pause synchronization, and purchasing/equipping.
-  - `src/ai/`: bot runtime model, bot aiming variance helper, and waypoint graph pathfinding.
+  - `src/ai/`: bot runtime model, bot aiming variance helper, tactical decisions, and wave progression systems.
+  - `src/environment/`: room/doorway/cover layout definitions plus collision/nav data builders.
   - `src/economy/`: money pickup entities, spawn/update/collect systems, and visual style definitions.
 - `assets/`: static assets (models, audio, textures). Currently placeholder-only.
 - `config/`: centralized runtime configuration modules.
@@ -56,7 +59,12 @@
 - `ProjectilePhysicsSystem` advances projectile motion and deactivates projectiles that hit walls or leave world bounds.
 - `ShopWheelController` renders shop entry state (owned/equipped/affordable), toggles pause when opened, and enforces money checks for purchases.
 - `Bot` supports health/state transitions, cooldown-aware shooting with accuracy variance, and money-drop spawning hooks.
+- `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
+- `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
+- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
+- `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 
 ## Development Notes
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..b6f59957cb367825d4a6e589e621603f685a281a
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,12 @@
-# Recent Changes
+# Recent Changes
+
+- Added `src/environment/` with a 5-room indoor facility model (`lobby`, `central_hall`, `storage`, `lab`, `security`), doorway definitions, cover placements, waypoint graph, spawn points, and engine-agnostic lighting data.
+- Implemented environment-to-collision conversion in `src/environment/collision.py`, generating doorway-aware wall AABBs plus cover collision volumes for player/projectile systems.
+- Implemented environment navigation integration in `src/environment/navigation.py` with validation and `WaypointPathfinder` construction.
+- Added tactical AI behavior in `src/ai/tactics.py`: cover detection/selection, tactical decision logic (`attack`, `take_cover`, `flank`), and flank route planning.
+- Added wave orchestration in `src/ai/waves.py`: per-wave bot count scaling, difficulty scaling, and deterministic multi-bot spawning.
+- Updated package exports in `src/ai/__init__.py` and `src/environment/__init__.py`.
+- Added `tests/test_environment_and_tactics.py` covering facility layout, doorway/collision behavior, nav pathfinding usage, tactical AI decisions, and wave scaling.
+- Updated developer guides in `src/environment/developer-guide.md`, `src/ai/developer-guide.md`, `src/developer-guide.md`, `developer-guide.md`, and `tests/developer-guide.md`.
+- Marked 10 completed tasks in `tasks.md` for environment layout/collision/nav, tactical AI, wave systems, and environment documentation.
 
diff --git a/src/ai/__init__.py b/src/ai/__init__.py
index 52e964abdc34773f86ca451f900c8b5d4507cb5f..74901ae182b8aabc4e2395d86b36b89918ccbd56
--- a/src/ai/__init__.py
+++ b/src/ai/__init__.py
@@ -3,10 +3,19 @@
 from src.ai.bot import Bot, BotAIState
 from src.ai.combat import vary_direction_with_accuracy
 from src.ai.navigation import WaypointPathfinder
+from src.ai.tactics import CoverPlan, TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDifficulty, WaveDirector
 
 __all__ = [
     "Bot",
     "BotAIState",
     "WaypointPathfinder",
     "vary_direction_with_accuracy",
+    "TacticalAction",
+    "CoverPlan",
+    "choose_tactical_action",
+    "find_cover_plan",
+    "build_flank_route",
+    "WaveDirector",
+    "WaveDifficulty",
 ]
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 9e763bd3d5873df5c3f36f439a2d1d4cb1d29de6..9947359cac1aa1d1f0ed74e70f5fafde1d52354b
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -1,12 +1,14 @@
 # AI Developer Guide
 
 ## Purpose
-`src/ai/` contains bot runtime behavior, bot aiming logic, and waypoint pathfinding.
+`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.
 
 ## Files
 - `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
 - `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
 - `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
+- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
+- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
 - `__init__.py`: package exports for AI modules.
 
 ## Key Behaviors
@@ -15,3 +17,7 @@
 - `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
+- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover.
+- `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
+- `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..13572adeaa723f28184789ba34aa4f7e60613554
--- /dev/null
+++ b/src/ai/tactics.py
@@ -0,0 +1,162 @@
+"""Tactical decision-making, cover usage, and flanking helpers."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from enum import Enum
+from math import sqrt
+
+from src.ai.bot import Bot
+from src.environment.facility import CoverObject
+
+
+Vector3 = tuple[float, float, float]
+
+
+class TacticalAction(str, Enum):
+    """Primary tactical actions a bot can select."""
+
+    ATTACK = "attack"
+    TAKE_COVER = "take_cover"
+    FLANK = "flank"
+
+
+@dataclass(frozen=True)
+class CoverPlan:
+    """Selected cover target and movement anchor for a bot."""
+
+    cover_id: str
+    anchor_position: Vector3
+    distance_from_bot: float
+
+
+def _distance_2d(a: Vector3, b: Vector3) -> float:
+    dx = a[0] - b[0]
+    dz = a[2] - b[2]
+    return sqrt((dx * dx) + (dz * dz))
+
+
+def _segment_point_distance_2d(a: Vector3, b: Vector3, p: Vector3) -> float:
+    ab_x = b[0] - a[0]
+    ab_z = b[2] - a[2]
+    ap_x = p[0] - a[0]
+    ap_z = p[2] - a[2]
+    ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
+    if ab_len_sq <= 1e-9:
+        return _distance_2d(a, p)
+    t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
+    t = max(0.0, min(1.0, t))
+    closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
+    return _distance_2d(closest, p)
+
+
+def _cover_blocks_line_of_fire(
+    *,
+    cover: CoverObject,
+    from_position: Vector3,
+    to_position: Vector3,
+) -> bool:
+    center = cover.center
+    half_extent_x = (cover.max_corner[0] - cover.min_corner[0]) * 0.5
+    half_extent_z = (cover.max_corner[2] - cover.min_corner[2]) * 0.5
+    radius = sqrt((half_extent_x * half_extent_x) + (half_extent_z * half_extent_z))
+    return _segment_point_distance_2d(from_position, to_position, center) <= (radius + 0.35)
+
+
+def _cover_anchor(cover: CoverObject, player_position: Vector3, stand_off: float = 0.9) -> Vector3:
+    center = cover.center
+    dir_x = center[0] - player_position[0]
+    dir_z = center[2] - player_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return center
+    nx = dir_x / length
+    nz = dir_z / length
+    return (center[0] + (nx * stand_off), center[1], center[2] + (nz * stand_off))
+
+
+def find_cover_plan(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    max_cover_distance: float = 12.0,
+) -> CoverPlan | None:
+    """Pick the nearest useful cover that can break line-of-fire to player."""
+    chosen: CoverPlan | None = None
+    for cover in cover_objects:
+        anchor = _cover_anchor(cover, player_position)
+        distance = _distance_2d(bot_position, anchor)
+        if distance > max_cover_distance:
+            continue
+        if not _cover_blocks_line_of_fire(cover=cover, from_position=anchor, to_position=player_position):
+            continue
+        if chosen is None or distance < chosen.distance_from_bot:
+            chosen = CoverPlan(
+                cover_id=cover.cover_id,
+                anchor_position=anchor,
+                distance_from_bot=distance,
+            )
+    return chosen
+
+
+def choose_tactical_action(
+    *,
+    bot: Bot,
+    player_position: Vector3,
+    cover_objects: list[CoverObject],
+    ally_count: int,
+    low_health_threshold: int = 35,
+    attack_range: float = 14.0,
+) -> TacticalAction:
+    """Choose attack/cover/flank based on bot state, health, and surroundings."""
+    if not bot.is_alive:
+        return TacticalAction.TAKE_COVER
+
+    distance_to_player = _distance_2d(bot.position, player_position)
+    cover = find_cover_plan(
+        bot_position=bot.position,
+        player_position=player_position,
+        cover_objects=cover_objects,
+    )
+    if bot.health <= low_health_threshold and cover is not None:
+        return TacticalAction.TAKE_COVER
+    if ally_count >= 1 and distance_to_player <= (attack_range * 1.5):
+        return TacticalAction.FLANK
+    if distance_to_player <= attack_range:
+        return TacticalAction.ATTACK
+    if cover is not None:
+        return TacticalAction.TAKE_COVER
+    return TacticalAction.ATTACK
+
+
+def build_flank_route(
+    *,
+    bot_position: Vector3,
+    player_position: Vector3,
+    flank_radius: float = 5.0,
+) -> list[Vector3]:
+    """Create a two-point flank path that approaches the player from a side angle."""
+    dir_x = player_position[0] - bot_position[0]
+    dir_z = player_position[2] - bot_position[2]
+    length = sqrt((dir_x * dir_x) + (dir_z * dir_z))
+    if length <= 1e-9:
+        return [bot_position, player_position]
+
+    nx = dir_x / length
+    nz = dir_z / length
+    left = (-nz, nx)
+    right = (nz, -nx)
+    left_candidate = (
+        player_position[0] + (left[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (left[1] * flank_radius),
+    )
+    right_candidate = (
+        player_position[0] + (right[0] * flank_radius),
+        player_position[1],
+        player_position[2] + (right[1] * flank_radius),
+    )
+    if _distance_2d(bot_position, left_candidate) <= _distance_2d(bot_position, right_candidate):
+        return [left_candidate, player_position]
+    return [right_candidate, player_position]
diff --git a/src/ai/waves.py b/src/ai/waves.py
new file mode 100644
index 0000000000000000000000000000000000000000..16a65bf2554eb881720a532486b5b71d1d4ba95e
--- /dev/null
+++ b/src/ai/waves.py
@@ -0,0 +1,81 @@
+"""Wave spawning and difficulty scaling for bot encounters."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from random import Random
+
+from src.ai.bot import Bot
+from src.weapons.assault_rifle import AssaultRifle
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class WaveDifficulty:
+    """Difficulty profile for a single wave."""
+
+    wave_number: int
+    bot_health: int
+    accuracy_degrees: float
+    fire_rate_multiplier: float
+
+
+class WaveDirector:
+    """Provides deterministic wave sizes and bot stat scaling."""
+
+    def __init__(
+        self,
+        *,
+        base_bot_count: int = 3,
+        max_extra_bots: int = 10,
+    ) -> None:
+        self.base_bot_count = base_bot_count
+        self.max_extra_bots = max_extra_bots
+
+    def bot_count_for_wave(self, wave_number: int) -> int:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        extra = min(self.max_extra_bots, (wave_number - 1) * 2)
+        return self.base_bot_count + extra
+
+    def difficulty_for_wave(self, wave_number: int) -> WaveDifficulty:
+        if wave_number <= 0:
+            raise ValueError("wave_number must be positive.")
+        health = 100 + ((wave_number - 1) * 12)
+        accuracy = max(0.8, 4.5 - ((wave_number - 1) * 0.35))
+        fire_rate_multiplier = 1.0 + ((wave_number - 1) * 0.06)
+        return WaveDifficulty(
+            wave_number=wave_number,
+            bot_health=health,
+            accuracy_degrees=accuracy,
+            fire_rate_multiplier=fire_rate_multiplier,
+        )
+
+    def spawn_wave(
+        self,
+        *,
+        wave_number: int,
+        spawn_positions: list[Vector3],
+        rng: Random,
+    ) -> list[Bot]:
+        """Spawn a wave of bots with scaled health and weapon fire rates."""
+        if not spawn_positions:
+            raise ValueError("spawn_positions must not be empty.")
+        difficulty = self.difficulty_for_wave(wave_number)
+        count = self.bot_count_for_wave(wave_number)
+        bots: list[Bot] = []
+        for index in range(count):
+            position = spawn_positions[rng.randrange(0, len(spawn_positions))]
+            weapon = AssaultRifle()
+            weapon.fire_rate *= difficulty.fire_rate_multiplier
+            bot = Bot(
+                bot_id=f"wave-{wave_number}-bot-{index + 1}",
+                max_health=difficulty.bot_health,
+                health=difficulty.bot_health,
+                position=position,
+                weapon=weapon,
+            )
+            bots.append(bot)
+        return bots
diff --git a/src/developer-guide.md b/src/developer-guide.md
index 77e62df05372fa290a2afc515b54f59d61013a14..bc5891e2d5517f75cd51462644359398734f5546
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -9,8 +9,9 @@
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
 - `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
-- `ai/`: bot runtime model, bot shot-accuracy variance helpers, and waypoint pathfinding.
+- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
+- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -21,5 +22,10 @@
 6. `projectiles.physics.ProjectilePhysicsSystem` advances active projectiles and resolves wall/bounds collisions.
 7. Hit-scan fire paths use `core.raycasting.RaycastingSystem` to resolve nearest target hits.
 8. `core.input_handler.InputHandler` emits a `toggle_shop` action on `B` key press edges for `ui.shop_wheel.ShopWheelController` consumption.
-9. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
-10. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
+9. `environment.create_default_facility_layout()` provides rooms/doorways/cover/waypoints as a single world source.
+10. `environment.build_collision_world(...)` generates wall/cover AABBs for movement and projectile collision.
+11. `environment.build_waypoint_pathfinder(...)` creates pathfinding data aligned with the same facility layout.
+12. `ai.bot.Bot` instances can fire at players using inaccuracy-aware aim and spawn money drops on death.
+13. `ai.tactics` chooses between attack/cover/flank and computes flanking approach routes.
+14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
+15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
diff --git a/src/environment/__init__.py b/src/environment/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb8259724c49c3bd1646c255dccfd5616416f3ab
--- /dev/null
+++ b/src/environment/__init__.py
@@ -0,0 +1,25 @@
+"""Environment layout and collision exports."""
+
+from src.environment.collision import build_collision_world
+from src.environment.facility import (
+    CoverObject,
+    Doorway,
+    FacilityLayout,
+    LightingSetup,
+    Room,
+    SpawnPoint,
+    create_default_facility_layout,
+)
+from src.environment.navigation import build_waypoint_pathfinder
+
+__all__ = [
+    "Room",
+    "Doorway",
+    "CoverObject",
+    "SpawnPoint",
+    "LightingSetup",
+    "FacilityLayout",
+    "create_default_facility_layout",
+    "build_collision_world",
+    "build_waypoint_pathfinder",
+]
diff --git a/src/environment/collision.py b/src/environment/collision.py
new file mode 100644
index 0000000000000000000000000000000000000000..fbbaf8e315b16edc9e1fb65967ec3c45b01399b9
--- /dev/null
+++ b/src/environment/collision.py
@@ -0,0 +1,117 @@
+"""Build collision volumes from a facility layout."""
+
+from __future__ import annotations
+
+from src.core.collision import AABB, CollisionWorld
+from src.environment.facility import FacilityLayout, Room
+
+
+EPSILON = 1e-5
+
+
+def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
+    """Subtract opening ranges from a wall segment range."""
+    segments = [(start, end)]
+    for cut_min, cut_max in cuts:
+        if cut_max <= cut_min:
+            continue
+        next_segments: list[tuple[float, float]] = []
+        for seg_min, seg_max in segments:
+            if cut_max <= seg_min or cut_min >= seg_max:
+                next_segments.append((seg_min, seg_max))
+                continue
+            if cut_min > seg_min:
+                next_segments.append((seg_min, cut_min))
+            if cut_max < seg_max:
+                next_segments.append((cut_max, seg_max))
+        segments = next_segments
+    return [(seg_min, seg_max) for seg_min, seg_max in segments if (seg_max - seg_min) > EPSILON]
+
+
+def _wall_openings_for_room(layout: FacilityLayout, room: Room, axis: str, wall_value: float) -> list[tuple[float, float]]:
+    openings: list[tuple[float, float]] = []
+    for doorway in layout.doorways:
+        if doorway.wall_axis != axis:
+            continue
+        if abs(doorway.wall_value - wall_value) > EPSILON:
+            continue
+        if doorway.room_a != room.room_id and doorway.room_b != room.room_id:
+            continue
+        openings.append((doorway.span_min, doorway.span_max))
+    return openings
+
+
+def _build_room_wall_boxes(
+    *,
+    layout: FacilityLayout,
+    room: Room,
+    wall_thickness: float,
+) -> list[AABB]:
+    half_thickness = wall_thickness * 0.5
+    floor_y = room.floor_y
+    ceiling_y = room.floor_y + layout.wall_height
+    boxes: list[AABB] = []
+
+    def add_x_wall(x_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "x", x_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(x_value - half_thickness, floor_y, cut_min),
+                    max_corner=(x_value + half_thickness, ceiling_y, cut_max),
+                )
+            )
+
+    def add_z_wall(z_value: float, span_min: float, span_max: float) -> None:
+        openings = _wall_openings_for_room(layout, room, "z", z_value)
+        for cut_min, cut_max in _interval_subtract(span_min, span_max, openings):
+            boxes.append(
+                AABB(
+                    min_corner=(cut_min, floor_y, z_value - half_thickness),
+                    max_corner=(cut_max, ceiling_y, z_value + half_thickness),
+                )
+            )
+
+    add_x_wall(room.min_x, room.min_z, room.max_z)
+    add_x_wall(room.max_x, room.min_z, room.max_z)
+    add_z_wall(room.min_z, room.min_x, room.max_x)
+    add_z_wall(room.max_z, room.min_x, room.max_x)
+    return boxes
+
+
+def build_collision_world(
+    layout: FacilityLayout,
+    *,
+    world_margin: float = 2.0,
+    wall_thickness: float = 0.4,
+) -> CollisionWorld:
+    """Convert rooms/doorways/cover into a collision world for gameplay systems."""
+    if wall_thickness <= 0.0:
+        raise ValueError("wall_thickness must be positive.")
+
+    static_walls: list[AABB] = []
+    min_x = float("inf")
+    min_y = float("inf")
+    min_z = float("inf")
+    max_x = float("-inf")
+    max_y = float("-inf")
+    max_z = float("-inf")
+
+    for room in layout.rooms.values():
+        min_x = min(min_x, room.min_x)
+        min_y = min(min_y, room.floor_y)
+        min_z = min(min_z, room.min_z)
+        max_x = max(max_x, room.max_x)
+        max_y = max(max_y, room.floor_y + layout.wall_height)
+        max_z = max(max_z, room.max_z)
+        static_walls.extend(_build_room_wall_boxes(layout=layout, room=room, wall_thickness=wall_thickness))
+
+    for cover in layout.cover_objects:
+        if cover.blocks_movement:
+            static_walls.append(AABB(min_corner=cover.min_corner, max_corner=cover.max_corner))
+
+    bounds = AABB(
+        min_corner=(min_x - world_margin, min_y - 1.0, min_z - world_margin),
+        max_corner=(max_x + world_margin, max_y + 2.0, max_z + world_margin),
+    )
+    return CollisionWorld(world_bounds=bounds, static_walls=static_walls)
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
new file mode 100644
index 0000000000000000000000000000000000000000..57e549bdbe14926f8fa1119ae0b3dc31126c1937
--- /dev/null
+++ b/src/environment/developer-guide.md
@@ -0,0 +1,23 @@
+# Environment Developer Guide
+
+## Purpose
+`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
+
+## Files
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
+- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
+- `__init__.py`: package exports for facility, collision, and navigation helpers.
+
+## Layout Contents
+- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
+- Doorway connectivity between rooms via explicit `Doorway` records.
+- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
+- Waypoint graph and links for AI route planning.
+- Spawn point records for player and bots.
+- Engine-agnostic ambient + directional lighting profile.
+
+## Integration Notes
+- Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
+- Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
+- Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
diff --git a/src/environment/facility.py b/src/environment/facility.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f228f285391dccd8591ce3d4929f5f939b9ac9d
--- /dev/null
+++ b/src/environment/facility.py
@@ -0,0 +1,248 @@
+"""Indoor facility layout primitives used by environment and AI systems."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Literal
+
+
+Vector3 = tuple[float, float, float]
+
+
+@dataclass(frozen=True)
+class Room:
+    """Axis-aligned rectangular room footprint."""
+
+    room_id: str
+    min_x: float
+    max_x: float
+    min_z: float
+    max_z: float
+    floor_y: float = 0.0
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_x + self.max_x) * 0.5,
+            self.floor_y,
+            (self.min_z + self.max_z) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class Doorway:
+    """Opening between two rooms along a shared wall."""
+
+    doorway_id: str
+    room_a: str
+    room_b: str
+    wall_axis: Literal["x", "z"]
+    wall_value: float
+    center: float
+    width: float
+
+    @property
+    def span_min(self) -> float:
+        return self.center - (self.width * 0.5)
+
+    @property
+    def span_max(self) -> float:
+        return self.center + (self.width * 0.5)
+
+
+@dataclass(frozen=True)
+class CoverObject:
+    """Simple geometric cover object represented as an AABB prism."""
+
+    cover_id: str
+    kind: Literal["crate", "pillar", "barrier"]
+    min_corner: Vector3
+    max_corner: Vector3
+    blocks_movement: bool = True
+
+    @property
+    def center(self) -> Vector3:
+        return (
+            (self.min_corner[0] + self.max_corner[0]) * 0.5,
+            (self.min_corner[1] + self.max_corner[1]) * 0.5,
+            (self.min_corner[2] + self.max_corner[2]) * 0.5,
+        )
+
+
+@dataclass(frozen=True)
+class SpawnPoint:
+    """Named spawn point for player or bots."""
+
+    spawn_id: str
+    position: Vector3
+    team: Literal["player", "bot"]
+
+
+@dataclass(frozen=True)
+class LightingSetup:
+    """Engine-agnostic lighting profile for the facility."""
+
+    ambient_color: tuple[float, float, float]
+    ambient_intensity: float
+    directional_color: tuple[float, float, float]
+    directional_intensity: float
+    directional_direction: Vector3
+
+
+@dataclass(frozen=True)
+class FacilityLayout:
+    """Complete facility definition used by environment and AI systems."""
+
+    rooms: dict[str, Room]
+    doorways: list[Doorway]
+    cover_objects: list[CoverObject]
+    waypoints: dict[str, Vector3]
+    waypoint_links: dict[str, list[str]]
+    spawn_points: list[SpawnPoint]
+    lighting: LightingSetup
+    wall_height: float = 3.0
+
+    def room_ids(self) -> set[str]:
+        return set(self.rooms.keys())
+
+    def bot_spawn_positions(self) -> list[Vector3]:
+        return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
+
+    def player_spawn_position(self) -> Vector3:
+        for spawn in self.spawn_points:
+            if spawn.team == "player":
+                return spawn.position
+        raise ValueError("Facility layout must define one player spawn point.")
+
+
+def create_default_facility_layout() -> FacilityLayout:
+    """Return a 5-room tactical facility with doorways, cover, and nav data."""
+    rooms = {
+        "lobby": Room("lobby", min_x=-12.0, max_x=-4.0, min_z=-8.0, max_z=8.0),
+        "central_hall": Room("central_hall", min_x=-4.0, max_x=4.0, min_z=-10.0, max_z=10.0),
+        "storage": Room("storage", min_x=4.0, max_x=12.0, min_z=-10.0, max_z=-2.0),
+        "lab": Room("lab", min_x=4.0, max_x=12.0, min_z=2.0, max_z=10.0),
+        "security": Room("security", min_x=-12.0, max_x=-4.0, min_z=-14.0, max_z=-8.0),
+    }
+
+    doorways = [
+        Doorway(
+            doorway_id="lobby_to_central",
+            room_a="lobby",
+            room_b="central_hall",
+            wall_axis="x",
+            wall_value=-4.0,
+            center=0.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_storage",
+            room_a="central_hall",
+            room_b="storage",
+            wall_axis="x",
+            wall_value=4.0,
+            center=-6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="central_to_lab",
+            room_a="central_hall",
+            room_b="lab",
+            wall_axis="x",
+            wall_value=4.0,
+            center=6.0,
+            width=3.0,
+        ),
+        Doorway(
+            doorway_id="lobby_to_security",
+            room_a="lobby",
+            room_b="security",
+            wall_axis="z",
+            wall_value=-8.0,
+            center=-8.0,
+            width=3.0,
+        ),
+    ]
+
+    cover_objects = [
+        CoverObject(
+            cover_id="lobby_crates",
+            kind="crate",
+            min_corner=(-10.5, 0.0, -1.8),
+            max_corner=(-8.8, 1.5, -0.1),
+        ),
+        CoverObject(
+            cover_id="hall_pillar",
+            kind="pillar",
+            min_corner=(-0.9, 0.0, -0.9),
+            max_corner=(0.9, 2.8, 0.9),
+        ),
+        CoverObject(
+            cover_id="storage_barrier",
+            kind="barrier",
+            min_corner=(6.0, 0.0, -6.9),
+            max_corner=(9.8, 1.3, -5.8),
+        ),
+        CoverObject(
+            cover_id="lab_crates",
+            kind="crate",
+            min_corner=(7.2, 0.0, 5.0),
+            max_corner=(9.0, 1.6, 6.8),
+        ),
+        CoverObject(
+            cover_id="security_barrier",
+            kind="barrier",
+            min_corner=(-9.6, 0.0, -11.2),
+            max_corner=(-6.4, 1.4, -10.1),
+        ),
+    ]
+
+    waypoints = {
+        "wp_lobby": (-8.0, 0.0, 0.0),
+        "wp_lobby_door": (-4.2, 0.0, 0.0),
+        "wp_central": (0.0, 0.0, 0.0),
+        "wp_storage_door": (4.2, 0.0, -6.0),
+        "wp_storage": (8.0, 0.0, -6.0),
+        "wp_lab_door": (4.2, 0.0, 6.0),
+        "wp_lab": (8.0, 0.0, 6.0),
+        "wp_security_door": (-8.0, 0.0, -8.2),
+        "wp_security": (-8.0, 0.0, -11.0),
+    }
+    waypoint_links = {
+        "wp_lobby": ["wp_lobby_door", "wp_security_door"],
+        "wp_lobby_door": ["wp_lobby", "wp_central"],
+        "wp_central": ["wp_lobby_door", "wp_storage_door", "wp_lab_door"],
+        "wp_storage_door": ["wp_central", "wp_storage"],
+        "wp_storage": ["wp_storage_door"],
+        "wp_lab_door": ["wp_central", "wp_lab"],
+        "wp_lab": ["wp_lab_door"],
+        "wp_security_door": ["wp_lobby", "wp_security"],
+        "wp_security": ["wp_security_door"],
+    }
+
+    spawn_points = [
+        SpawnPoint("spawn_player", position=(-9.0, 0.0, 3.0), team="player"),
+        SpawnPoint("spawn_bot_lobby", position=(-9.5, 0.0, -3.0), team="bot"),
+        SpawnPoint("spawn_bot_storage", position=(9.0, 0.0, -7.8), team="bot"),
+        SpawnPoint("spawn_bot_lab", position=(8.7, 0.0, 7.8), team="bot"),
+        SpawnPoint("spawn_bot_security", position=(-8.0, 0.0, -12.0), team="bot"),
+        SpawnPoint("spawn_bot_central", position=(0.0, 0.0, 8.0), team="bot"),
+    ]
+
+    lighting = LightingSetup(
+        ambient_color=(0.68, 0.72, 0.78),
+        ambient_intensity=0.42,
+        directional_color=(1.0, 0.96, 0.9),
+        directional_intensity=0.82,
+        directional_direction=(-0.6, -1.0, -0.3),
+    )
+
+    return FacilityLayout(
+        rooms=rooms,
+        doorways=doorways,
+        cover_objects=cover_objects,
+        waypoints=waypoints,
+        waypoint_links=waypoint_links,
+        spawn_points=spawn_points,
+        lighting=lighting,
+    )
diff --git a/src/environment/navigation.py b/src/environment/navigation.py
new file mode 100644
index 0000000000000000000000000000000000000000..4092fa853bf131d205700775510f3cddb4f4e1ce
--- /dev/null
+++ b/src/environment/navigation.py
@@ -0,0 +1,20 @@
+"""Environment navigation helpers."""
+
+from __future__ import annotations
+
+from src.ai.navigation import WaypointPathfinder
+from src.environment.facility import FacilityLayout
+
+
+def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
+    """Create a validated waypoint pathfinder from facility data."""
+    for node_id, neighbors in layout.waypoint_links.items():
+        if node_id not in layout.waypoints:
+            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
+        for neighbor in neighbors:
+            if neighbor not in layout.waypoints:
+                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
+    return WaypointPathfinder(
+        waypoints=dict(layout.waypoints),
+        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
+    )
diff --git a/tasks.md b/tasks.md
index 1aeae7b6a658dad9a82bf833415163e319055239..d794e1c5a8e944f779d28fdc9deedfa5b0370d84
--- a/tasks.md
+++ b/tasks.md
@@ -59,13 +59,13 @@
 
 - [x] Create Bot class with health, position, and AI state
 - [x] Implement basic bot pathfinding using navigation mesh or waypoints
-- [ ] Create tactical AI decision-making system (attack, take cover, flank)
-- [ ] Implement cover detection and usage logic
-- [ ] Create flanking behavior to approach player from multiple angles
+- [x] Create tactical AI decision-making system (attack, take cover, flank)
+- [x] Implement cover detection and usage logic
+- [x] Create flanking behavior to approach player from multiple angles
 - [x] Implement bot shooting mechanics with accuracy variance
 - [x] Add bot death handling with money drop spawning
-- [ ] Create wave spawning system for multiple bots
-- [ ] Implement bot difficulty scaling across waves
+- [x] Create wave spawning system for multiple bots
+- [x] Implement bot difficulty scaling across waves
 - [x] Create src/ai folder developer-guide.md
 
 ## Money & Economy
@@ -79,15 +79,15 @@
 
 ## Environment & Level Design
 
-- [ ] Create multi-room indoor facility layout using geometric primitives
-- [ ] Implement wall collision detection for player and projectiles
-- [ ] Add cover objects (crates, walls) throughout the facility
-- [ ] Create navigation data for AI pathfinding
+- [x] Create multi-room indoor facility layout using geometric primitives
+- [x] Implement wall collision detection for player and projectiles
+- [x] Add cover objects (crates, walls) throughout the facility
+- [x] Create navigation data for AI pathfinding
 - [ ] Implement room connectivity and doorways
 - [ ] Add environmental lighting setup
 - [ ] Create spawn points for player and bots
 - [ ] Design at least 3-5 distinct rooms with tactical variety
-- [ ] Create src/environment folder developer-guide.md
+- [x] Create src/environment folder developer-guide.md
 
 ## HUD System
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 93d224b73c2fb83729e82caba23c274c6f89db2b..39bb37eac4077f0078b7f7f77330bd80f27ace40
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -19,6 +19,7 @@
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 
 ## Running Tests
 To run all tests, execute the following command from the project root:
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
new file mode 100644
index 0000000000000000000000000000000000000000..358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2
--- /dev/null
+++ b/tests/test_environment_and_tactics.py
@@ -0,0 +1,101 @@
+from random import Random
+
+from src.ai.bot import Bot
+from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
+from src.ai.waves import WaveDirector
+from src.core.collision import AABB
+from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout
+
+
+def test_default_facility_has_five_rooms_and_doorway_connectivity():
+    layout = create_default_facility_layout()
+    assert len(layout.rooms) == 5
+    room_ids = layout.room_ids()
+    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
+    for doorway in layout.doorways:
+        assert doorway.room_a in room_ids
+        assert doorway.room_b in room_ids
+
+
+def test_collision_world_from_layout_respects_doorway_openings_and_cover():
+    layout = create_default_facility_layout()
+    world = build_collision_world(layout)
+    collider_half_size = (0.35, 0.9, 0.35)
+
+    def player_box(position: tuple[float, float, float]) -> AABB:
+        return AABB(
+            min_corner=(
+                position[0] - collider_half_size[0],
+                position[1] - collider_half_size[1],
+                position[2] - collider_half_size[2],
+            ),
+            max_corner=(
+                position[0] + collider_half_size[0],
+                position[1] + collider_half_size[1],
+                position[2] + collider_half_size[2],
+            ),
+        )
+
+    doorway_box = player_box(position=(-4.0, 0.9, 0.0))
+    blocked_wall_box = player_box(position=(-4.0, 0.9, 6.0))
+    cover_box = player_box(position=(0.0, 0.9, 0.0))
+
+    assert world.collides_with_wall(doorway_box) is False
+    assert world.collides_with_wall(blocked_wall_box) is True
+    assert world.collides_with_wall(cover_box) is True
+
+
+def test_layout_navigation_data_builds_pathfinder_with_connected_path():
+    layout = create_default_facility_layout()
+    pathfinder = build_waypoint_pathfinder(layout)
+    path = pathfinder.find_path(start_position=(-8.0, 0.0, 0.0), goal_position=(8.0, 0.0, 6.0))
+    assert len(path) >= 3
+    assert path[0] == layout.waypoints["wp_lobby"]
+    assert path[-1] == layout.waypoints["wp_lab"]
+
+
+def test_cover_selection_and_tactical_action_choice():
+    layout = create_default_facility_layout()
+    ai_bot = Bot.create_default(bot_id="tactical-bot", position=(-7.5, 0.0, -1.0))
+    ai_bot.health = 25
+    player_position = (-2.0, 0.0, -1.0)
+    plan = find_cover_plan(
+        bot_position=ai_bot.position,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+    )
+    assert plan is not None
+    action = choose_tactical_action(
+        bot=ai_bot,
+        player_position=player_position,
+        cover_objects=layout.cover_objects,
+        ally_count=0,
+    )
+    assert action == TacticalAction.TAKE_COVER
+
+
+def test_flank_route_and_wave_scaling_behavior():
+    flank_route = build_flank_route(
+        bot_position=(-10.0, 0.0, 0.0),
+        player_position=(0.0, 0.0, 0.0),
+        flank_radius=4.0,
+    )
+    assert len(flank_route) == 2
+    assert flank_route[-1] == (0.0, 0.0, 0.0)
+    assert flank_route[0][2] != 0.0
+
+    layout = create_default_facility_layout()
+    director = WaveDirector()
+    wave1 = director.spawn_wave(
+        wave_number=1,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    wave4 = director.spawn_wave(
+        wave_number=4,
+        spawn_positions=layout.bot_spawn_positions(),
+        rng=Random(42),
+    )
+    assert len(wave4) > len(wave1)
+    assert wave4[0].max_health > wave1[0].max_health
+    assert wave4[0].weapon.fire_rate > wave1[0].weapon.fire_rate

tokens used
94,732
Implemented a batch of 10 previously incomplete tasks and updated tracking/docs as requested.

Completed and marked in `tasks.md`:
1. Tactical AI decision-making (`attack`, `take_cover`, `flank`)
2. Cover detection and usage logic
3. Flanking behavior
4. Wave spawning system for multiple bots
5. Bot difficulty scaling across waves
6. Multi-room indoor facility layout
7. Wall collision detection for player/projectiles (via generated collision world)
8. Cover objects throughout facility
9. Navigation data for AI pathfinding
10. `src/environment` developer guide creation

Code added/updated:
- `src/environment/facility.py`
- `src/environment/collision.py`
- `src/environment/navigation.py`
- `src/environment/__init__.py`
- `src/environment/developer-guide.md`
- `src/ai/tactics.py`
- `src/ai/waves.py`
- `src/ai/__init__.py`
- `tests/test_environment_and_tactics.py`
- `src/ai/developer-guide.md`
- `src/developer-guide.md`
- `developer-guide.md`
- `tests/developer-guide.md`
- `tasks.md`
- `recent-changes.md`

Validation:
- Ran `pytest -q`
- Result: `40 passed`

Also noticed unrelated workspace changes not authored by me in `.agentharness/*` and `.codex_last_message.txt`. I left them untouched.
Implemented a batch of 10 previously incomplete tasks and updated tracking/docs as requested.

Completed and marked in `tasks.md`:
1. Tactical AI decision-making (`attack`, `take_cover`, `flank`)
2. Cover detection and usage logic
3. Flanking behavior
4. Wave spawning system for multiple bots
5. Bot difficulty scaling across waves
6. Multi-room indoor facility layout
7. Wall collision detection for player/projectiles (via generated collision world)
8. Cover objects throughout facility
9. Navigation data for AI pathfinding
10. `src/environment` developer guide creation

Code added/updated:
- `src/environment/facility.py`
- `src/environment/collision.py`
- `src/environment/navigation.py`
- `src/environment/__init__.py`
- `src/environment/developer-guide.md`
- `src/ai/tactics.py`
- `src/ai/waves.py`
- `src/ai/__init__.py`
- `tests/test_environment_and_tactics.py`
- `src/ai/developer-guide.md`
- `src/developer-guide.md`
- `developer-guide.md`
- `tests/developer-guide.md`
- `tasks.md`
- `recent-changes.md`

Validation:
- Ran `pytest -q`
- Result: `40 passed`

Also noticed unrelated workspace changes not authored by me in `.agentharness/*` and `.codex_last_message.txt`. I left them untouched.
Process exited with code 0. Output length: 1261218 chars.
End: 2026-02-08T18:46:36
__AGENTHARNESS_LIVE_DONE__
