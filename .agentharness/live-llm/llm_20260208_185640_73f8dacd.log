AgentHarness LLM Live Output
Start: 2026-02-08T18:56:40
CWD: C:/Users/shlob/Pycharm Projects/harness-test/harness-test-4
Command: codex exec --skip-git-repo-check --full-auto --output-last-message "C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\.codex_last_message.txt" --model gpt-5.3-codex -

Provider: Codex, Model: gpt-5.3-codex | Timeout: 600s
Prompt transport: stdin (678 chars)
LLM prompt begin (stdin)

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md
LLM prompt end (stdin)
Process PID: 13756
OpenAI Codex v0.98.0 (research preview)
--------
workdir: C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019c3e2f-19fe-7aa1-b9d6-065ef301e867
--------
user

INSTRUCTIONS:
1. Read the recent-changes.md
2. Choose up to 10 incomplete tasks from tasks.md list (marked with `- [ ]`)
3. Implement each chosen task completely and thoroughly
4. After implementing, update the recent-changes.md file with what you changed
5. Mark each completed task in tasks.md by changing `- [ ]` to `- [x]`
6. If you discover additional tasks that need to be done, add them to tasks.md but do not execute them

CRITICAL RULES:
- Work on up to 10 tasks and complete them
- Only mark a task as complete once you have fully completed it
- Be thorough - each task should be fully complete before marking done
- Always update both tasks.md and recent-changes.md

deprecated: `enable_experimental_windows_sandbox` is deprecated. Use `[features].experimental_windows_sandbox` instead.
  Enable it with `--enable experimental_windows_sandbox` or `[features].experimental_windows_sandbox` in config.toml. See https://github.com/openai/codex/blob/main/docs/config.md#feature-flags for details.
mcp startup: no servers

thinking
**Preparing initial file inspection**
codex
I’m going to read `product-description.md`, `recent-changes.md`, and `tasks.md` first, then I’ll pick up to 10 unchecked tasks and start implementing them one by one with validations.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'if (Test-Path product-description.md) { Get-Content product-description.md }' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'if (Test-Path recent-changes.md) { Get-Content recent-changes.md }' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'if (Test-Path tasks.md) { Get-Content tasks.md }' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Name' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 251ms:
# Recent Changes

 succeeded in 251ms:
# Product Description: FPS Bot Arena with "The Glitch"

## Overview
A First-Person Shooter (FPS) game where the player fights against waves of tactical AI bots in a multi-room indoor facility. The core loop involves combat, earning money from kills, and upgrading weapons. The game features a meta-twist ending where the final weapon, an RPG, triggers a simulated game crash (Fake BSOD/Error) upon use.

## Gameplay Mechanics
*   **Perspective:** First-Person.
*   **Controls:** Standard FPS controls (WASD + Mouse).
*   **Interaction:** Pressing 'B' opens a real-time inventory/shop wheel to buy and switch weapons.
*   **Win/Loss:**
    *   **Loss:** Player health reaches zero.
    *   **"Win":** Acquiring and firing the final RPG, triggering the "crash" ending.

## Economy & Progression
*   **Income:** Bots drop money as physical items upon death, which the player must collect.
*   **Weapon Progression:**
    1.  **Pistol:** Starting weapon.
    2.  **Shotgun:** High close-range damage.
    3.  **Assault Rifle:** Rapid fire, medium range.
    4.  **RPG (Final Weapon):** Expensive endgame item. Firing it causes a fake "Blue Screen of Death" or critical error message, effectively ending the session.
 succeeded in 256ms:
# FPS Bot Arena Implementation Tasks

## Project Setup & Architecture

- [x] Choose and document the technology stack (Python + Ursina or Web + Three.js)
- [x] Set up project structure with main folders (src, assets, config, tests)
- [x] Create root developer-guide.md documenting overall project architecture
- [x] Initialize package.json or requirements.txt with core dependencies
- [x] Set up basic project configuration files (config.py or config.js)

## Core Game Engine

- [x] Implement main game loop with frame updates and delta time handling
- [x] Create game state manager to handle different states (menu, playing, paused, crashed)
- [x] Implement camera system with first-person perspective and mouse look controls
- [x] Create input handler for WASD movement and mouse controls
- [x] Implement player movement with collision detection
- [x] Create physics system for projectile movement and collision
- [x] Implement raycasting system for shooting mechanics
- [x] Create game clock and time management system
 succeeded in 206ms:
.agentharness
.pytest_cache
assets
config
review
src
tests
.gitignore
AGENTS.md
CLAUDE.md
developer-guide.md
GAMEPLAY.md
GEMINI.md
product-description.md
questions.json
README.md
recent-changes.md
requirements.txt
tasks.md

thinking
**Scoping feasible small tasks**
codex
I’ve loaded the task list; next I’m scanning the codebase to pick tasks that can be completed end-to-end in this pass, then I’ll implement and validate each before marking done.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'rg --files' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File src | Select-Object -ExpandProperty FullName' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 270ms:
tests\test_shop_ui.py
tests\test_player_and_weapons.py
tests\test_hud.py
tests\test_environment_and_tactics.py
tests\test_core_systems.py
tests\test_config.py
tests\test_ai_and_economy.py
tests\test_advanced_combat_and_movement.py
tests\developer-guide.md
tests\conftest.py
tasks.md
GEMINI.md
README.md
GAMEPLAY.md
developer-guide.md
questions.json
product-description.md
requirements.txt
recent-changes.md
AGENTS.md
 succeeded in 270ms:
# Developer Guide

## Project Architecture
This project uses **Python + Ursina** for a lightweight FPS prototype.

The current codebase implements engine-agnostic gameplay foundations in pure Python:
- Core runtime loop and timing
- State machine for high-level game flow
- Clock pause/resume and time scaling controls
- Input normalization for WASD + mouse look
- First-person camera and movement/collision simulation
- Raycasting-based hit-scan traces
- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
- Projectile entities and physics for bullets, pellets, and rockets
- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
- HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 succeeded in 276ms:
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\.gitkeep
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\bot.py
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\combat.py
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\navigation.py
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\tactics.py
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\waves.py
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__init__.py
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__pycache__\bot.cpython-311.pyc
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__pycache__\combat.cpython-311.pyc
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__pycache__\navigation.cpython-311.pyc
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__pycache__\tactics.cpython-311.pyc
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__pycache__\waves.cpython-311.pyc
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\__pycache__\__init__.cpython-311.pyc
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\camera.py
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\collision.py
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\developer-guide.md
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\game_clock.py
C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\game_loop.py

thinking
**Reviewing task completion and coverage**
codex
I found several unchecked tasks that map to existing partial systems. I’m now inspecting `src/environment`, `src/hud`, and `src/core` to confirm what is already present, then I’ll implement missing parts (especially HUD runtime event wiring) and backfill tests/documentation.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\environment\\developer-guide.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\hud\\developer-guide.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\core\\developer-guide.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\environment\\facility.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\hud\\overlay.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\core\\game_loop.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 233ms:
# Environment Developer Guide

## Purpose
`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.

## Files
- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
- `__init__.py`: package exports for facility, collision, and navigation helpers.

## Layout Contents
- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
- Doorway connectivity between rooms via explicit `Doorway` records.
- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
- Waypoint graph and links for AI route planning.
- Spawn point records for player and bots.
- Engine-agnostic ambient + directional lighting profile.

## Integration Notes
 succeeded in 238ms:
# HUD Developer Guide

## Purpose
`src/hud/` contains engine-agnostic HUD state generation and short-lived feedback systems.

## Files
- `overlay.py`: HUD domain models and `HudOverlayController` for health/ammo/money/crosshair rendering payloads, damage flash timing, and kill notifications/counter.
- `__init__.py`: package exports for HUD state/controller types.

## Core Behaviors
- `HudOverlayController.build_state(player)` returns one render-ready payload with:
  - health bar data (`current_health`, `max_health`, `fill_ratio`, severity color)
  - ammo data (`weapon_name`, `in_magazine`, `magazine_size`, `reserve_ammo`, formatted text)
  - money display text
  - center-screen crosshair style and placement
  - damage indicator visibility/intensity/alpha countdown values
  - kill counter and active kill notifications
- `register_damage(amount)` triggers or refreshes the damage indicator flash.
- `register_kill(enemy_label)` increments kill count and adds a short-lived kill notification.
- `step(delta_time)` advances timers and expires transient damage/notification effects.
 succeeded in 250ms:
# Core Developer Guide

## Purpose
`src/core/` provides engine-level systems that are independent from rendering backends.

## Files
- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.

## Behavior Notes
- `GameStateManager` blocks invalid transitions with `ValueError`.
- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 succeeded in 251ms:
"""Indoor facility layout primitives used by environment and AI systems."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Literal


Vector3 = tuple[float, float, float]


@dataclass(frozen=True)
class Room:
    """Axis-aligned rectangular room footprint."""

    room_id: str
    min_x: float
    max_x: float
    min_z: float
    max_z: float
 succeeded in 247ms:
"""Engine-agnostic HUD overlay state and update logic."""

from __future__ import annotations

from dataclasses import dataclass, field
from math import floor

from src.player.player import Player


@dataclass(frozen=True)
class HealthBarState:
    """Normalized health bar values for renderers."""

    current_health: int
    max_health: int
    fill_ratio: float
    color: str


 succeeded in 230ms:
"""Main game loop orchestration with delta-time updates."""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import Callable

from src.core.game_clock import GameClock
from src.core.game_state import GameState, GameStateManager

logger = logging.getLogger(__name__)


FrameCallback = Callable[[float], None]


@dataclass
class GameLoop:
    """Owns frame stepping and update dispatch for active gameplay."""

thinking
**Searching runtime integration points**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "rg \"GameLoop\\(|register_update_callback|step\\(\" -n src tests" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "rg \"HudOverlayController|register_damage|register_kill|build_state\\(\" -n src tests" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 210ms:
src\developer-guide.md:33:16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
src\hud\developer-guide.md:7:- `overlay.py`: HUD domain models and `HudOverlayController` for health/ammo/money/crosshair rendering payloads, damage flash timing, and kill notifications/counter.
src\hud\developer-guide.md:11:- `HudOverlayController.build_state(player)` returns one render-ready payload with:
src\hud\developer-guide.md:18:- `register_damage(amount)` triggers or refreshes the damage indicator flash.
src\hud\developer-guide.md:19:- `register_kill(enemy_label)` increments kill count and adds a short-lived kill notification.
src\hud\developer-guide.md:24:- Call `step(...)` once per frame and `build_state(...)` when preparing HUD draw data.
src\hud\developer-guide.md:25:- Hook `register_damage(...)` to player damage events and `register_kill(...)` to bot death events.
src\hud\__init__.py:8:    HudOverlayController,
src\hud\__init__.py:15:    "HudOverlayController",
src\hud\overlay.py:87:class HudOverlayController:
src\hud\overlay.py:119:    def register_damage(self, amount: int) -> None:
src\hud\overlay.py:130:    def register_kill(self, enemy_label: str = "Bot") -> None:
src\hud\overlay.py:144:    def build_state(self, player: Player) -> HudOverlayState:
tests\test_hud.py:3:from src.hud import HudOverlayController
tests\test_hud.py:9:    hud = HudOverlayController()
tests\test_hud.py:11:    state = hud.build_state(player)
tests\test_hud.py:34:    hud = HudOverlayController()
tests\test_hud.py:37:    mid_state = hud.build_state(player)
tests\test_hud.py:42:    low_state = hud.build_state(player)
tests\test_hud.py:49:    hud = HudOverlayController(damage_flash_seconds=0.5)
 succeeded in 210ms:
src\economy\money.py:57:    def step(self, delta_time: float) -> None:
src\economy\money.py:118:    def step(self, delta_time: float) -> None:
src\economy\money.py:120:            pickup.step(delta_time)
tests\test_hud.py:47:def test_hud_damage_indicator_shows_then_fades_with_step():
tests\test_hud.py:57:    hud.step(0.25)
tests\test_hud.py:62:    hud.step(0.25)
tests\test_hud.py:83:    hud.step(1.5)
src\hud\overlay.py:98:    def step(self, delta_time: float) -> None:
src\economy\developer-guide.md:14:- `MoneyPickup.step(...)` supports TTL expiration; expired pickups are removed during `MoneyPickupSystem.step(...)`.
tests\test_core_systems.py:102:    loop = GameLoop(state_manager=manager)
tests\test_core_systems.py:104:    loop.register_update_callback(deltas.append)
tests\test_core_systems.py:106:    loop.step(1.0)
tests\test_core_systems.py:107:    loop.step(1.1)
tests\test_core_systems.py:111:    loop.step(1.4)
tests\test_core_systems.py:112:    loop.step(1.8)
src\hud\developer-guide.md:20:- `step(delta_time)` advances timers and expires transient damage/notification effects.
src\hud\developer-guide.md:24:- Call `step(...)` once per frame and `build_state(...)` when preparing HUD draw data.
src\projectiles\developer-guide.md:13:3. `ProjectilePhysicsSystem.step(...)` advances active projectiles each frame.
tests\test_advanced_combat_and_movement.py:140:    collisions = physics.step(projectiles, delta_time=0.05, world=world)
src\core\developer-guide.md:18:- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.

thinking
**Planning runtime integration file**
codex
I confirmed HUD is currently isolated: it has no runtime hook for player damage/kill events. I’m now reviewing existing tests and module boundaries so I can add a minimal runtime integration layer plus tests without breaking current architecture.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\src??" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content tests\\test_environment_and_tactics.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content tests\\test_core_systems.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\ai\\bot.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 229ms:
from random import Random

from src.ai.bot import Bot
from src.ai.tactics import TacticalAction, build_flank_route, choose_tactical_action, find_cover_plan
from src.ai.waves import WaveDirector
from src.core.collision import AABB
from src.environment import build_collision_world, build_waypoint_pathfinder, create_default_facility_layout


def test_default_facility_has_five_rooms_and_doorway_connectivity():
    layout = create_default_facility_layout()
    assert len(layout.rooms) == 5
    room_ids = layout.room_ids()
    assert {"lobby", "central_hall", "storage", "lab", "security"} <= room_ids
    for doorway in layout.doorways:
        assert doorway.room_a in room_ids
        assert doorway.room_b in room_ids


def test_collision_world_from_layout_respects_doorway_openings_and_cover():
 succeeded in 284ms:
"""Bot runtime model with combat hooks and money-drop behavior."""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from math import sqrt
from random import Random

from src.ai.combat import vary_direction_with_accuracy
from src.economy.money import MoneyPickup, MoneyPickupSystem
from src.weapons.assault_rifle import AssaultRifle
from src.weapons.weapon import Weapon


Vector3 = tuple[float, float, float]


class BotAIState(str, Enum):
    """High-level tactical state labels for bots."""
 succeeded in 284ms:
import pytest

from src.core.game_clock import GameClock
from src.core.game_loop import GameLoop
from src.core.raycasting import RaycastingSystem, RaycastTarget
from src.core.game_state import GameState, GameStateManager
from src.core.input_handler import InputHandler, InputSnapshot


def test_game_clock_tracks_delta_and_elapsed_time():
    clock = GameClock()

    assert clock.tick(10.0) == 0.0
    assert clock.elapsed_time == 0.0
    assert clock.frame_count == 0

    assert clock.tick(10.25) == 0.25
    assert clock.tick(10.75) == 0.5
    assert clock.elapsed_time == 0.75
    assert clock.frame_count == 2
 exited 1 in 290ms:
Get-Content : An object at the specified path src\src?? does not exist, or has been filtered by the -Include or -Exclude parameter.
At line:2 char:1
+ Get-Content src\src??
+ ~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (System.String[]:String[]) [Get-Content], Exception
    + FullyQualifiedErrorId : ItemNotFound,Microsoft.PowerShell.Commands.GetContentCommand
 

thinking
**Planning player damage handling**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\player\\player.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 209ms:
"""Player model with health, currency, inventory, and shooting."""

from __future__ import annotations

from dataclasses import dataclass, field

from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
from src.projectiles.projectile import Projectile
from src.weapons.pistol import Pistol
from src.weapons.switching import WeaponSwitchState
from src.weapons.weapon import Weapon


@dataclass
class Player:
    """Encapsulates runtime player state and core gameplay actions."""

    max_health: int
    health: int
    money: int

thinking
**Inspecting core initialization exports**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content tests\\developer-guide.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\environment\\__init__.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\hud\\__init__.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\core\\__init__.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 218ms:
"""Environment layout and collision exports."""

from src.environment.collision import build_collision_world
from src.environment.facility import (
    CoverObject,
    Doorway,
    FacilityLayout,
    LightingSetup,
    Room,
    SpawnPoint,
    create_default_facility_layout,
)
from src.environment.navigation import build_waypoint_pathfinder

__all__ = [
    "Room",
    "Doorway",
    "CoverObject",
    "SpawnPoint",
    "LightingSetup",
 succeeded in 218ms:
# Tests Developer Guide

## Overview
This directory contains the automated test suite for the FPS Bot Arena project.

## Testing Framework
- **Framework:** `pytest`
- **Rationale:** Standard, powerful, and easy-to-use testing framework for Python.

## Structure
- Test files should be named `test_<module_name>.py`.
- Tests should mirror the structure of the `src/` and `config/` directories where applicable.
- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.

## Current Test Modules
- `test_config.py`: validates immutable config defaults.
- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 succeeded in 221ms:
"""HUD overlay exports."""

from src.hud.overlay import (
    AmmoCounterState,
    CrosshairState,
    DamageIndicatorState,
    HealthBarState,
    HudOverlayController,
    HudOverlayState,
    KillNotification,
    MoneyDisplayState,
)

__all__ = [
    "HudOverlayController",
    "HudOverlayState",
    "HealthBarState",
    "AmmoCounterState",
    "MoneyDisplayState",
    "CrosshairState",
 succeeded in 221ms:
"""Core runtime systems for FPS Bot Arena."""

from src.core.camera import FirstPersonCamera
from src.core.collision import AABB, CollisionWorld
from src.core.game_clock import GameClock
from src.core.game_loop import GameLoop
from src.core.game_state import GameState, GameStateManager
from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
from src.core.movement import PlayerMovementController
from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget

__all__ = [
    "AABB",
    "CollisionWorld",
    "FirstPersonCamera",
    "GameClock",
    "GameLoop",
    "GameState",
    "GameStateManager",
    "InputFrame",

thinking
**Checking developer guide for updates**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\developer-guide.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 206ms:
# Src Developer Guide

## Purpose
`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.

## Folder Overview
- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
- `projectiles/`: projectile entities plus physics stepping and world collision checks.
- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
- `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.

## Integration Flow
1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.

thinking
**Planning task selection and integration**
codex
I’m implementing three concrete pieces next: a HUD event bridge wired into `GameLoop`, stronger environment connectivity/spawn/lighting helpers with tests, and targeted algorithm comments. Then I’ll update all required developer guides plus `tasks.md` and `recent-changes.md`.
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\environment\\collision.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\ai\\tactics.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\environment\\navigation.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content tests\\test_hud.py" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 217ms:
"""Environment navigation helpers."""

from __future__ import annotations

from src.ai.navigation import WaypointPathfinder
from src.environment.facility import FacilityLayout


def build_waypoint_pathfinder(layout: FacilityLayout) -> WaypointPathfinder:
    """Create a validated waypoint pathfinder from facility data."""
    for node_id, neighbors in layout.waypoint_links.items():
        if node_id not in layout.waypoints:
            raise ValueError(f"Waypoint link source '{node_id}' is undefined.")
        for neighbor in neighbors:
            if neighbor not in layout.waypoints:
                raise ValueError(f"Waypoint link target '{neighbor}' is undefined.")
    return WaypointPathfinder(
        waypoints=dict(layout.waypoints),
        links={node_id: list(neighbors) for node_id, neighbors in layout.waypoint_links.items()},
    )
 succeeded in 221ms:
"""Build collision volumes from a facility layout."""

from __future__ import annotations

from src.core.collision import AABB, CollisionWorld
from src.environment.facility import FacilityLayout, Room


EPSILON = 1e-5


def _interval_subtract(start: float, end: float, cuts: list[tuple[float, float]]) -> list[tuple[float, float]]:
    """Subtract opening ranges from a wall segment range."""
    segments = [(start, end)]
    for cut_min, cut_max in cuts:
        if cut_max <= cut_min:
            continue
        next_segments: list[tuple[float, float]] = []
        for seg_min, seg_max in segments:
            if cut_max <= seg_min or cut_min >= seg_max:
 succeeded in 221ms:
"""Tactical decision-making, cover usage, and flanking helpers."""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from math import sqrt

from src.ai.bot import Bot
from src.environment.facility import CoverObject


Vector3 = tuple[float, float, float]


class TacticalAction(str, Enum):
    """Primary tactical actions a bot can select."""

    ATTACK = "attack"
    TAKE_COVER = "take_cover"
 succeeded in 219ms:
import pytest

from src.hud import HudOverlayController
from src.player.player import Player


def test_hud_overlay_core_displays_health_ammo_money_and_crosshair():
    player = Player.with_starter_loadout(start_health=100, start_money=425)
    hud = HudOverlayController()

    state = hud.build_state(player)
    assert state.health.current_health == 100
    assert state.health.max_health == 100
    assert state.health.fill_ratio == pytest.approx(1.0)
    assert state.health.color == "green"

    assert state.ammo.weapon_name == "Pistol"
    assert state.ammo.in_magazine == 12
    assert state.ammo.magazine_size == 12
    assert state.ammo.reserve_ammo == 48

thinking
**Planning task implementation and test updates**
codex
I’m starting file edits now: adding `src/core/runtime.py`, exporting it from `src/core/__init__.py`, and extending tests in `tests/test_core_systems.py` for HUD damage/kill event wiring through the game loop.
file update
A C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/runtime.py
"""Runtime wiring helpers that bridge gameplay events to HUD updates."""

from __future__ import annotations

from dataclasses import dataclass, field

from src.core.game_loop import GameLoop
from src.hud.overlay import HudOverlayController, HudOverlayState
from src.player.player import Player


@dataclass
class HudEventRuntimeBridge:
    """Queues gameplay events and applies them to the HUD inside game-loop updates."""

    game_loop: GameLoop
    hud_controller: HudOverlayController
    _pending_damage_events: list[int] = field(default_factory=list)
    _pending_kill_events: list[str] = field(default_factory=list)

    def __post_init__(self) -> None:
        self.game_loop.register_update_callback(self.on_frame_update)

    def queue_damage_event(self, amount: int) -> None:
        """Queue a player damage event to be flushed during the next playing frame."""
        if amount <= 0:
            raise ValueError("amount must be positive.")
        self._pending_damage_events.append(amount)

    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
        """Queue a kill event to be flushed during the next playing frame."""
        self._pending_kill_events.append(enemy_label)

    def on_frame_update(self, delta_time: float) -> None:
        """Flush queued events and advance transient HUD timers."""
        for amount in self._pending_damage_events:
            self.hud_controller.register_damage(amount)
        self._pending_damage_events.clear()

        for enemy_label in self._pending_kill_events:
            self.hud_controller.register_kill(enemy_label)
        self._pending_kill_events.clear()

        self.hud_controller.step(delta_time)


@dataclass
class RuntimeSession:
    """Minimal runtime composition helper for player + HUD integration."""

    player: Player
    game_loop: GameLoop
    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
    hud_bridge: HudEventRuntimeBridge = field(init=False)

    def __post_init__(self) -> None:
        self.hud_bridge = HudEventRuntimeBridge(
            game_loop=self.game_loop,
            hud_controller=self.hud_controller,
        )

    def apply_player_damage(self, amount: int) -> None:
        """Apply player damage and enqueue HUD feedback."""
        health_before = self.player.health
        self.player.apply_damage(amount)
        damage_taken = health_before - self.player.health
        if damage_taken > 0:
            self.hud_bridge.queue_damage_event(damage_taken)

    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
        """Queue a bot kill event for HUD notification/counter updates."""
        self.hud_bridge.queue_kill_event(enemy_label)

    def build_hud_state(self) -> HudOverlayState:
        """Build a render-ready HUD state for the current player frame."""
        return self.hud_controller.build_state(self.player)
apply_patch(auto_approved=true) exited 0 in 53ms:
Success. Updated the following files:
A src/core/runtime.py
file update:
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)

file update:
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)

file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/__init__.py
@@ -10,2 +10,3 @@
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
@@ -26,2 +27,4 @@
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
apply_patch(auto_approved=true) exited 0 in 66ms:
Success. Updated the following files:
M src/core/__init__.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)

file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_core_systems.py
@@ -5,4 +5,6 @@
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
@@ -113 +115,22 @@
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
apply_patch(auto_approved=true) exited 0 in 79ms:
Success. Updated the following files:
M tests/test_core_systems.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]


thinking
**Planning facility enhancements**
codex
The HUD runtime bridge is in place with tests. I’m now enhancing the environment model with explicit connectivity/spawn helpers and validation so the unchecked environment tasks are fully covered, then I’ll add tests for lighting/spawn/room distinctness.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/environment/facility.py
@@ -5,2 +5,3 @@
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
@@ -107,2 +108,33 @@
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
@@ -116,3 +148,42 @@
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
@@ -239,3 +310,3 @@
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
@@ -248 +319,3 @@
     )
+    layout.validate()
+    return layout
apply_patch(auto_approved=true) exited 0 in 103ms:
Success. Updated the following files:
M src/environment/facility.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]


thinking
**Adding comments to algorithms**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/environment/collision.py
@@ -18,2 +18,3 @@
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
apply_patch(auto_approved=true) exited 0 in 125ms:
Success. Updated the following files:
M src/environment/collision.py
file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]

file update:
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]

file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/tactics.py
@@ -46,2 +46,3 @@
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
apply_patch(auto_approved=true) exited 0 in 157ms:
Success. Updated the following files:
M src/ai/tactics.py
file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]

file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]


thinking
**Adding tests for environment helpers**
codex
I’ve added environment validation/connectivity logic and algorithm comments. Next I’m extending `tests/test_environment_and_tactics.py` to verify doorway graph connectivity, spawn placement, and lighting validity so those tasks are provably complete.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/test_environment_and_tactics.py
@@ -17,2 +17,15 @@
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
apply_patch(auto_approved=true) exited 0 in 169ms:
Success. Updated the following files:
M tests/test_environment_and_tactics.py
file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():


thinking
**Running tests before docs update**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 601ms:
...............................................                          [100%]
47 passed in 0.12s
file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():


thinking
**Planning verification tasks**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File -Include *.py | ForEach-Object { $lines=(Get-Content $_.FullName).Length; if($lines -gt 1000){"$lines`t$($_.FullName)"} }' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -File -Include *.md | ForEach-Object { $lines=(Get-Content $_.FullName).Length; "{0}`t{1}" -f $lines,$_.FullName } | Sort-Object {[int]($_ -split "`t")[0]} -Descending' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-ChildItem -Recurse -Directory | ForEach-Object { $pyCount=(Get-ChildItem $_.FullName -File -Filter *.py | Measure-Object).Count; if($pyCount -gt 10){"$pyCount`t$($_.FullName)"} }' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 327ms:

 succeeded in 328ms:

 succeeded in 398ms:
180	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tasks.md
76	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md
38	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\README.md
34	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ui\developer-guide.md
33	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\developer-guide.md
32	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\GAMEPLAY.md
32	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\product-description.md
31	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\review\developer-guide.md
31	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\player\developer-guide.md
29	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests\developer-guide.md
28	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\weapons\developer-guide.md
26	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\core\developer-guide.md
25	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\hud\developer-guide.md
23	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\ai\developer-guide.md
23	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\environment\developer-guide.md
17	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\config\developer-guide.md
15	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\economy\developer-guide.md
14	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src\projectiles\developer-guide.md
9	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\AGENTS.md
9	C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\CLAUDE.md
file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():


thinking
**Planning developer guide updates**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\core\\developer-guide.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\ai\\developer-guide.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\environment\\developer-guide.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'Get-Content developer-guide.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content src\\developer-guide.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command "Get-Content tests\\developer-guide.md" in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 224ms:
# Core Developer Guide

## Purpose
`src/core/` provides engine-level systems that are independent from rendering backends.

## Files
- `game_state.py`: `GameState` enum and `GameStateManager` with validated state transitions.
- `game_clock.py`: `GameClock` for frame delta-time, pause/resume, time scaling, and elapsed time tracking.
- `input_handler.py`: `InputSnapshot` and `InputHandler` for WASD + mouse look normalization.
- `game_loop.py`: `GameLoop` that runs frame steps and calls update callbacks while in `playing`.
- `camera.py`: `FirstPersonCamera` yaw/pitch state with clamped vertical look limits.
- `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
- `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
- `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.

## Behavior Notes
- `GameStateManager` blocks invalid transitions with `ValueError`.
- `GameLoop.step(now)` always advances the clock, but only runs callbacks in `playing`.
- `GameClock` supports paused time and positive time-scale multipliers for slowed/accelerated simulation.
- Mouse look is sensitivity-scaled and pitch is inverted (`mouse up` => positive look pitch).
 succeeded in 219ms:
# Tests Developer Guide

## Overview
This directory contains the automated test suite for the FPS Bot Arena project.

## Testing Framework
- **Framework:** `pytest`
- **Rationale:** Standard, powerful, and easy-to-use testing framework for Python.

## Structure
- Test files should be named `test_<module_name>.py`.
- Tests should mirror the structure of the `src/` and `config/` directories where applicable.
- `conftest.py` inserts the repository root into `sys.path` so package-style imports (`src.*`, `config.*`) work in pytest.

## Current Test Modules
- `test_config.py`: validates immutable config defaults.
- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
- `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
- `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
- `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 succeeded in 219ms:
# Environment Developer Guide

## Purpose
`src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.

## Files
- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
- `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
- `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
- `__init__.py`: package exports for facility, collision, and navigation helpers.

## Layout Contents
- Five distinct rooms: `lobby`, `central_hall`, `storage`, `lab`, and `security`.
- Doorway connectivity between rooms via explicit `Doorway` records.
- Distributed cover objects (`crate`, `pillar`, `barrier`) represented as AABB prisms.
- Waypoint graph and links for AI route planning.
- Spawn point records for player and bots.
- Engine-agnostic ambient + directional lighting profile.

## Integration Notes
 succeeded in 219ms:
# Src Developer Guide

## Purpose
`src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.

## Folder Overview
- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
- `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
- `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
- `projectiles/`: projectile entities plus physics stepping and world collision checks.
- `ui/`: shop wheel catalog, radial layout generation, affordability/equipped status projection, and open/close interaction controller.
- `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
- `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
- `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.

## Integration Flow
1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
2. Mouse look deltas update `core.camera.FirstPersonCamera`; resulting yaw drives movement direction.
3. `core.movement.PlayerMovementController` computes collision-aware movement against `core.collision.CollisionWorld`.
 succeeded in 248ms:
# AI Developer Guide

## Purpose
`src/ai/` contains bot runtime behavior, bot aiming logic, tactical decision logic, waypoint pathfinding, and wave management.

## Files
- `bot.py`: `Bot` model with health/state, damage/death flow, inaccuracy-aware shooting, and money-drop spawning.
- `combat.py`: deterministic helper for applying directional aim variance from an accuracy cone.
- `navigation.py`: `WaypointPathfinder` for nearest-waypoint BFS path generation.
- `tactics.py`: cover evaluation, tactical action selection (`attack`, `take_cover`, `flank`), and flank route construction.
- `waves.py`: wave size scaling, per-wave difficulty profiles, and deterministic bot spawning.
- `__init__.py`: package exports for AI modules.

## Key Behaviors
- `Bot.create_default(...)` creates a standard bot with assault rifle loadout.
- `Bot.apply_damage(...)` clamps health and sets state to `dead` on kill.
- `Bot.shoot_at(...)` computes normalized target direction, applies accuracy variance, and respects weapon cooldown/ammo.
- `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
- `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
- `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
 succeeded in 220ms:
# Developer Guide

## Project Architecture
This project uses **Python + Ursina** for a lightweight FPS prototype.

The current codebase implements engine-agnostic gameplay foundations in pure Python:
- Core runtime loop and timing
- State machine for high-level game flow
- Clock pause/resume and time scaling controls
- Input normalization for WASD + mouse look
- First-person camera and movement/collision simulation
- Raycasting-based hit-scan traces
- Player model with health, money, inventory, immediate/smooth weapon switching, reload, projectile fire, hit-scan fire, and respawn/game-over
- Weapon system with pistol, shotgun, assault rifle, RPG, switch transitions, and primitive visual recipes
- Projectile entities and physics for bullets, pellets, and rockets
- Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
- HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
- Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
- Collision world generation from environment rooms/doorways/cover for movement and projectile systems
- Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():


thinking
**Planning comprehensive guide updates**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/core/developer-guide.md
@@ -14,2 +14,3 @@
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
@@ -26 +27,3 @@
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
apply_patch(auto_approved=true) exited 0 in 187ms:
Success. Updated the following files:
M src/core/developer-guide.md
file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/environment/developer-guide.md
@@ -6,3 +6,3 @@
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
@@ -18,2 +18,3 @@
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
@@ -23 +24,2 @@
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
apply_patch(auto_approved=true) exited 0 in 213ms:
Success. Updated the following files:
M src/environment/developer-guide.md
file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update:
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():


thinking
**Planning AI guide update**
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/ai/developer-guide.md
@@ -20,2 +20,3 @@
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
apply_patch(auto_approved=true) exited 0 in 241ms:
Success. Updated the following files:
M src/ai/developer-guide.md
file update:
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update:
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():


thinking
**Updating documentation and tests**
codex
I’m updating the developer guides now for every touched folder plus ancestors (`src/` and root) so the documentation stays compliant with your AGENTS rules.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\src/developer-guide.md
@@ -6,3 +6,3 @@
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
@@ -14,3 +14,3 @@
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
@@ -33 +33,2 @@
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
apply_patch(auto_approved=true) exited 0 in 251ms:
Success. Updated the following files:
M src/developer-guide.md
file update:
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update:
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\developer-guide.md
@@ -9,2 +9,3 @@
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
@@ -18,2 +19,3 @@
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
@@ -24,3 +26,4 @@
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
@@ -67,3 +70,3 @@
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
@@ -72,2 +75,3 @@
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
apply_patch(auto_approved=true) exited 0 in 283ms:
Success. Updated the following files:
M developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tests/developer-guide.md
@@ -16,3 +16,3 @@
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, loop update dispatch behavior, and runtime HUD event hook integration.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
@@ -21,3 +21,3 @@
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
-- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway connectivity traversal, spawn placement inside rooms, lighting validity, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 - `test_hud.py`: validates HUD snapshot generation (health/ammo/money/crosshair), damage indicator timing, and kill notification/counter behavior.
apply_patch(auto_approved=true) exited 0 in 304ms:
Success. Updated the following files:
M tests/developer-guide.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 2b952ac68e620711205485ba965cd60e20129f64..6242575007932dfe6d4798fafeb15b94799f5d6a
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,12 +14,12 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, loop update dispatch behavior, and runtime HUD event hook integration.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
-- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway connectivity traversal, spawn placement inside rooms, lighting validity, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 - `test_hud.py`: validates HUD snapshot generation (health/ammo/money/crosshair), damage indicator timing, and kill notification/counter behavior.
 
 ## Running Tests
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 2b952ac68e620711205485ba965cd60e20129f64..6242575007932dfe6d4798fafeb15b94799f5d6a
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,12 +14,12 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, loop update dispatch behavior, and runtime HUD event hook integration.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
-- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway connectivity traversal, spawn placement inside rooms, lighting validity, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 - `test_hud.py`: validates HUD snapshot generation (health/ammo/money/crosshair), damage indicator timing, and kill notification/counter behavior.
 
 ## Running Tests
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():


thinking
**Updating task checklists and docs**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'rg "Implement room connectivity and doorways|Add environmental lighting setup|Create spawn points for player and bots|Design at least 3-5 distinct rooms with tactical variety|Integrate HudOverlayController event hooks into the runtime update loop|Add code comments for complex algorithms|Review and compact any developer-guide.md files over 500 lines|Verify no code files exceed 1000 lines|Verify no folders have more than 10 code files" -n tasks.md' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 202ms:
86:- [ ] Implement room connectivity and doorways
87:- [ ] Add environmental lighting setup
88:- [ ] Create spawn points for player and bots
89:- [ ] Design at least 3-5 distinct rooms with tactical variety
102:- [ ] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
168:- [ ] Add code comments for complex algorithms
169:- [ ] Review and compact any developer-guide.md files over 500 lines
170:- [ ] Verify no code files exceed 1000 lines
171:- [ ] Verify no folders have more than 10 code files
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 2b952ac68e620711205485ba965cd60e20129f64..6242575007932dfe6d4798fafeb15b94799f5d6a
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,12 +14,12 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, loop update dispatch behavior, and runtime HUD event hook integration.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
-- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway connectivity traversal, spawn placement inside rooms, lighting validity, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 - `test_hud.py`: validates HUD snapshot generation (health/ammo/money/crosshair), damage indicator timing, and kill notification/counter behavior.
 
 ## Running Tests
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\tasks.md
@@ -85,6 +85,6 @@
 - [x] Create navigation data for AI pathfinding
-- [ ] Implement room connectivity and doorways
-- [ ] Add environmental lighting setup
-- [ ] Create spawn points for player and bots
-- [ ] Design at least 3-5 distinct rooms with tactical variety
+- [x] Implement room connectivity and doorways
+- [x] Add environmental lighting setup
+- [x] Create spawn points for player and bots
+- [x] Design at least 3-5 distinct rooms with tactical variety
 - [x] Create src/environment folder developer-guide.md
@@ -101,3 +101,3 @@
 - [x] Create src/hud folder developer-guide.md
-- [ ] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
+- [x] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
 
@@ -167,6 +167,6 @@
 - [x] Document controls and gameplay in user-facing documentation
-- [ ] Add code comments for complex algorithms
-- [ ] Review and compact any developer-guide.md files over 500 lines
-- [ ] Verify no code files exceed 1000 lines
-- [ ] Verify no folders have more than 10 code files
+- [x] Add code comments for complex algorithms
+- [x] Review and compact any developer-guide.md files over 500 lines
+- [x] Verify no code files exceed 1000 lines
+- [x] Verify no folders have more than 10 code files
 
apply_patch(auto_approved=true) exited 0 in 330ms:
Success. Updated the following files:
M tasks.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tasks.md b/tasks.md
index b330cd99a78832608e79b0327ef02edc52fed762..442f3df63013a993679b957ab32db1409020d96b
--- a/tasks.md
+++ b/tasks.md
@@ -83,10 +83,10 @@
 - [x] Implement wall collision detection for player and projectiles
 - [x] Add cover objects (crates, walls) throughout the facility
 - [x] Create navigation data for AI pathfinding
-- [ ] Implement room connectivity and doorways
-- [ ] Add environmental lighting setup
-- [ ] Create spawn points for player and bots
-- [ ] Design at least 3-5 distinct rooms with tactical variety
+- [x] Implement room connectivity and doorways
+- [x] Add environmental lighting setup
+- [x] Create spawn points for player and bots
+- [x] Design at least 3-5 distinct rooms with tactical variety
 - [x] Create src/environment folder developer-guide.md
 
 ## HUD System
@@ -99,7 +99,7 @@
 - [x] Create damage indicator visual feedback
 - [x] Add kill notification or counter display
 - [x] Create src/hud folder developer-guide.md
-- [ ] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
+- [x] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
 
 ## Special Effect: "The Glitch"
 
@@ -165,10 +165,10 @@
 - [x] Ensure all code folders have up-to-date developer-guide.md files
 - [x] Create README.md with installation and running instructions
 - [x] Document controls and gameplay in user-facing documentation
-- [ ] Add code comments for complex algorithms
-- [ ] Review and compact any developer-guide.md files over 500 lines
-- [ ] Verify no code files exceed 1000 lines
-- [ ] Verify no folders have more than 10 code files
+- [x] Add code comments for complex algorithms
+- [x] Review and compact any developer-guide.md files over 500 lines
+- [x] Verify no code files exceed 1000 lines
+- [x] Verify no folders have more than 10 code files
 
 ## Deployment & Build
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 2b952ac68e620711205485ba965cd60e20129f64..6242575007932dfe6d4798fafeb15b94799f5d6a
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,12 +14,12 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, loop update dispatch behavior, and runtime HUD event hook integration.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
-- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway connectivity traversal, spawn placement inside rooms, lighting validity, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 - `test_hud.py`: validates HUD snapshot generation (health/ammo/money/crosshair), damage indicator timing, and kill notification/counter behavior.
 
 ## Running Tests
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tasks.md b/tasks.md
index b330cd99a78832608e79b0327ef02edc52fed762..442f3df63013a993679b957ab32db1409020d96b
--- a/tasks.md
+++ b/tasks.md
@@ -83,10 +83,10 @@
 - [x] Implement wall collision detection for player and projectiles
 - [x] Add cover objects (crates, walls) throughout the facility
 - [x] Create navigation data for AI pathfinding
-- [ ] Implement room connectivity and doorways
-- [ ] Add environmental lighting setup
-- [ ] Create spawn points for player and bots
-- [ ] Design at least 3-5 distinct rooms with tactical variety
+- [x] Implement room connectivity and doorways
+- [x] Add environmental lighting setup
+- [x] Create spawn points for player and bots
+- [x] Design at least 3-5 distinct rooms with tactical variety
 - [x] Create src/environment folder developer-guide.md
 
 ## HUD System
@@ -99,7 +99,7 @@
 - [x] Create damage indicator visual feedback
 - [x] Add kill notification or counter display
 - [x] Create src/hud folder developer-guide.md
-- [ ] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
+- [x] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
 
 ## Special Effect: "The Glitch"
 
@@ -165,10 +165,10 @@
 - [x] Ensure all code folders have up-to-date developer-guide.md files
 - [x] Create README.md with installation and running instructions
 - [x] Document controls and gameplay in user-facing documentation
-- [ ] Add code comments for complex algorithms
-- [ ] Review and compact any developer-guide.md files over 500 lines
-- [ ] Verify no code files exceed 1000 lines
-- [ ] Verify no folders have more than 10 code files
+- [x] Add code comments for complex algorithms
+- [x] Review and compact any developer-guide.md files over 500 lines
+- [x] Verify no code files exceed 1000 lines
+- [x] Verify no folders have more than 10 code files
 
 ## Deployment & Build
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 2b952ac68e620711205485ba965cd60e20129f64..6242575007932dfe6d4798fafeb15b94799f5d6a
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,12 +14,12 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, loop update dispatch behavior, and runtime HUD event hook integration.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
-- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway connectivity traversal, spawn placement inside rooms, lighting validity, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 - `test_hud.py`: validates HUD snapshot generation (health/ammo/money/crosshair), damage indicator timing, and kill notification/counter behavior.
 
 ## Running Tests
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():


thinking
**Updating recent changes section**
codex
I’m at the final documentation step: updating `recent-changes.md` with all implemented tasks and validations, then I’ll run one final test pass and summarize results.
file update
M C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4\recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
+# Recent Changes
+
+- Implemented HUD runtime event integration via `src/core/runtime.py`:
+  - Added `HudEventRuntimeBridge` to queue damage/kill events and flush them during `GameLoop` playing-frame callbacks.
+  - Added `RuntimeSession` to compose `Player`, `GameLoop`, and HUD hooks (`apply_player_damage`, `register_bot_kill`, `build_hud_state`).
+  - Exported new runtime types from `src/core/__init__.py`.
+- Expanded environment completeness in `src/environment/facility.py`:
+  - Added explicit doorway connectivity graph traversal (`doorway_graph`, `connected_room_ids`).
+  - Added room lookup helper for positions (`find_room_for_position`).
+  - Added lighting vector helper (`lighting_direction_length`).
+  - Added layout validation for doorway references/widths, spawn presence/placement, lighting sanity, and room validity.
+  - `create_default_facility_layout()` now validates before returning.
+- Added targeted complex-algorithm comments:
+  - Doorway wall-segment splitting in `src/environment/collision.py`.
+  - Segment-projection geometry in `src/ai/tactics.py`.
+- Strengthened tests:
+  - `tests/test_core_systems.py` now verifies runtime HUD damage/kill hooks only apply on `playing` frames.
+  - `tests/test_environment_and_tactics.py` now verifies full room connectivity, spawn positions inside rooms, and lighting validity.
+- Verified documentation/codebase constraints:
+  - No `developer-guide.md` file exceeds 500 lines.
+  - No Python code file exceeds 1000 lines.
+  - No folder contains more than 10 Python code files.
+- Updated relevant developer guides after folder changes:
+  - `src/core/developer-guide.md`
+  - `src/environment/developer-guide.md`
+  - `src/ai/developer-guide.md`
+  - `src/developer-guide.md`
+  - `tests/developer-guide.md`
+  - `developer-guide.md`
 
apply_patch(auto_approved=true) exited 0 in 345ms:
Success. Updated the following files:
M recent-changes.md
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..4f68fdf34e406a52d30da85259b30c5dcb8022f1
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
+# Recent Changes
+
+- Implemented HUD runtime event integration via `src/core/runtime.py`:
+  - Added `HudEventRuntimeBridge` to queue damage/kill events and flush them during `GameLoop` playing-frame callbacks.
+  - Added `RuntimeSession` to compose `Player`, `GameLoop`, and HUD hooks (`apply_player_damage`, `register_bot_kill`, `build_hud_state`).
+  - Exported new runtime types from `src/core/__init__.py`.
+- Expanded environment completeness in `src/environment/facility.py`:
+  - Added explicit doorway connectivity graph traversal (`doorway_graph`, `connected_room_ids`).
+  - Added room lookup helper for positions (`find_room_for_position`).
+  - Added lighting vector helper (`lighting_direction_length`).
+  - Added layout validation for doorway references/widths, spawn presence/placement, lighting sanity, and room validity.
+  - `create_default_facility_layout()` now validates before returning.
+- Added targeted complex-algorithm comments:
+  - Doorway wall-segment splitting in `src/environment/collision.py`.
+  - Segment-projection geometry in `src/ai/tactics.py`.
+- Strengthened tests:
+  - `tests/test_core_systems.py` now verifies runtime HUD damage/kill hooks only apply on `playing` frames.
+  - `tests/test_environment_and_tactics.py` now verifies full room connectivity, spawn positions inside rooms, and lighting validity.
+- Verified documentation/codebase constraints:
+  - No `developer-guide.md` file exceeds 500 lines.
+  - No Python code file exceeds 1000 lines.
+  - No folder contains more than 10 Python code files.
+- Updated relevant developer guides after folder changes:
+  - `src/core/developer-guide.md`
+  - `src/environment/developer-guide.md`
+  - `src/ai/developer-guide.md`
+  - `src/developer-guide.md`
+  - `tests/developer-guide.md`
+  - `developer-guide.md`
 
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tasks.md b/tasks.md
index b330cd99a78832608e79b0327ef02edc52fed762..442f3df63013a993679b957ab32db1409020d96b
--- a/tasks.md
+++ b/tasks.md
@@ -83,10 +83,10 @@
 - [x] Implement wall collision detection for player and projectiles
 - [x] Add cover objects (crates, walls) throughout the facility
 - [x] Create navigation data for AI pathfinding
-- [ ] Implement room connectivity and doorways
-- [ ] Add environmental lighting setup
-- [ ] Create spawn points for player and bots
-- [ ] Design at least 3-5 distinct rooms with tactical variety
+- [x] Implement room connectivity and doorways
+- [x] Add environmental lighting setup
+- [x] Create spawn points for player and bots
+- [x] Design at least 3-5 distinct rooms with tactical variety
 - [x] Create src/environment folder developer-guide.md
 
 ## HUD System
@@ -99,7 +99,7 @@
 - [x] Create damage indicator visual feedback
 - [x] Add kill notification or counter display
 - [x] Create src/hud folder developer-guide.md
-- [ ] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
+- [x] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
 
 ## Special Effect: "The Glitch"
 
@@ -165,10 +165,10 @@
 - [x] Ensure all code folders have up-to-date developer-guide.md files
 - [x] Create README.md with installation and running instructions
 - [x] Document controls and gameplay in user-facing documentation
-- [ ] Add code comments for complex algorithms
-- [ ] Review and compact any developer-guide.md files over 500 lines
-- [ ] Verify no code files exceed 1000 lines
-- [ ] Verify no folders have more than 10 code files
+- [x] Add code comments for complex algorithms
+- [x] Review and compact any developer-guide.md files over 500 lines
+- [x] Verify no code files exceed 1000 lines
+- [x] Verify no folders have more than 10 code files
 
 ## Deployment & Build
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 2b952ac68e620711205485ba965cd60e20129f64..6242575007932dfe6d4798fafeb15b94799f5d6a
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,12 +14,12 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, loop update dispatch behavior, and runtime HUD event hook integration.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
-- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway connectivity traversal, spawn placement inside rooms, lighting validity, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 - `test_hud.py`: validates HUD snapshot generation (health/ammo/money/crosshair), damage indicator timing, and kill notification/counter behavior.
 
 ## Running Tests
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..4f68fdf34e406a52d30da85259b30c5dcb8022f1
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
+# Recent Changes
+
+- Implemented HUD runtime event integration via `src/core/runtime.py`:
+  - Added `HudEventRuntimeBridge` to queue damage/kill events and flush them during `GameLoop` playing-frame callbacks.
+  - Added `RuntimeSession` to compose `Player`, `GameLoop`, and HUD hooks (`apply_player_damage`, `register_bot_kill`, `build_hud_state`).
+  - Exported new runtime types from `src/core/__init__.py`.
+- Expanded environment completeness in `src/environment/facility.py`:
+  - Added explicit doorway connectivity graph traversal (`doorway_graph`, `connected_room_ids`).
+  - Added room lookup helper for positions (`find_room_for_position`).
+  - Added lighting vector helper (`lighting_direction_length`).
+  - Added layout validation for doorway references/widths, spawn presence/placement, lighting sanity, and room validity.
+  - `create_default_facility_layout()` now validates before returning.
+- Added targeted complex-algorithm comments:
+  - Doorway wall-segment splitting in `src/environment/collision.py`.
+  - Segment-projection geometry in `src/ai/tactics.py`.
+- Strengthened tests:
+  - `tests/test_core_systems.py` now verifies runtime HUD damage/kill hooks only apply on `playing` frames.
+  - `tests/test_environment_and_tactics.py` now verifies full room connectivity, spawn positions inside rooms, and lighting validity.
+- Verified documentation/codebase constraints:
+  - No `developer-guide.md` file exceeds 500 lines.
+  - No Python code file exceeds 1000 lines.
+  - No folder contains more than 10 Python code files.
+- Updated relevant developer guides after folder changes:
+  - `src/core/developer-guide.md`
+  - `src/environment/developer-guide.md`
+  - `src/ai/developer-guide.md`
+  - `src/developer-guide.md`
+  - `tests/developer-guide.md`
+  - `developer-guide.md`
 
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tasks.md b/tasks.md
index b330cd99a78832608e79b0327ef02edc52fed762..442f3df63013a993679b957ab32db1409020d96b
--- a/tasks.md
+++ b/tasks.md
@@ -83,10 +83,10 @@
 - [x] Implement wall collision detection for player and projectiles
 - [x] Add cover objects (crates, walls) throughout the facility
 - [x] Create navigation data for AI pathfinding
-- [ ] Implement room connectivity and doorways
-- [ ] Add environmental lighting setup
-- [ ] Create spawn points for player and bots
-- [ ] Design at least 3-5 distinct rooms with tactical variety
+- [x] Implement room connectivity and doorways
+- [x] Add environmental lighting setup
+- [x] Create spawn points for player and bots
+- [x] Design at least 3-5 distinct rooms with tactical variety
 - [x] Create src/environment folder developer-guide.md
 
 ## HUD System
@@ -99,7 +99,7 @@
 - [x] Create damage indicator visual feedback
 - [x] Add kill notification or counter display
 - [x] Create src/hud folder developer-guide.md
-- [ ] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
+- [x] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
 
 ## Special Effect: "The Glitch"
 
@@ -165,10 +165,10 @@
 - [x] Ensure all code folders have up-to-date developer-guide.md files
 - [x] Create README.md with installation and running instructions
 - [x] Document controls and gameplay in user-facing documentation
-- [ ] Add code comments for complex algorithms
-- [ ] Review and compact any developer-guide.md files over 500 lines
-- [ ] Verify no code files exceed 1000 lines
-- [ ] Verify no folders have more than 10 code files
+- [x] Add code comments for complex algorithms
+- [x] Review and compact any developer-guide.md files over 500 lines
+- [x] Verify no code files exceed 1000 lines
+- [x] Verify no folders have more than 10 code files
 
 ## Deployment & Build
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 2b952ac68e620711205485ba965cd60e20129f64..6242575007932dfe6d4798fafeb15b94799f5d6a
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,12 +14,12 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, loop update dispatch behavior, and runtime HUD event hook integration.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
-- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway connectivity traversal, spawn placement inside rooms, lighting validity, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 - `test_hud.py`: validates HUD snapshot generation (health/ammo/money/crosshair), damage indicator timing, and kill notification/counter behavior.
 
 ## Running Tests
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():


thinking
**Verifying with tests**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'pytest -q' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 582ms:
...............................................                          [100%]
47 passed in 0.08s
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..4f68fdf34e406a52d30da85259b30c5dcb8022f1
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
+# Recent Changes
+
+- Implemented HUD runtime event integration via `src/core/runtime.py`:
+  - Added `HudEventRuntimeBridge` to queue damage/kill events and flush them during `GameLoop` playing-frame callbacks.
+  - Added `RuntimeSession` to compose `Player`, `GameLoop`, and HUD hooks (`apply_player_damage`, `register_bot_kill`, `build_hud_state`).
+  - Exported new runtime types from `src/core/__init__.py`.
+- Expanded environment completeness in `src/environment/facility.py`:
+  - Added explicit doorway connectivity graph traversal (`doorway_graph`, `connected_room_ids`).
+  - Added room lookup helper for positions (`find_room_for_position`).
+  - Added lighting vector helper (`lighting_direction_length`).
+  - Added layout validation for doorway references/widths, spawn presence/placement, lighting sanity, and room validity.
+  - `create_default_facility_layout()` now validates before returning.
+- Added targeted complex-algorithm comments:
+  - Doorway wall-segment splitting in `src/environment/collision.py`.
+  - Segment-projection geometry in `src/ai/tactics.py`.
+- Strengthened tests:
+  - `tests/test_core_systems.py` now verifies runtime HUD damage/kill hooks only apply on `playing` frames.
+  - `tests/test_environment_and_tactics.py` now verifies full room connectivity, spawn positions inside rooms, and lighting validity.
+- Verified documentation/codebase constraints:
+  - No `developer-guide.md` file exceeds 500 lines.
+  - No Python code file exceeds 1000 lines.
+  - No folder contains more than 10 Python code files.
+- Updated relevant developer guides after folder changes:
+  - `src/core/developer-guide.md`
+  - `src/environment/developer-guide.md`
+  - `src/ai/developer-guide.md`
+  - `src/developer-guide.md`
+  - `tests/developer-guide.md`
+  - `developer-guide.md`
 
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tasks.md b/tasks.md
index b330cd99a78832608e79b0327ef02edc52fed762..442f3df63013a993679b957ab32db1409020d96b
--- a/tasks.md
+++ b/tasks.md
@@ -83,10 +83,10 @@
 - [x] Implement wall collision detection for player and projectiles
 - [x] Add cover objects (crates, walls) throughout the facility
 - [x] Create navigation data for AI pathfinding
-- [ ] Implement room connectivity and doorways
-- [ ] Add environmental lighting setup
-- [ ] Create spawn points for player and bots
-- [ ] Design at least 3-5 distinct rooms with tactical variety
+- [x] Implement room connectivity and doorways
+- [x] Add environmental lighting setup
+- [x] Create spawn points for player and bots
+- [x] Design at least 3-5 distinct rooms with tactical variety
 - [x] Create src/environment folder developer-guide.md
 
 ## HUD System
@@ -99,7 +99,7 @@
 - [x] Create damage indicator visual feedback
 - [x] Add kill notification or counter display
 - [x] Create src/hud folder developer-guide.md
-- [ ] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
+- [x] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
 
 ## Special Effect: "The Glitch"
 
@@ -165,10 +165,10 @@
 - [x] Ensure all code folders have up-to-date developer-guide.md files
 - [x] Create README.md with installation and running instructions
 - [x] Document controls and gameplay in user-facing documentation
-- [ ] Add code comments for complex algorithms
-- [ ] Review and compact any developer-guide.md files over 500 lines
-- [ ] Verify no code files exceed 1000 lines
-- [ ] Verify no folders have more than 10 code files
+- [x] Add code comments for complex algorithms
+- [x] Review and compact any developer-guide.md files over 500 lines
+- [x] Verify no code files exceed 1000 lines
+- [x] Verify no folders have more than 10 code files
 
 ## Deployment & Build
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 2b952ac68e620711205485ba965cd60e20129f64..6242575007932dfe6d4798fafeb15b94799f5d6a
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,12 +14,12 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, loop update dispatch behavior, and runtime HUD event hook integration.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
-- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway connectivity traversal, spawn placement inside rooms, lighting validity, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 - `test_hud.py`: validates HUD snapshot generation (health/ammo/money/crosshair), damage indicator timing, and kill notification/counter behavior.
 
 ## Running Tests
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():


thinking
**Verifying code changes with git**
exec
"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe" -Command 'git status --short' in C:\Users\shlob\Pycharm Projects\harness-test\harness-test-4 succeeded in 192ms:
 M .agentharness/git-commit-message.txt
 D .codex_last_message.txt
 M developer-guide.md
 M recent-changes.md
 M src/ai/developer-guide.md
 M src/ai/tactics.py
 M src/core/__init__.py
 M src/core/developer-guide.md
 M src/developer-guide.md
 M src/environment/collision.py
 M src/environment/developer-guide.md
 M src/environment/facility.py
 M tasks.md
 M tests/developer-guide.md
 M tests/test_core_systems.py
 M tests/test_environment_and_tactics.py
?? .agentharness/live-llm/llm_20260208_185640_73f8dacd.log
?? src/core/runtime.py
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..4f68fdf34e406a52d30da85259b30c5dcb8022f1
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
+# Recent Changes
+
+- Implemented HUD runtime event integration via `src/core/runtime.py`:
+  - Added `HudEventRuntimeBridge` to queue damage/kill events and flush them during `GameLoop` playing-frame callbacks.
+  - Added `RuntimeSession` to compose `Player`, `GameLoop`, and HUD hooks (`apply_player_damage`, `register_bot_kill`, `build_hud_state`).
+  - Exported new runtime types from `src/core/__init__.py`.
+- Expanded environment completeness in `src/environment/facility.py`:
+  - Added explicit doorway connectivity graph traversal (`doorway_graph`, `connected_room_ids`).
+  - Added room lookup helper for positions (`find_room_for_position`).
+  - Added lighting vector helper (`lighting_direction_length`).
+  - Added layout validation for doorway references/widths, spawn presence/placement, lighting sanity, and room validity.
+  - `create_default_facility_layout()` now validates before returning.
+- Added targeted complex-algorithm comments:
+  - Doorway wall-segment splitting in `src/environment/collision.py`.
+  - Segment-projection geometry in `src/ai/tactics.py`.
+- Strengthened tests:
+  - `tests/test_core_systems.py` now verifies runtime HUD damage/kill hooks only apply on `playing` frames.
+  - `tests/test_environment_and_tactics.py` now verifies full room connectivity, spawn positions inside rooms, and lighting validity.
+- Verified documentation/codebase constraints:
+  - No `developer-guide.md` file exceeds 500 lines.
+  - No Python code file exceeds 1000 lines.
+  - No folder contains more than 10 Python code files.
+- Updated relevant developer guides after folder changes:
+  - `src/core/developer-guide.md`
+  - `src/environment/developer-guide.md`
+  - `src/ai/developer-guide.md`
+  - `src/developer-guide.md`
+  - `tests/developer-guide.md`
+  - `developer-guide.md`
 
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tasks.md b/tasks.md
index b330cd99a78832608e79b0327ef02edc52fed762..442f3df63013a993679b957ab32db1409020d96b
--- a/tasks.md
+++ b/tasks.md
@@ -83,10 +83,10 @@
 - [x] Implement wall collision detection for player and projectiles
 - [x] Add cover objects (crates, walls) throughout the facility
 - [x] Create navigation data for AI pathfinding
-- [ ] Implement room connectivity and doorways
-- [ ] Add environmental lighting setup
-- [ ] Create spawn points for player and bots
-- [ ] Design at least 3-5 distinct rooms with tactical variety
+- [x] Implement room connectivity and doorways
+- [x] Add environmental lighting setup
+- [x] Create spawn points for player and bots
+- [x] Design at least 3-5 distinct rooms with tactical variety
 - [x] Create src/environment folder developer-guide.md
 
 ## HUD System
@@ -99,7 +99,7 @@
 - [x] Create damage indicator visual feedback
 - [x] Add kill notification or counter display
 - [x] Create src/hud folder developer-guide.md
-- [ ] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
+- [x] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
 
 ## Special Effect: "The Glitch"
 
@@ -165,10 +165,10 @@
 - [x] Ensure all code folders have up-to-date developer-guide.md files
 - [x] Create README.md with installation and running instructions
 - [x] Document controls and gameplay in user-facing documentation
-- [ ] Add code comments for complex algorithms
-- [ ] Review and compact any developer-guide.md files over 500 lines
-- [ ] Verify no code files exceed 1000 lines
-- [ ] Verify no folders have more than 10 code files
+- [x] Add code comments for complex algorithms
+- [x] Review and compact any developer-guide.md files over 500 lines
+- [x] Verify no code files exceed 1000 lines
+- [x] Verify no folders have more than 10 code files
 
 ## Deployment & Build
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 2b952ac68e620711205485ba965cd60e20129f64..6242575007932dfe6d4798fafeb15b94799f5d6a
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,12 +14,12 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, loop update dispatch behavior, and runtime HUD event hook integration.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
-- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway connectivity traversal, spawn placement inside rooms, lighting validity, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 - `test_hud.py`: validates HUD snapshot generation (health/ammo/money/crosshair), damage indicator timing, and kill notification/counter behavior.
 
 ## Running Tests
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():


thinking
**Noticing unrelated workspace changes**
codex
Implemented 9 incomplete tasks end-to-end and updated both required tracking files.

Completed tasks (now checked in `tasks.md`):
1. `Implement room connectivity and doorways`
2. `Add environmental lighting setup`
3. `Create spawn points for player and bots`
4. `Design at least 3-5 distinct rooms with tactical variety`
5. `Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)`
6. `Add code comments for complex algorithms`
7. `Review and compact any developer-guide.md files over 500 lines`
8. `Verify no code files exceed 1000 lines`
9. `Verify no folders have more than 10 code files`

Key implementation changes:
- Added HUD runtime integration in `src/core/runtime.py` and exports in `src/core/__init__.py`.
- Added environment connectivity/validation helpers in `src/environment/facility.py`.
- Added algorithm comments in `src/environment/collision.py` and `src/ai/tactics.py`.
- Extended tests in `tests/test_core_systems.py` and `tests/test_environment_and_tactics.py`.

Documentation updates (per-folder + ancestors):
- `src/core/developer-guide.md`
- `src/environment/developer-guide.md`
- `src/ai/developer-guide.md`
- `src/developer-guide.md`
- `tests/developer-guide.md`
- `developer-guide.md`

Required tracking files updated:
- `tasks.md` (checked completed items)
- `recent-changes.md` (detailed change log)

Validation:
- `pytest -q` passed: **47 passed**.
- Verified: no `.py` file >1000 lines; no folder has >10 Python code files; no developer guide >500 lines.
file update:
diff --git a/developer-guide.md b/developer-guide.md
index 769e46d31261f4affd568075ecb9b9dbebe7834f..870f6a91c4f10ee8a515b6ff3e3008440739e999
--- a/developer-guide.md
+++ b/developer-guide.md
@@ -7,6 +7,7 @@
 - Core runtime loop and timing
 - State machine for high-level game flow
 - Clock pause/resume and time scaling controls
+- Runtime bridge for HUD damage/kill event hooks through the frame loop
 - Input normalization for WASD + mouse look
 - First-person camera and movement/collision simulation
 - Raycasting-based hit-scan traces
@@ -16,13 +17,15 @@
 - Shop wheel UI logic with radial layout, weapon prices, affordability feedback, purchase validation, and inventory equip flow
 - HUD overlay logic for health/ammo/money/crosshair, damage feedback, and kill notifications
 - Multi-room facility model with doorway connectivity, cover placements, lighting profile, and nav waypoints
+- Facility layout validation for doorways, spawn placement, and non-degenerate lighting vectors
 - Collision world generation from environment rooms/doorways/cover for movement and projectile systems
 - Bot runtime model with stateful health/death handling, shot variance, tactical action selection, cover/flank planning, and wave spawning
 - Money drop economy with collectible pickups, collision-based collection, and primitive visual definitions
 
 ## Directory Map
 - `src/`: runtime game systems.
-  - `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, and raycasting.
+- `src/core/`: game loop, game clock, state manager, input, camera, movement, collision primitives, raycasting, and HUD event/runtime bridges.
   - `src/player/`: player runtime state, combat APIs, instant/smooth inventory switching, reload, hit-scan, and respawn.
   - `src/weapons/`: weapon base model, concrete implementations, visual definitions, and switch transition state.
   - `src/projectiles/`: projectile entity construction and world collision physics.
@@ -65,11 +68,12 @@
 - `ai.tactics` evaluates cover and picks `attack`/`take_cover`/`flank`, including side-approach flank routes.
 - `ai.waves.WaveDirector` scales bot count and difficulty as waves progress.
 - `WaypointPathfinder` computes nearest-waypoint BFS paths for baseline bot movement planning.
-- `environment.create_default_facility_layout()` defines a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
+- `environment.create_default_facility_layout()` defines and validates a 5-room indoor map with doorways, cover, waypoints, bot/player spawns, and lighting values.
 - `environment.build_collision_world(...)` transforms environment geometry into wall+cover collision AABBs.
 - `environment.build_waypoint_pathfinder(...)` builds validated nav graphs from facility waypoint data.
 - `MoneyPickupSystem` manages spawned money drops, pickup collisions, TTL expiration, and player-balance updates.
 - `HudOverlayController` builds a single HUD payload and tracks timed damage/kill feedback effects.
+- `HudEventRuntimeBridge` + `RuntimeSession` hook HUD damage/kill events into `GameLoop` update callbacks and expose frame-ready HUD state.
 
 ## Development Notes
 - Keep gameplay constants in `config/config.py` until a richer configuration layer is needed.
diff --git a/recent-changes.md b/recent-changes.md
index 73d5ad7434e94381604299428ce28289809331c0..4f68fdf34e406a52d30da85259b30c5dcb8022f1
--- a/recent-changes.md
+++ b/recent-changes.md
@@ -1,2 +1,30 @@
-# Recent Changes
+# Recent Changes
+
+- Implemented HUD runtime event integration via `src/core/runtime.py`:
+  - Added `HudEventRuntimeBridge` to queue damage/kill events and flush them during `GameLoop` playing-frame callbacks.
+  - Added `RuntimeSession` to compose `Player`, `GameLoop`, and HUD hooks (`apply_player_damage`, `register_bot_kill`, `build_hud_state`).
+  - Exported new runtime types from `src/core/__init__.py`.
+- Expanded environment completeness in `src/environment/facility.py`:
+  - Added explicit doorway connectivity graph traversal (`doorway_graph`, `connected_room_ids`).
+  - Added room lookup helper for positions (`find_room_for_position`).
+  - Added lighting vector helper (`lighting_direction_length`).
+  - Added layout validation for doorway references/widths, spawn presence/placement, lighting sanity, and room validity.
+  - `create_default_facility_layout()` now validates before returning.
+- Added targeted complex-algorithm comments:
+  - Doorway wall-segment splitting in `src/environment/collision.py`.
+  - Segment-projection geometry in `src/ai/tactics.py`.
+- Strengthened tests:
+  - `tests/test_core_systems.py` now verifies runtime HUD damage/kill hooks only apply on `playing` frames.
+  - `tests/test_environment_and_tactics.py` now verifies full room connectivity, spawn positions inside rooms, and lighting validity.
+- Verified documentation/codebase constraints:
+  - No `developer-guide.md` file exceeds 500 lines.
+  - No Python code file exceeds 1000 lines.
+  - No folder contains more than 10 Python code files.
+- Updated relevant developer guides after folder changes:
+  - `src/core/developer-guide.md`
+  - `src/environment/developer-guide.md`
+  - `src/ai/developer-guide.md`
+  - `src/developer-guide.md`
+  - `tests/developer-guide.md`
+  - `developer-guide.md`
 
diff --git a/src/ai/developer-guide.md b/src/ai/developer-guide.md
index 2c446b82795284efbaf5ca920b7991a1a7b2d511..45b001f0ac2e8ecc4567db5d9ab087084dd36ad6
--- a/src/ai/developer-guide.md
+++ b/src/ai/developer-guide.md
@@ -18,6 +18,7 @@
 - `Bot.spawn_money_drop(...)` emits a `MoneyPickup` through `MoneyPickupSystem` and is allowed only after death.
 - `WaypointPathfinder.find_path(...)` maps world positions to nearest waypoints and returns a connected path using BFS over waypoint links.
 - `find_cover_plan(...)` finds nearest usable cover that can break line-of-fire from player to bot.
+- `tactics` geometry helpers use 2D segment projection to estimate whether cover blocks the player->bot line.
 - `choose_tactical_action(...)` decides between `attack`, `take_cover`, and `flank` based on health, distance, allies, and available cover. Raises `ValueError` if called on a dead bot; callers must filter dead bots before calling.
 - `build_flank_route(...)` returns side-approach points so bots can pressure from multiple angles.
 - `WaveDirector` scales bot count and difficulty per wave and spawns wave bots at provided spawn positions.
diff --git a/src/ai/tactics.py b/src/ai/tactics.py
index 93dd1af5342057eefc7e7c8616b2dfe5ac076633..3a39e4fd8aa24183768130a1d7dd234bb86ec18e
--- a/src/ai/tactics.py
+++ b/src/ai/tactics.py
@@ -44,6 +44,7 @@
     ab_len_sq = (ab_x * ab_x) + (ab_z * ab_z)
     if ab_len_sq <= 1e-9:
         return _distance_2d(a, p)
+    # Project point p onto segment ab and clamp to segment endpoints.
     t = ((ap_x * ab_x) + (ap_z * ab_z)) / ab_len_sq
     t = max(0.0, min(1.0, t))
     closest = (a[0] + (ab_x * t), 0.0, a[2] + (ab_z * t))
diff --git a/src/core/__init__.py b/src/core/__init__.py
index 61af34f368f93d5dcf1060c9147f96ca7fe2baeb..bebbc328c42211977a7bc55ec960c1ba77dae62c
--- a/src/core/__init__.py
+++ b/src/core/__init__.py
@@ -8,6 +8,7 @@
 from src.core.input_handler import InputFrame, InputHandler, InputSnapshot
 from src.core.movement import PlayerMovementController
 from src.core.raycasting import RaycastHit, RaycastingSystem, RaycastTarget
+from src.core.runtime import HudEventRuntimeBridge, RuntimeSession
 
 __all__ = [
     "AABB",
@@ -24,4 +25,6 @@
     "RaycastHit",
     "RaycastingSystem",
     "RaycastTarget",
+    "HudEventRuntimeBridge",
+    "RuntimeSession",
 ]
diff --git a/src/core/developer-guide.md b/src/core/developer-guide.md
index 17eddafeb8adfdad331dcb5c166e8ac39657e199..49b8617f1b241d46bf59d4032041684d04fc2872
--- a/src/core/developer-guide.md
+++ b/src/core/developer-guide.md
@@ -12,6 +12,7 @@
 - `collision.py`: AABB and `CollisionWorld` primitives for wall/bounds collision checks.
 - `movement.py`: `PlayerMovementController` for yaw-relative movement with collision + slide resolution.
 - `raycasting.py`: `RaycastingSystem` with nearest-hit line traces against spherical targets for hit-scan shooting.
+- `runtime.py`: runtime composition helpers that wire `HudOverlayController` damage/kill events into `GameLoop` frame updates.
 
 ## Behavior Notes
 - `GameStateManager` blocks invalid transitions with `ValueError`.
@@ -24,3 +25,5 @@
 - Movement checks full displacement first, then attempts axis-aligned slide fallback before stopping.
 - `CollisionWorld.outside_world_bounds` checks full containment: returns `True` if any part of the box is outside world bounds.
 - `RaycastingSystem.cast_ray(...)` returns the closest valid target hit (or `None`) within max distance.
+- `HudEventRuntimeBridge` queues damage/kill events and flushes them only on active `playing` frames.
+- `RuntimeSession` provides a minimal player+HUD runtime wrapper with `apply_player_damage(...)`, `register_bot_kill(...)`, and `build_hud_state(...)`.
diff --git a/src/core/runtime.py b/src/core/runtime.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc74469d68dfb3b305c349035bdfd97256ff0f21
--- /dev/null
+++ b/src/core/runtime.py
@@ -0,0 +1,76 @@
+"""Runtime wiring helpers that bridge gameplay events to HUD updates."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+
+from src.core.game_loop import GameLoop
+from src.hud.overlay import HudOverlayController, HudOverlayState
+from src.player.player import Player
+
+
+@dataclass
+class HudEventRuntimeBridge:
+    """Queues gameplay events and applies them to the HUD inside game-loop updates."""
+
+    game_loop: GameLoop
+    hud_controller: HudOverlayController
+    _pending_damage_events: list[int] = field(default_factory=list)
+    _pending_kill_events: list[str] = field(default_factory=list)
+
+    def __post_init__(self) -> None:
+        self.game_loop.register_update_callback(self.on_frame_update)
+
+    def queue_damage_event(self, amount: int) -> None:
+        """Queue a player damage event to be flushed during the next playing frame."""
+        if amount <= 0:
+            raise ValueError("amount must be positive.")
+        self._pending_damage_events.append(amount)
+
+    def queue_kill_event(self, enemy_label: str = "Bot") -> None:
+        """Queue a kill event to be flushed during the next playing frame."""
+        self._pending_kill_events.append(enemy_label)
+
+    def on_frame_update(self, delta_time: float) -> None:
+        """Flush queued events and advance transient HUD timers."""
+        for amount in self._pending_damage_events:
+            self.hud_controller.register_damage(amount)
+        self._pending_damage_events.clear()
+
+        for enemy_label in self._pending_kill_events:
+            self.hud_controller.register_kill(enemy_label)
+        self._pending_kill_events.clear()
+
+        self.hud_controller.step(delta_time)
+
+
+@dataclass
+class RuntimeSession:
+    """Minimal runtime composition helper for player + HUD integration."""
+
+    player: Player
+    game_loop: GameLoop
+    hud_controller: HudOverlayController = field(default_factory=HudOverlayController)
+    hud_bridge: HudEventRuntimeBridge = field(init=False)
+
+    def __post_init__(self) -> None:
+        self.hud_bridge = HudEventRuntimeBridge(
+            game_loop=self.game_loop,
+            hud_controller=self.hud_controller,
+        )
+
+    def apply_player_damage(self, amount: int) -> None:
+        """Apply player damage and enqueue HUD feedback."""
+        health_before = self.player.health
+        self.player.apply_damage(amount)
+        damage_taken = health_before - self.player.health
+        if damage_taken > 0:
+            self.hud_bridge.queue_damage_event(damage_taken)
+
+    def register_bot_kill(self, enemy_label: str = "Bot") -> None:
+        """Queue a bot kill event for HUD notification/counter updates."""
+        self.hud_bridge.queue_kill_event(enemy_label)
+
+    def build_hud_state(self) -> HudOverlayState:
+        """Build a render-ready HUD state for the current player frame."""
+        return self.hud_controller.build_state(self.player)
diff --git a/src/developer-guide.md b/src/developer-guide.md
index c8eaf64ff62eaeb12f1cc6e0cb23b68af0b69fdb..16344ae518b097bf7f62a82da42171997789a40c
--- a/src/developer-guide.md
+++ b/src/developer-guide.md
@@ -4,7 +4,7 @@
 `src/` contains the game runtime modules for loop/state management, player logic, weapons, and projectile simulation.
 
 ## Folder Overview
-- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, and raycasting.
+- `core/`: frame stepping, game clock (pause + time scale), state machine, input normalization, first-person camera state, movement, collision primitives, raycasting, and HUD runtime event bridges.
 - `player/`: player runtime model (health, money, inventory, immediate + smooth weapon switching, reload, hit-scan/projectile shooting, game-over/respawn).
 - `weapons/`: reusable weapon abstractions, concrete weapons (pistol/shotgun/assault rifle/RPG), switch-transition state, and primitive visual definitions.
 - `projectiles/`: projectile entities plus physics stepping and world collision checks.
@@ -12,7 +12,7 @@
 - `hud/`: HUD overlay payload generation for health, ammo, money, crosshair, damage feedback, and kill notifications.
 - `ai/`: bot runtime model, shot-accuracy helpers, tactical decision/cover/flank planners, and wave spawning+difficulty scaling.
 - `economy/`: money pickup entities, glowing primitive visual definitions, pickup lifecycle, and player collection logic.
-- `environment/`: multi-room facility definitions, doorway connectivity, cover placements, collision world generation, and nav graph generation.
+- `environment/`: multi-room facility definitions, doorway connectivity, spawn/light validation helpers, cover placements, collision world generation, and nav graph generation.
 
 ## Integration Flow
 1. The platform layer collects raw input and passes it to `core.input_handler.InputHandler`.
@@ -31,3 +31,4 @@
 14. `ai.waves.WaveDirector` scales wave difficulty and spawns multiple bots from configured spawn positions.
 15. `economy.money.MoneyPickupSystem` resolves pickup collisions and deposits collected money to `player.Player`.
 16. `hud.HudOverlayController` builds render-ready HUD state and manages damage/kill feedback timers.
+17. `core.runtime.RuntimeSession` and `HudEventRuntimeBridge` queue gameplay damage/kill events and flush them to HUD only during active `playing` loop frames.
diff --git a/src/environment/collision.py b/src/environment/collision.py
index fbbaf8e315b16edc9e1fb65967ec3c45b01399b9..d66c8684c0ce8fff1c0515847ed30ab8b215af03
--- a/src/environment/collision.py
+++ b/src/environment/collision.py
@@ -16,6 +16,7 @@
         if cut_max <= cut_min:
             continue
         next_segments: list[tuple[float, float]] = []
+        # Split each surviving segment around the doorway opening.
         for seg_min, seg_max in segments:
             if cut_max <= seg_min or cut_min >= seg_max:
                 next_segments.append((seg_min, seg_max))
diff --git a/src/environment/developer-guide.md b/src/environment/developer-guide.md
index 57e549bdbe14926f8fa1119ae0b3dc31126c1937..a875244a8621b872f798a88f4527cc678208f46d
--- a/src/environment/developer-guide.md
+++ b/src/environment/developer-guide.md
@@ -4,7 +4,7 @@
 `src/environment/` defines the indoor facility layout and turns that layout into reusable collision and navigation data.
 
 ## Files
-- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a 5-room tactical facility.
+- `facility.py`: dataclasses for rooms, doorways, cover objects, spawn points, and lighting; includes `create_default_facility_layout()` with a validated 5-room tactical facility and helpers for doorway graph traversal and spawn-room lookups.
 - `collision.py`: converts room boundaries + doorway openings + blocking cover into a `CollisionWorld` for player and projectile collision.
 - `navigation.py`: validates layout waypoint links and creates a `WaypointPathfinder`.
 - `__init__.py`: package exports for facility, collision, and navigation helpers.
@@ -16,8 +16,10 @@
 - Waypoint graph and links for AI route planning.
 - Spawn point records for player and bots.
 - Engine-agnostic ambient + directional lighting profile.
+- Layout validation enforces doorway integrity, spawn placement inside rooms, non-zero directional light vectors, and minimum room count.
 
 ## Integration Notes
 - Build runtime collision data with `build_collision_world(layout)` and pass it to movement/projectile systems.
 - Build AI pathfinding with `build_waypoint_pathfinder(layout)` to keep navigation synced with room geometry.
 - Keep room and doorway geometry in `facility.py` as the single source of truth for environment updates.
+- Use `layout.connected_room_ids(...)` and `layout.find_room_for_position(...)` when systems need explicit room connectivity or spawn/position checks.
diff --git a/src/environment/facility.py b/src/environment/facility.py
index 4f228f285391dccd8591ce3d4929f5f939b9ac9d..9e85515639f66b8e36846b5b298610f0c52db430
--- a/src/environment/facility.py
+++ b/src/environment/facility.py
@@ -3,6 +3,7 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
+from math import sqrt
 from typing import Literal
 
 
@@ -105,6 +106,37 @@
     def room_ids(self) -> set[str]:
         return set(self.rooms.keys())
 
+    def doorway_graph(self) -> dict[str, set[str]]:
+        graph: dict[str, set[str]] = {room_id: set() for room_id in self.rooms}
+        for doorway in self.doorways:
+            graph.setdefault(doorway.room_a, set()).add(doorway.room_b)
+            graph.setdefault(doorway.room_b, set()).add(doorway.room_a)
+        return graph
+
+    def connected_room_ids(self, start_room_id: str) -> set[str]:
+        """Return every room reachable from a starting room through doorways."""
+        if start_room_id not in self.rooms:
+            raise ValueError(f"Unknown room_id '{start_room_id}'.")
+        graph = self.doorway_graph()
+        visited: set[str] = set()
+        frontier = [start_room_id]
+        while frontier:
+            room_id = frontier.pop()
+            if room_id in visited:
+                continue
+            visited.add(room_id)
+            for neighbor in graph.get(room_id, set()):
+                if neighbor not in visited:
+                    frontier.append(neighbor)
+        return visited
+
+    def find_room_for_position(self, position: Vector3) -> str | None:
+        x, _, z = position
+        for room in self.rooms.values():
+            if room.min_x <= x <= room.max_x and room.min_z <= z <= room.max_z:
+                return room.room_id
+        return None
+
     def bot_spawn_positions(self) -> list[Vector3]:
         return [spawn.position for spawn in self.spawn_points if spawn.team == "bot"]
 
@@ -114,7 +146,46 @@
                 return spawn.position
         raise ValueError("Facility layout must define one player spawn point.")
 
+    def lighting_direction_length(self) -> float:
+        direction = self.lighting.directional_direction
+        return sqrt(
+            (direction[0] * direction[0])
+            + (direction[1] * direction[1])
+            + (direction[2] * direction[2])
+        )
+
+    def validate(self) -> None:
+        """Validate doorway/spawn/lighting integrity for runtime safety."""
+        room_ids = self.room_ids()
+        for doorway in self.doorways:
+            if doorway.room_a not in room_ids or doorway.room_b not in room_ids:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' links undefined rooms.")
+            if doorway.width <= 0.0:
+                raise ValueError(f"Doorway '{doorway.doorway_id}' width must be positive.")
 
+        player_spawns = [spawn for spawn in self.spawn_points if spawn.team == "player"]
+        if len(player_spawns) != 1:
+            raise ValueError("Facility layout must define exactly one player spawn.")
+        bot_spawns = [spawn for spawn in self.spawn_points if spawn.team == "bot"]
+        if not bot_spawns:
+            raise ValueError("Facility layout must define at least one bot spawn.")
+        for spawn in self.spawn_points:
+            if self.find_room_for_position(spawn.position) is None:
+                raise ValueError(f"Spawn point '{spawn.spawn_id}' is outside all rooms.")
+
+        if self.lighting.ambient_intensity < 0.0 or self.lighting.directional_intensity < 0.0:
+            raise ValueError("Lighting intensities must be non-negative.")
+        if self.lighting_direction_length() <= 0.0:
+            raise ValueError("Directional lighting direction must be non-zero.")
+
+        # Distinct-room requirement for tactical variety.
+        if len(self.rooms) < 3:
+            raise ValueError("Facility layout must define at least three rooms.")
+        for room in self.rooms.values():
+            if room.max_x <= room.min_x or room.max_z <= room.min_z:
+                raise ValueError(f"Room '{room.room_id}' has invalid dimensions.")
+
+
 def create_default_facility_layout() -> FacilityLayout:
     """Return a 5-room tactical facility with doorways, cover, and nav data."""
     rooms = {
@@ -237,7 +308,7 @@
         directional_direction=(-0.6, -1.0, -0.3),
     )
 
-    return FacilityLayout(
+    layout = FacilityLayout(
         rooms=rooms,
         doorways=doorways,
         cover_objects=cover_objects,
@@ -246,3 +317,5 @@
         spawn_points=spawn_points,
         lighting=lighting,
     )
+    layout.validate()
+    return layout
diff --git a/tasks.md b/tasks.md
index b330cd99a78832608e79b0327ef02edc52fed762..442f3df63013a993679b957ab32db1409020d96b
--- a/tasks.md
+++ b/tasks.md
@@ -83,10 +83,10 @@
 - [x] Implement wall collision detection for player and projectiles
 - [x] Add cover objects (crates, walls) throughout the facility
 - [x] Create navigation data for AI pathfinding
-- [ ] Implement room connectivity and doorways
-- [ ] Add environmental lighting setup
-- [ ] Create spawn points for player and bots
-- [ ] Design at least 3-5 distinct rooms with tactical variety
+- [x] Implement room connectivity and doorways
+- [x] Add environmental lighting setup
+- [x] Create spawn points for player and bots
+- [x] Design at least 3-5 distinct rooms with tactical variety
 - [x] Create src/environment folder developer-guide.md
 
 ## HUD System
@@ -99,7 +99,7 @@
 - [x] Create damage indicator visual feedback
 - [x] Add kill notification or counter display
 - [x] Create src/hud folder developer-guide.md
-- [ ] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
+- [x] Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)
 
 ## Special Effect: "The Glitch"
 
@@ -165,10 +165,10 @@
 - [x] Ensure all code folders have up-to-date developer-guide.md files
 - [x] Create README.md with installation and running instructions
 - [x] Document controls and gameplay in user-facing documentation
-- [ ] Add code comments for complex algorithms
-- [ ] Review and compact any developer-guide.md files over 500 lines
-- [ ] Verify no code files exceed 1000 lines
-- [ ] Verify no folders have more than 10 code files
+- [x] Add code comments for complex algorithms
+- [x] Review and compact any developer-guide.md files over 500 lines
+- [x] Verify no code files exceed 1000 lines
+- [x] Verify no folders have more than 10 code files
 
 ## Deployment & Build
 
diff --git a/tests/developer-guide.md b/tests/developer-guide.md
index 2b952ac68e620711205485ba965cd60e20129f64..6242575007932dfe6d4798fafeb15b94799f5d6a
--- a/tests/developer-guide.md
+++ b/tests/developer-guide.md
@@ -14,12 +14,12 @@
 
 ## Current Test Modules
 - `test_config.py`: validates immutable config defaults.
-- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, and loop update dispatch behavior.
+- `test_core_systems.py`: validates game clock timing controls, raycasting behavior, state transitions, input handling, loop update dispatch behavior, and runtime HUD event hook integration.
 - `test_player_and_weapons.py`: validates player health/economy/inventory/shooting and weapon cooldown/ammo behavior.
 - `test_advanced_combat_and_movement.py`: validates camera look, movement collision/slide, smooth weapon switching transitions, hit-scan shooting, weapon visuals, weapon behaviors, and projectile collisions.
 - `test_shop_ui.py`: validates shop wheel radial layout, `B`-toggle input behavior, pause/state synchronization while shopping, pricing visibility, affordability feedback, purchase validation, and owned-weapon selection/equip behavior.
 - `test_ai_and_economy.py`: validates bot health/state transitions, waypoint pathfinding, accuracy-varied bot shooting, death money-drop spawning, pickup collision, visual mapping, and player collection flow.
-- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
+- `test_environment_and_tactics.py`: validates multi-room facility structure, doorway connectivity traversal, spawn placement inside rooms, lighting validity, doorway-aware collision generation, environment nav graph usage, tactical cover/flank decisions, and wave difficulty scaling/spawning.
 - `test_hud.py`: validates HUD snapshot generation (health/ammo/money/crosshair), damage indicator timing, and kill notification/counter behavior.
 
 ## Running Tests
diff --git a/tests/test_core_systems.py b/tests/test_core_systems.py
index 35815703c3cd0a2ad37f693066bc2bcfda4587c5..33c09429835c3aa3ec24c06e268c1d6e9e211e49
--- a/tests/test_core_systems.py
+++ b/tests/test_core_systems.py
@@ -3,8 +3,10 @@
 from src.core.game_clock import GameClock
 from src.core.game_loop import GameLoop
 from src.core.raycasting import RaycastingSystem, RaycastTarget
+from src.core.runtime import RuntimeSession
 from src.core.game_state import GameState, GameStateManager
 from src.core.input_handler import InputHandler, InputSnapshot
+from src.player.player import Player
 
 
 def test_game_clock_tracks_delta_and_elapsed_time():
@@ -111,3 +113,24 @@
     loop.step(1.4)
     loop.step(1.8)
     assert deltas == pytest.approx([0.3, 0.4])
+
+
+def test_runtime_session_routes_damage_and_kill_events_to_hud_during_playing_frames():
+    manager = GameStateManager()
+    loop = GameLoop(state_manager=manager)
+    player = Player.with_starter_loadout(start_health=100, start_money=0)
+    session = RuntimeSession(player=player, game_loop=loop)
+
+    session.apply_player_damage(25)
+    session.register_bot_kill("Bot Delta")
+    not_playing_state = session.build_hud_state()
+    assert not_playing_state.damage_indicator.is_visible is False
+    assert not_playing_state.kill_count == 0
+
+    manager.transition_to(GameState.PLAYING)
+    loop.step(10.0)
+    playing_state = session.build_hud_state()
+    assert playing_state.health.current_health == 75
+    assert playing_state.damage_indicator.is_visible is True
+    assert playing_state.kill_count == 1
+    assert [note.message for note in playing_state.kill_notifications] == ["Bot Delta eliminated"]
diff --git a/tests/test_environment_and_tactics.py b/tests/test_environment_and_tactics.py
index 358cf2bcc6bdfa0fb8f6eb78015fefd655fef3e2..39561195bfbd238c0c2a6af012599cf70936592e
--- a/tests/test_environment_and_tactics.py
+++ b/tests/test_environment_and_tactics.py
@@ -15,6 +15,19 @@
     for doorway in layout.doorways:
         assert doorway.room_a in room_ids
         assert doorway.room_b in room_ids
+    assert layout.connected_room_ids("lobby") == room_ids
+
+
+def test_layout_has_spawn_points_inside_rooms_and_valid_lighting_profile():
+    layout = create_default_facility_layout()
+    assert layout.player_spawn_position() in [spawn.position for spawn in layout.spawn_points if spawn.team == "player"]
+    assert len(layout.bot_spawn_positions()) >= 1
+    for spawn in layout.spawn_points:
+        assert layout.find_room_for_position(spawn.position) is not None
+
+    assert layout.lighting.ambient_intensity >= 0.0
+    assert layout.lighting.directional_intensity > 0.0
+    assert layout.lighting_direction_length() > 0.0
 
 
 def test_collision_world_from_layout_respects_doorway_openings_and_cover():

tokens used
93,570
Implemented 9 incomplete tasks end-to-end and updated both required tracking files.

Completed tasks (now checked in `tasks.md`):
1. `Implement room connectivity and doorways`
2. `Add environmental lighting setup`
3. `Create spawn points for player and bots`
4. `Design at least 3-5 distinct rooms with tactical variety`
5. `Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)`
6. `Add code comments for complex algorithms`
7. `Review and compact any developer-guide.md files over 500 lines`
8. `Verify no code files exceed 1000 lines`
9. `Verify no folders have more than 10 code files`

Key implementation changes:
- Added HUD runtime integration in `src/core/runtime.py` and exports in `src/core/__init__.py`.
- Added environment connectivity/validation helpers in `src/environment/facility.py`.
- Added algorithm comments in `src/environment/collision.py` and `src/ai/tactics.py`.
- Extended tests in `tests/test_core_systems.py` and `tests/test_environment_and_tactics.py`.

Documentation updates (per-folder + ancestors):
- `src/core/developer-guide.md`
- `src/environment/developer-guide.md`
- `src/ai/developer-guide.md`
- `src/developer-guide.md`
- `tests/developer-guide.md`
- `developer-guide.md`

Required tracking files updated:
- `tasks.md` (checked completed items)
- `recent-changes.md` (detailed change log)

Validation:
- `pytest -q` passed: **47 passed**.
- Verified: no `.py` file >1000 lines; no folder has >10 Python code files; no developer guide >500 lines.
Implemented 9 incomplete tasks end-to-end and updated both required tracking files.

Completed tasks (now checked in `tasks.md`):
1. `Implement room connectivity and doorways`
2. `Add environmental lighting setup`
3. `Create spawn points for player and bots`
4. `Design at least 3-5 distinct rooms with tactical variety`
5. `Integrate HudOverlayController event hooks into the runtime update loop (damage + kill events)`
6. `Add code comments for complex algorithms`
7. `Review and compact any developer-guide.md files over 500 lines`
8. `Verify no code files exceed 1000 lines`
9. `Verify no folders have more than 10 code files`

Key implementation changes:
- Added HUD runtime integration in `src/core/runtime.py` and exports in `src/core/__init__.py`.
- Added environment connectivity/validation helpers in `src/environment/facility.py`.
- Added algorithm comments in `src/environment/collision.py` and `src/ai/tactics.py`.
- Extended tests in `tests/test_core_systems.py` and `tests/test_environment_and_tactics.py`.

Documentation updates (per-folder + ancestors):
- `src/core/developer-guide.md`
- `src/environment/developer-guide.md`
- `src/ai/developer-guide.md`
- `src/developer-guide.md`
- `tests/developer-guide.md`
- `developer-guide.md`

Required tracking files updated:
- `tasks.md` (checked completed items)
- `recent-changes.md` (detailed change log)

Validation:
- `pytest -q` passed: **47 passed**.
- Verified: no `.py` file >1000 lines; no folder has >10 Python code files; no developer guide >500 lines.
Process exited with code 0. Output length: 679992 chars.
End: 2026-02-08T19:00:52
__AGENTHARNESS_LIVE_DONE__
